Directory structure:
└── simpleyyt-ai-manus/
    ├── README.md
    ├── ai-manus.code-workspace
    ├── build.sh
    ├── dev.sh
    ├── docker-compose-development.yml
    ├── docker-compose-example.yml
    ├── docker-compose.yml
    ├── mcp.json.example
    ├── README_zh.md
    ├── run.sh
    ├── update_doc.sh
    ├── .env.example
    ├── backend/
    │   ├── README.md
    │   ├── dev.sh
    │   ├── Dockerfile
    │   ├── pytest.ini
    │   ├── README_zh.md
    │   ├── requirements.txt
    │   ├── run.sh
    │   ├── app/
    │   │   ├── __init__.py
    │   │   ├── main.py
    │   │   ├── application/
    │   │   │   ├── __init__.py
    │   │   │   ├── errors/
    │   │   │   │   └── exceptions.py
    │   │   │   └── services/
    │   │   │       ├── __init__.py
    │   │   │       ├── agent_service.py
    │   │   │       ├── auth_service.py
    │   │   │       ├── email_service.py
    │   │   │       ├── file_service.py
    │   │   │       └── token_service.py
    │   │   ├── core/
    │   │   │   └── config.py
    │   │   ├── domain/
    │   │   │   ├── __init__.py
    │   │   │   ├── external/
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── browser.py
    │   │   │   │   ├── cache.py
    │   │   │   │   ├── file.py
    │   │   │   │   ├── llm.py
    │   │   │   │   ├── message_queue.py
    │   │   │   │   ├── sandbox.py
    │   │   │   │   ├── search.py
    │   │   │   │   └── task.py
    │   │   │   ├── models/
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── agent.py
    │   │   │   │   ├── auth.py
    │   │   │   │   ├── event.py
    │   │   │   │   ├── file.py
    │   │   │   │   ├── mcp_config.py
    │   │   │   │   ├── memory.py
    │   │   │   │   ├── message.py
    │   │   │   │   ├── plan.py
    │   │   │   │   ├── search.py
    │   │   │   │   ├── session.py
    │   │   │   │   ├── tool_result.py
    │   │   │   │   ├── user.py
    │   │   │   │   └── sandbox/
    │   │   │   │       ├── file.py
    │   │   │   │       ├── shell.py
    │   │   │   │       └── supervisor.py
    │   │   │   ├── repositories/
    │   │   │   │   ├── agent_repository.py
    │   │   │   │   ├── mcp_repository.py
    │   │   │   │   ├── session_repository.py
    │   │   │   │   └── user_repository.py
    │   │   │   ├── services/
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── agent_domain_service.py
    │   │   │   │   ├── agent_task_runner.py
    │   │   │   │   ├── agents/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── base.py
    │   │   │   │   │   ├── execution.py
    │   │   │   │   │   └── planner.py
    │   │   │   │   ├── flows/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── base.py
    │   │   │   │   │   └── plan_act.py
    │   │   │   │   ├── prompts/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── execution.py
    │   │   │   │   │   ├── planner.py
    │   │   │   │   │   └── system.py
    │   │   │   │   └── tools/
    │   │   │   │       ├── __init__.py
    │   │   │   │       ├── base.py
    │   │   │   │       ├── browser.py
    │   │   │   │       ├── file.py
    │   │   │   │       ├── mcp.py
    │   │   │   │       ├── message.py
    │   │   │   │       ├── plan.py
    │   │   │   │       ├── search.py
    │   │   │   │       └── shell.py
    │   │   │   └── utils/
    │   │   │       └── json_parser.py
    │   │   ├── infrastructure/
    │   │   │   ├── __init__.py
    │   │   │   ├── logging.py
    │   │   │   ├── external/
    │   │   │   │   ├── __init__.py
    │   │   │   │   ├── browser/
    │   │   │   │   │   └── playwright_browser.py
    │   │   │   │   ├── cache/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   └── redis_cache.py
    │   │   │   │   ├── file/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   └── gridfsfile.py
    │   │   │   │   ├── llm/
    │   │   │   │   │   └── openai_llm.py
    │   │   │   │   ├── message_queue/
    │   │   │   │   │   └── redis_stream_queue.py
    │   │   │   │   ├── sandbox/
    │   │   │   │   │   └── docker_sandbox.py
    │   │   │   │   ├── search/
    │   │   │   │   │   ├── __init__.py
    │   │   │   │   │   ├── baidu_search.py
    │   │   │   │   │   ├── bing_search.py
    │   │   │   │   │   └── google_search.py
    │   │   │   │   └── task/
    │   │   │   │       └── redis_task.py
    │   │   │   ├── models/
    │   │   │   │   └── documents.py
    │   │   │   ├── repositories/
    │   │   │   │   ├── file_mcp_repository.py
    │   │   │   │   ├── mongo_agent_repository.py
    │   │   │   │   ├── mongo_session_repository.py
    │   │   │   │   └── user_repository.py
    │   │   │   ├── storage/
    │   │   │   │   ├── mongodb.py
    │   │   │   │   └── redis.py
    │   │   │   └── utils/
    │   │   │       └── llm_json_parser.py
    │   │   └── interfaces/
    │   │       ├── dependencies.py
    │   │       ├── api/
    │   │       │   ├── auth_routes.py
    │   │       │   ├── file_routes.py
    │   │       │   ├── routes.py
    │   │       │   └── session_routes.py
    │   │       ├── errors/
    │   │       │   └── exception_handlers.py
    │   │       ├── middleware/
    │   │       │   └── auth.py
    │   │       └── schemas/
    │   │           ├── auth.py
    │   │           ├── base.py
    │   │           ├── event.py
    │   │           ├── file.py
    │   │           ├── resource.py
    │   │           └── session.py
    │   └── tests/
    │       ├── conftest.py
    │       ├── requirements.txt
    │       ├── test_api_file.py
    │       ├── test_auth_routes.py
    │       └── test_sandbox_file.py
    ├── docs/
    │   ├── README.md
    │   ├── _navbar.md
    │   ├── _sidebar.md
    │   ├── architecture.md
    │   ├── CNAME
    │   ├── configuration.md
    │   ├── demo.md
    │   ├── index.html
    │   ├── mcp.md
    │   ├── quick_start.md
    │   ├── roadmap.md
    │   ├── run.sh
    │   ├── .nojekyll
    │   └── en/
    │       ├── README.md
    │       ├── _navbar.md
    │       ├── _sidebar.md
    │       ├── architecture.md
    │       ├── configuration.md
    │       ├── demo.md
    │       ├── mcp.md
    │       ├── quick_start.md
    │       └── roadmap.md
    ├── frontend/
    │   ├── README.md
    │   ├── components.json
    │   ├── docker-entrypoint.sh
    │   ├── Dockerfile
    │   ├── env.d.ts
    │   ├── index.html
    │   ├── nginx.conf
    │   ├── package.json
    │   ├── postcss.config.js
    │   ├── README_zh.md
    │   ├── tailwind.config.js
    │   ├── tsconfig.app.json
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── vite.config.ts
    │   ├── .dockerignore
    │   └── src/
    │       ├── App.vue
    │       ├── main.ts
    │       ├── api/
    │       │   ├── agent.ts
    │       │   ├── auth.ts
    │       │   ├── client.ts
    │       │   ├── file.ts
    │       │   └── index.ts
    │       ├── assets/
    │       │   ├── global.css
    │       │   └── theme.css
    │       ├── components/
    │       │   ├── AttachmentsMessage.vue
    │       │   ├── ChatBox.vue
    │       │   ├── ChatBoxFiles.vue
    │       │   ├── ChatMessage.vue
    │       │   ├── FilePanel.vue
    │       │   ├── FilePanelContent.vue
    │       │   ├── LeftPanel.vue
    │       │   ├── PlanPanel.vue
    │       │   ├── SessionFileList.vue
    │       │   ├── SessionItem.vue
    │       │   ├── SimpleBar.vue
    │       │   ├── TakeOverView.vue
    │       │   ├── ToolPanel.vue
    │       │   ├── ToolPanelContent.vue
    │       │   ├── ToolUse.vue
    │       │   ├── UserMenu.vue
    │       │   ├── VNCViewer.vue
    │       │   ├── filePreviews/
    │       │   │   ├── CodeFilePreview.vue
    │       │   │   ├── ImageFilePreview.vue
    │       │   │   ├── MarkdownFilePreview.vue
    │       │   │   └── UnknownFilePreview.vue
    │       │   ├── icons/
    │       │   │   ├── AttachmentIcon.vue
    │       │   │   ├── BrowserIcon.vue
    │       │   │   ├── ClearIcon.vue
    │       │   │   ├── CodeFileIcon.vue
    │       │   │   ├── EditIcon.vue
    │       │   │   ├── ErrorIcon.vue
    │       │   │   ├── FileIcon.vue
    │       │   │   ├── InfoIcon.vue
    │       │   │   ├── LoadingSpinnerIcon.vue
    │       │   │   ├── ManusIcon.vue
    │       │   │   ├── ManusLogoTextIcon.vue
    │       │   │   ├── ManusTextIcon.vue
    │       │   │   ├── SearchIcon.vue
    │       │   │   ├── SendIcon.vue
    │       │   │   ├── ShellIcon.vue
    │       │   │   ├── SpinnigIcon.vue
    │       │   │   ├── StepSuccessIcon.vue
    │       │   │   ├── SuccessIcon.vue
    │       │   │   └── TakeOverIcon.vue
    │       │   ├── login/
    │       │   │   ├── LoginForm.vue
    │       │   │   ├── RegisterForm.vue
    │       │   │   ├── ResetPasswordEmailForm.vue
    │       │   │   ├── ResetPasswordForm.vue
    │       │   │   └── ResetPasswordVerificationForm.vue
    │       │   ├── settings/
    │       │   │   ├── AccountSettings.vue
    │       │   │   ├── ChangePasswordDialog.vue
    │       │   │   ├── GeneralSettings.vue
    │       │   │   ├── ProfileSettings.vue
    │       │   │   ├── SettingsDialog.vue
    │       │   │   └── SettingsTabs.vue
    │       │   ├── toolViews/
    │       │   │   ├── BrowserToolView.vue
    │       │   │   ├── FileToolView.vue
    │       │   │   ├── McpToolView.vue
    │       │   │   ├── SearchToolView.vue
    │       │   │   └── ShellToolView.vue
    │       │   └── ui/
    │       │       ├── ContextMenu.vue
    │       │       ├── CustomDialog.vue
    │       │       ├── MonacoEditor.vue
    │       │       ├── Toast.vue
    │       │       ├── dialog/
    │       │       │   ├── Dialog.vue
    │       │       │   ├── DialogClose.vue
    │       │       │   ├── DialogContent.vue
    │       │       │   ├── DialogDescription.vue
    │       │       │   ├── DialogFooter.vue
    │       │       │   ├── DialogHeader.vue
    │       │       │   ├── DialogOverlay.vue
    │       │       │   ├── DialogScrollContent.vue
    │       │       │   ├── DialogTitle.vue
    │       │       │   ├── DialogTrigger.vue
    │       │       │   └── index.ts
    │       │       └── select/
    │       │           ├── index.ts
    │       │           ├── Select.vue
    │       │           ├── SelectContent.vue
    │       │           ├── SelectGroup.vue
    │       │           ├── SelectItem.vue
    │       │           ├── SelectItemText.vue
    │       │           ├── SelectLabel.vue
    │       │           ├── SelectScrollDownButton.vue
    │       │           ├── SelectScrollUpButton.vue
    │       │           ├── SelectSeparator.vue
    │       │           ├── SelectTrigger.vue
    │       │           └── SelectValue.vue
    │       ├── composables/
    │       │   ├── useAuth.ts
    │       │   ├── useContextMenu.ts
    │       │   ├── useDialog.ts
    │       │   ├── useFilePanel.ts
    │       │   ├── useI18n.ts
    │       │   ├── useLeftPanel.ts
    │       │   ├── useResizeObserver.ts
    │       │   ├── useRightPanel.ts
    │       │   ├── useSessionFileList.ts
    │       │   ├── useSettingsDialog.ts
    │       │   ├── useTime.ts
    │       │   └── useTool.ts
    │       ├── constants/
    │       │   ├── event.ts
    │       │   └── tool.ts
    │       ├── lib/
    │       │   └── utils.ts
    │       ├── locales/
    │       │   ├── en.ts
    │       │   ├── index.ts
    │       │   └── zh.ts
    │       ├── pages/
    │       │   ├── ChatPage.vue
    │       │   ├── HomePage.vue
    │       │   ├── LoginPage.vue
    │       │   └── MainLayout.vue
    │       ├── types/
    │       │   ├── event.ts
    │       │   ├── message.ts
    │       │   ├── panel.ts
    │       │   ├── response.ts
    │       │   ├── router.d.ts
    │       │   └── select.ts
    │       └── utils/
    │           ├── auth.ts
    │           ├── dom.ts
    │           ├── eventBus.ts
    │           ├── fileType.ts
    │           ├── time.ts
    │           └── toast.ts
    ├── mockserver/
    │   ├── dev.sh
    │   ├── Dockerfile
    │   ├── main.py
    │   ├── requirements.txt
    │   └── mock_datas/
    │       ├── browser_tools.yaml
    │       ├── default.yaml
    │       ├── file_tools.yaml
    │       ├── message_tools.yaml
    │       ├── search_tools.yaml
    │       └── shell_tools.yaml
    ├── sandbox/
    │   ├── README.md
    │   ├── Dockerfile
    │   ├── pytest.ini
    │   ├── README_zh.md
    │   ├── requirements.txt
    │   ├── supervisord.conf
    │   ├── app/
    │   │   ├── __init__.py
    │   │   ├── main.py
    │   │   ├── api/
    │   │   │   ├── __init__.py
    │   │   │   ├── router.py
    │   │   │   └── v1/
    │   │   │       ├── __init__.py
    │   │   │       ├── file.py
    │   │   │       ├── shell.py
    │   │   │       └── supervisor.py
    │   │   ├── core/
    │   │   │   ├── __init__.py
    │   │   │   ├── config.py
    │   │   │   ├── exceptions.py
    │   │   │   └── middleware.py
    │   │   ├── models/
    │   │   │   ├── __init__.py
    │   │   │   ├── file.py
    │   │   │   ├── shell.py
    │   │   │   └── supervisor.py
    │   │   ├── schemas/
    │   │   │   ├── __init__.py
    │   │   │   ├── file.py
    │   │   │   ├── response.py
    │   │   │   └── shell.py
    │   │   └── services/
    │   │       ├── __init__.py
    │   │       ├── file.py
    │   │       ├── shell.py
    │   │       └── supervisor.py
    │   ├── resource/
    │   │   └── test_upload_unique.txt
    │   └── tests/
    │       ├── conftest.py
    │       ├── requirements.txt
    │       └── test_api_file.py
    └── .github/
        └── workflows/
            └── docker-build-and-push.yml

================================================
FILE: README.md
================================================
# AI Manus

English | [中文](README_zh.md) | [Documents](https://docs.ai-manus.com/#/en/)

[![GitHub stars](https://img.shields.io/github/stars/simpleyyt/ai-manus?style=social)](https://github.com/simpleyyt/ai-manus/stargazers)
&ensp;
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

AI Manus is a general-purpose AI Agent system that supports running various tools and operations in a sandbox environment.

Enjoy your own agent with AI Manus!

👏 Join [QQ Group(1005477581)](https://qun.qq.com/universal-share/share?ac=1&authKey=p4X3Da5iMpR4liAenxwvhs7IValPKiCFtUevRlJouz9qSTSZsMnPJc3hzsJjgQYv&busi_data=eyJncm91cENvZGUiOiIxMDA1NDc3NTgxIiwidG9rZW4iOiJNZmUrTmQ0UzNDZDNqNDFVdjVPS1VCRkJGRWVlV0R3RFJSRVFoZDAwRjFDeUdUM0t6aUIyczlVdzRjV1BYN09IIiwidWluIjoiMzQyMjExODE1In0%3D&data=C3B-E6BlEbailV32co77iXL5vxPIhtD9y_itWLSq50hKqosO_55_isOZym2Faaq4hs9-517tUY8GSWaDwPom-A&svctype=4&tempid=h5_group_info)

## Demos

### Basic Features

https://github.com/user-attachments/assets/37060a09-c647-4bcb-920c-959f7fa73ebe

### Browser Use

* Task: Latest LLM papers

<https://github.com/user-attachments/assets/4e35bc4d-024a-4617-8def-a537a94bd285>

### Code Use

* Task: Write a complex Python example

<https://github.com/user-attachments/assets/765ea387-bb1c-4dc2-b03e-716698feef77>


## Key Features

 * Deployment: Minimal deployment requires only an LLM service, with no dependency on other external services.
 * Tools: Supports Terminal, Browser, File, Web Search, and messaging tools with real-time viewing and takeover capabilities, supports external MCP tool integration.
 * Sandbox: Each task is allocated a separate sandbox that runs in a local Docker environment.
 * Task Sessions: Session history is managed through MongoDB/Redis, supporting background tasks.
 * Conversations: Supports stopping and interrupting, file upload and download.
 * Multilingual: Supports both Chinese and English.
 * Authentication: User login and authentication.

## Development Roadmap

 * Tools: Support for Deploy & Expose.
 * Sandbox: Support for mobile and Windows computer access.
 * Deployment: Support for K8s and Docker Swarm multi-cluster deployment.

### Overall Design

![Image](https://github.com/user-attachments/assets/69775011-1eb7-452f-adaf-cd6603a4dde5)

**When a user initiates a conversation:**

1. Web sends a request to create an Agent to the Server, which creates a Sandbox through `/var/run/docker.sock` and returns a session ID.
2. The Sandbox is an Ubuntu Docker environment that starts Chrome browser and API services for tools like File/Shell.
3. Web sends user messages to the session ID, and when the Server receives user messages, it forwards them to the PlanAct Agent for processing.
4. During processing, the PlanAct Agent calls relevant tools to complete tasks.
5. All events generated during Agent processing are sent back to Web via SSE.

**When users browse tools:**

- Browser:
    1. The Sandbox's headless browser starts a VNC service through xvfb and x11vnc, and converts VNC to websocket through websockify.
    2. Web's NoVNC component connects to the Sandbox through the Server's Websocket Forward, enabling browser viewing.
- Other tools: Other tools work on similar principles.

## Environment Requirements

This project primarily relies on Docker for development and deployment, requiring a relatively new version of Docker:
- Docker 20.10+
- Docker Compose

Model capability requirements:
- Compatible with OpenAI interface
- Support for FunctionCall
- Support for Json Format output

Deepseek and GPT models are recommended.

## Deployment Guide

Docker Compose is recommended for deployment:

<!-- docker-compose-example.yml -->
```yaml
services:
  frontend:
    image: simpleyyt/manus-frontend
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: simpleyyt/manus-backend
    depends_on:
      - sandbox
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    environment:
      # OpenAI API base URL
      - API_BASE=https://api.openai.com/v1
      # OpenAI API key, replace with your own
      - API_KEY=sk-xxxx
      # LLM model name
      - MODEL_NAME=gpt-4o
      # LLM temperature parameter, controls randomness
      - TEMPERATURE=0.7
      # Maximum tokens for LLM response
      - MAX_TOKENS=2000

      # MongoDB connection URI
      #- MONGODB_URI=mongodb://mongodb:27017
      # MongoDB database name
      #- MONGODB_DATABASE=manus
      # MongoDB username (optional)
      #- MONGODB_USERNAME=
      # MongoDB password (optional)
      #- MONGODB_PASSWORD=

      # Redis server hostname
      #- REDIS_HOST=redis
      # Redis server port
      #- REDIS_PORT=6379
      # Redis database number
      #- REDIS_DB=0
      # Redis password (optional)
      #- REDIS_PASSWORD=

      # Sandbox server address (optional)
      #- SANDBOX_ADDRESS=
      # Docker image used for the sandbox
      - SANDBOX_IMAGE=simpleyyt/manus-sandbox
      # Prefix for sandbox container names
      - SANDBOX_NAME_PREFIX=sandbox
      # Time-to-live for sandbox containers in minutes
      - SANDBOX_TTL_MINUTES=30
      # Docker network for sandbox containers
      - SANDBOX_NETWORK=manus-network
      # Chrome browser arguments for sandbox (optional)
      #- SANDBOX_CHROME_ARGS=
      # HTTPS proxy for sandbox (optional)
      #- SANDBOX_HTTPS_PROXY=
      # HTTP proxy for sandbox (optional)
      #- SANDBOX_HTTP_PROXY=
      # No proxy hosts for sandbox (optional)
      #- SANDBOX_NO_PROXY=
      
      # Search engine configuration
      # Options: baidu, google, bing
      - SEARCH_PROVIDER=bing

      # Google search configuration, only used when SEARCH_PROVIDER=google
      #- GOOGLE_SEARCH_API_KEY=
      #- GOOGLE_SEARCH_ENGINE_ID=

      # Auth configuration
      # Options: password, none, local
      - AUTH_PROVIDER=password

      # Password auth configuration, only used when AUTH_PROVIDER=password
      - PASSWORD_SALT=
      - PASSWORD_HASH_ROUNDS=10
      - PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

      # Local auth configuration, only used when AUTH_PROVIDER=local
      #- LOCAL_AUTH_EMAIL=admin@example.com
      #- LOCAL_AUTH_PASSWORD=admin

      # JWT configuration
      - JWT_SECRET_KEY=your-secret-key-here
      - JWT_ALGORITHM=HS256
      - JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
      - JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

      # Email configuration
      # Only used when AUTH_PROVIDER=password
      #- EMAIL_HOST=smtp.gmail.com
      #- EMAIL_PORT=587
      #- EMAIL_USERNAME=your-email@gmail.com
      #- EMAIL_PASSWORD=your-password
      #- EMAIL_FROM=your-email@gmail.com

      # MCP configuration file path
      #- MCP_CONFIG_PATH=/etc/mcp.json

      # Application log level
      - LOG_LEVEL=INFO

  sandbox:
    image: simpleyyt/manus-sandbox
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge
```
<!-- /docker-compose-example.yml -->

Save as `docker-compose.yml` file, and run:

```shell
docker compose up -d
```

> Note: If you see `sandbox-1 exited with code 0`, this is normal, as it ensures the sandbox image is successfully pulled locally.

Open your browser and visit <http://localhost:5173> to access Manus.

## Development Guide

### Project Structure

This project consists of three independent sub-projects:

* `frontend`: manus frontend
* `backend`: Manus backend
* `sandbox`: Manus sandbox

### Environment Setup

1. Download the project:
```bash
git clone https://github.com/simpleyyt/ai-manus.git
cd ai-manus
```

2. Copy the configuration file:
```bash
cp .env.example .env
```

3. Modify the configuration file:

<!-- .env.example -->
```env
# Model provider configuration
API_KEY=
API_BASE=http://mockserver:8090/v1

# Model configuration
MODEL_NAME=deepseek-chat
TEMPERATURE=0.7
MAX_TOKENS=2000

# MongoDB configuration
#MONGODB_URI=mongodb://mongodb:27017
#MONGODB_DATABASE=manus
#MONGODB_USERNAME=
#MONGODB_PASSWORD=

# Redis configuration
#REDIS_HOST=redis
#REDIS_PORT=6379
#REDIS_DB=0
#REDIS_PASSWORD=

# Sandbox configuration
#SANDBOX_ADDRESS=
SANDBOX_IMAGE=simpleyyt/manus-sandbox
SANDBOX_NAME_PREFIX=sandbox
SANDBOX_TTL_MINUTES=30
SANDBOX_NETWORK=manus-network
#SANDBOX_CHROME_ARGS=
#SANDBOX_HTTPS_PROXY=
#SANDBOX_HTTP_PROXY=
#SANDBOX_NO_PROXY=

# Search engine configuration
# Options: baidu, google, bing
SEARCH_PROVIDER=bing

# Google search configuration, only used when SEARCH_PROVIDER=google
#GOOGLE_SEARCH_API_KEY=
#GOOGLE_SEARCH_ENGINE_ID=

# Auth configuration
# Options: password, none, local
AUTH_PROVIDER=password

# Password auth configuration, only used when AUTH_PROVIDER=password
PASSWORD_SALT=
PASSWORD_HASH_ROUNDS=10
PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

# Local auth configuration, only used when AUTH_PROVIDER=local
#LOCAL_AUTH_EMAIL=admin@example.com
#LOCAL_AUTH_PASSWORD=admin

# JWT configuration
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Email configuration
# Only used when AUTH_PROVIDER=password
#EMAIL_HOST=smtp.gmail.com
#EMAIL_PORT=587
#EMAIL_USERNAME=your-email@gmail.com
#EMAIL_PASSWORD=your-password
#EMAIL_FROM=your-email@gmail.com

# MCP configuration
#MCP_CONFIG_PATH=/etc/mcp.json

# Log configuration
LOG_LEVEL=INFO
```
<!-- /.env.example -->

### Development and Debugging

1. Run in debug mode:
```bash
# Equivalent to docker compose -f docker-compose-development.yaml up
./dev.sh up
```

All services will run in reload mode, and code changes will be automatically reloaded. The exposed ports are as follows:
- 5173: Web frontend port
- 8000: Server API service port
- 8080: Sandbox API service port
- 5900: Sandbox VNC port
- 9222: Sandbox Chrome browser CDP port

> *Note: In Debug mode, only one sandbox will be started globally*

2. When dependencies change (requirements.txt or package.json), clean up and rebuild:
```bash
# Clean up all related resources
./dev.sh down -v

# Rebuild images
./dev.sh build

# Run in debug mode
./dev.sh up
```

### Image Publishing

```bash
export IMAGE_REGISTRY=your-registry-url
export IMAGE_TAG=latest

# Build images
./run build

# Push to the corresponding image repository
./run push
``` 



================================================
FILE: ai-manus.code-workspace
================================================
{
	"folders": [
		{
			"path": "."
		},
		{
			"path": "backend"
		},
		{
			"path": "frontend"
		},
		{
			"path": "sandbox"
		},
		{
			"path": "mockserver"
		},
		{
			"path": "docs"
		}
	],
	"settings": {},
	"tasks": {
		"version": "2.0.0",
		"tasks": [
			{
				"label": "dev",
				"type": "shell",
				"command": "./dev.sh up -d",
				"problemMatcher": []
			},
			{
				"label": "reset mock server",
				"type": "shell",
				"command": "touch mockserver/main.py",
				"problemMatcher": []
			},
			{
				"label": "run docs",
				"type": "shell",
				"command": "docsify serve docs",
				"problemMatcher": []
			},
			{
				"label": "sandbox logs",
				"type": "shell",
				"command": "./dev.sh logs -f sandbox",
				"problemMatcher": []
			},
			{
				"label": "frontend logs",
				"type": "shell",
				"command": "./dev.sh logs -f frontend",
				"problemMatcher": []
			},
			{
				"label": "backend logs",
				"type": "shell",
				"command": "./dev.sh logs -f backend",
				"problemMatcher": []
			}
		]
	}
}


================================================
FILE: build.sh
================================================
#!/bin/bash

export BUILDX_NO_DEFAULT_ATTESTATIONS=1
docker buildx bake "$@"



================================================
FILE: dev.sh
================================================
#!/bin/bash

# Determine which Docker Compose command to use
if command -v docker &> /dev/null && docker compose version &> /dev/null; then
    COMPOSE="docker compose"
elif command -v docker-compose &> /dev/null; then
    COMPOSE="docker-compose"
else
    echo "Error: Neither docker compose nor docker-compose command found" >&2
    exit 1
fi


# Execute Docker Compose command
$COMPOSE -f docker-compose-development.yml "$@"



================================================
FILE: docker-compose-development.yml
================================================
services:
  frontend-dev:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: build-stage  # Use build stage image instead of production image
    command: ["npm", "run", "dev", "--", "--host", "0.0.0.0"]  # Start in development mode and listen on all network interfaces
    volumes:
      - ./frontend:/app  # Mount source code directory
      - /app/node_modules  # Avoid overwriting container's node_modules
    ports:
      - "5173:5173"  # Vite default development port
    environment:
      - NODE_ENV=development
      #- VITE_API_URL=http://127.0.0.1:8000
      - BACKEND_URL=http://backend:8000
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: ["./dev.sh"]  # Start in reload mode
    volumes:
      - ./backend:/app  # Mount source code directory
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /app/__pycache__  # Avoid overwriting cache files
      - /app/.venv  # Avoid overwriting virtual environment
    ports:
      - "8000:8000"
    depends_on:
      sandbox:
        condition: service_started
        required: false
      mongodb:
        condition: service_started
        required: true
      redis:
        condition: service_started
        required: true
    restart: unless-stopped
    networks:
      - manus-network
    env_file:
      - .env
    environment:
      - SANDBOX_ADDRESS=sandbox # Use single container as sandbox

  sandbox:
    build:
      context: ./sandbox
      dockerfile: Dockerfile
    hostname: sandbox
    volumes:
      - ./sandbox:/app  # Mount source code directory
      - ./sandbox/supervisord.conf:/etc/supervisor/conf.d/app.conf
      - /app/__pycache__  # Avoid overwriting cache files
      - /app/.venv  # Avoid overwriting virtual environment
    ports:
      #- "9222:9222"
      - "5902:5900"
      #- "5901:5901"
      - "8080:8080"
    environment:
      - UVI_ARGS="--reload"
      - LOG_LEVEL=${LOG_LEVEL:-DEBUG}
    restart: unless-stopped
    networks:
      - manus-network

  mockserver:
    build:
      context: ./mockserver
      dockerfile: Dockerfile
    volumes:
      - ./mockserver:/app  # Mount source code directory
      - /app/__pycache__  # Avoid overwriting cache files
      - /app/.venv  # Avoid overwriting virtual environment
    restart: unless-stopped
    environment:
      - MOCK_DATA_FILE=default.yaml
      - MOCK_DELAY=1
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    ports:
      - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge



================================================
FILE: docker-compose-example.yml
================================================
services:
  frontend:
    image: simpleyyt/manus-frontend
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: simpleyyt/manus-backend
    depends_on:
      - sandbox
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    environment:
      # OpenAI API base URL
      - API_BASE=https://api.openai.com/v1
      # OpenAI API key, replace with your own
      - API_KEY=sk-xxxx
      # LLM model name
      - MODEL_NAME=gpt-4o
      # LLM temperature parameter, controls randomness
      - TEMPERATURE=0.7
      # Maximum tokens for LLM response
      - MAX_TOKENS=2000

      # MongoDB connection URI
      #- MONGODB_URI=mongodb://mongodb:27017
      # MongoDB database name
      #- MONGODB_DATABASE=manus
      # MongoDB username (optional)
      #- MONGODB_USERNAME=
      # MongoDB password (optional)
      #- MONGODB_PASSWORD=

      # Redis server hostname
      #- REDIS_HOST=redis
      # Redis server port
      #- REDIS_PORT=6379
      # Redis database number
      #- REDIS_DB=0
      # Redis password (optional)
      #- REDIS_PASSWORD=

      # Sandbox server address (optional)
      #- SANDBOX_ADDRESS=
      # Docker image used for the sandbox
      - SANDBOX_IMAGE=simpleyyt/manus-sandbox
      # Prefix for sandbox container names
      - SANDBOX_NAME_PREFIX=sandbox
      # Time-to-live for sandbox containers in minutes
      - SANDBOX_TTL_MINUTES=30
      # Docker network for sandbox containers
      - SANDBOX_NETWORK=manus-network
      # Chrome browser arguments for sandbox (optional)
      #- SANDBOX_CHROME_ARGS=
      # HTTPS proxy for sandbox (optional)
      #- SANDBOX_HTTPS_PROXY=
      # HTTP proxy for sandbox (optional)
      #- SANDBOX_HTTP_PROXY=
      # No proxy hosts for sandbox (optional)
      #- SANDBOX_NO_PROXY=
      
      # Search engine configuration
      # Options: baidu, google, bing
      - SEARCH_PROVIDER=bing

      # Google search configuration, only used when SEARCH_PROVIDER=google
      #- GOOGLE_SEARCH_API_KEY=
      #- GOOGLE_SEARCH_ENGINE_ID=

      # Auth configuration
      # Options: password, none, local
      - AUTH_PROVIDER=password

      # Password auth configuration, only used when AUTH_PROVIDER=password
      - PASSWORD_SALT=
      - PASSWORD_HASH_ROUNDS=10
      - PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

      # Local auth configuration, only used when AUTH_PROVIDER=local
      #- LOCAL_AUTH_EMAIL=admin@example.com
      #- LOCAL_AUTH_PASSWORD=admin

      # JWT configuration
      - JWT_SECRET_KEY=your-secret-key-here
      - JWT_ALGORITHM=HS256
      - JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
      - JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

      # Email configuration
      # Only used when AUTH_PROVIDER=password
      #- EMAIL_HOST=smtp.gmail.com
      #- EMAIL_PORT=587
      #- EMAIL_USERNAME=your-email@gmail.com
      #- EMAIL_PASSWORD=your-password
      #- EMAIL_FROM=your-email@gmail.com

      # MCP configuration file path
      #- MCP_CONFIG_PATH=/etc/mcp.json

      # Application log level
      - LOG_LEVEL=INFO

  sandbox:
    image: simpleyyt/manus-sandbox
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge


================================================
FILE: docker-compose.yml
================================================
services:
  frontend:
    image: ${IMAGE_REGISTRY:-simpleyyt}/manus-frontend:${IMAGE_TAG:-latest}
    build:
      context: ./frontend
      dockerfile: Dockerfile
      x-bake:
        platforms:
          - linux/amd64
          - linux/arm64
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: ${IMAGE_REGISTRY:-simpleyyt}/manus-backend:${IMAGE_TAG:-latest}
    build:
      context: ./backend
      dockerfile: Dockerfile
      x-bake:
        platforms:
          - linux/amd64
          - linux/arm64
    depends_on:
      - sandbox
      - mongodb
      - redis
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    env_file:
      - .env

  sandbox:
    image: ${IMAGE_REGISTRY:-simpleyyt}/manus-sandbox:${IMAGE_TAG:-latest}
    build:
      context: ./sandbox
      dockerfile: Dockerfile
      x-bake:
        platforms:
          - linux/amd64
          - linux/arm64
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge


================================================
FILE: mcp.json.example
================================================
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/tmp"
      ],
      "transport": "stdio",
      "enabled": true,
      "description": "Access to local filesystem"
    },
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "transport": "stdio",
      "enabled": true,
      "description": "GitHub API integration",
      "env": {
        "GITHUB_TOKEN": "your-github-token"
      }
    },
    "example-http": {
      "url": "http://localhost:8080/mcp",
      "transport": "sse",
      "enabled": true,
      "description": "Example HTTP MCP server",
      "headers": {
        "Authorization": "Bearer your-token"
      }
    },
    "example-streamable": {
      "url": "http://localhost:9090/mcp",
      "transport": "streamable-http",
      "enabled": true,
      "description": "Example streamable HTTP MCP server"
    }
  }
} 


================================================
FILE: README_zh.md
================================================
# AI Manus

[English](README.md) | 中文 | [文档](https://docs.ai-manus.com)

[![GitHub stars](https://img.shields.io/github/stars/simpleyyt/ai-manus?style=social)](https://github.com/simpleyyt/ai-manus/stargazers)
&ensp;
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

AI Manus 是一个通用的 AI Agent 系统，支持在沙盒环境中运行各种工具和操作。

用 AI Manus 开启你的智能体之旅吧！

👏 欢迎加入 [QQ群(1005477581)](https://qun.qq.com/universal-share/share?ac=1&authKey=p4X3Da5iMpR4liAenxwvhs7IValPKiCFtUevRlJouz9qSTSZsMnPJc3hzsJjgQYv&busi_data=eyJncm91cENvZGUiOiIxMDA1NDc3NTgxIiwidG9rZW4iOiJNZmUrTmQ0UzNDZDNqNDFVdjVPS1VCRkJGRWVlV0R3RFJSRVFoZDAwRjFDeUdUM0t6aUIyczlVdzRjV1BYN09IIiwidWluIjoiMzQyMjExODE1In0%3D&data=C3B-E6BlEbailV32co77iXL5vxPIhtD9y_itWLSq50hKqosO_55_isOZym2Faaq4hs9-517tUY8GSWaDwPom-A&svctype=4&tempid=h5_group_info)

## 示例

### 基本功能

https://github.com/user-attachments/assets/37060a09-c647-4bcb-920c-959f7fa73ebe

### Browser Use

* 任务：llm 最新论文

https://github.com/user-attachments/assets/8f7788a4-fbda-49f5-b836-949a607c64ac

### Code Use

* 任务：写一个复杂的 python 示例

https://github.com/user-attachments/assets/5cb2240b-0984-4db0-8818-a24f81624b04


## 主要特性

 * 部署：最小只需要一个 LLM 服务即可完成部署，不需要依赖其它外部服务。
 * 工具：支持 Terminal、Browser、File、Web Search、消息工具，并支持实查看和接管，支持外部 MCP 工具集成。
 * 沙盒：每个 Task 会分配单独的一个沙盒，沙盒在本地 Dock 环境里面运行。
 * 任务会话：通过 Mongo/Redis 对会话历史进行管理，支持后台任务。
 * 对话：支持停止与打断，支持文件上传与下载。
 * 多语言：支持中文与英文。
 * 认证：用户登录与认证。

## 开发计划

 * 工具：支持 Deploy & Expose。
 * 沙盒：支持手机与 Windows 电脑接入。
 * 部署：支持 K8s 和 Dock Swarm 多集群部署。

## 环境要求

本项目主要依赖Docker进行开发与部署，需要安装较新版本的Docker：
- Docker 20.10+
- Docker Compose

模型能力要求：
- 兼容OpenAI接口
- 支持FunctionCall
- 支持Json Format输出

推荐使用Deepseek与GPT模型。


## 部署指南

推荐使用Docker Compose进行部署：

<!-- docker-compose-example.yml -->
```yaml
services:
  frontend:
    image: simpleyyt/manus-frontend
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: simpleyyt/manus-backend
    depends_on:
      - sandbox
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    environment:
      # OpenAI API base URL
      - API_BASE=https://api.openai.com/v1
      # OpenAI API key, replace with your own
      - API_KEY=sk-xxxx
      # LLM model name
      - MODEL_NAME=gpt-4o
      # LLM temperature parameter, controls randomness
      - TEMPERATURE=0.7
      # Maximum tokens for LLM response
      - MAX_TOKENS=2000

      # MongoDB connection URI
      #- MONGODB_URI=mongodb://mongodb:27017
      # MongoDB database name
      #- MONGODB_DATABASE=manus
      # MongoDB username (optional)
      #- MONGODB_USERNAME=
      # MongoDB password (optional)
      #- MONGODB_PASSWORD=

      # Redis server hostname
      #- REDIS_HOST=redis
      # Redis server port
      #- REDIS_PORT=6379
      # Redis database number
      #- REDIS_DB=0
      # Redis password (optional)
      #- REDIS_PASSWORD=

      # Sandbox server address (optional)
      #- SANDBOX_ADDRESS=
      # Docker image used for the sandbox
      - SANDBOX_IMAGE=simpleyyt/manus-sandbox
      # Prefix for sandbox container names
      - SANDBOX_NAME_PREFIX=sandbox
      # Time-to-live for sandbox containers in minutes
      - SANDBOX_TTL_MINUTES=30
      # Docker network for sandbox containers
      - SANDBOX_NETWORK=manus-network
      # Chrome browser arguments for sandbox (optional)
      #- SANDBOX_CHROME_ARGS=
      # HTTPS proxy for sandbox (optional)
      #- SANDBOX_HTTPS_PROXY=
      # HTTP proxy for sandbox (optional)
      #- SANDBOX_HTTP_PROXY=
      # No proxy hosts for sandbox (optional)
      #- SANDBOX_NO_PROXY=
      
      # Search engine configuration
      # Options: baidu, google, bing
      - SEARCH_PROVIDER=bing

      # Google search configuration, only used when SEARCH_PROVIDER=google
      #- GOOGLE_SEARCH_API_KEY=
      #- GOOGLE_SEARCH_ENGINE_ID=

      # Auth configuration
      # Options: password, none, local
      - AUTH_PROVIDER=password

      # Password auth configuration, only used when AUTH_PROVIDER=password
      - PASSWORD_SALT=
      - PASSWORD_HASH_ROUNDS=10
      - PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

      # Local auth configuration, only used when AUTH_PROVIDER=local
      #- LOCAL_AUTH_EMAIL=admin@example.com
      #- LOCAL_AUTH_PASSWORD=admin

      # JWT configuration
      - JWT_SECRET_KEY=your-secret-key-here
      - JWT_ALGORITHM=HS256
      - JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
      - JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

      # Email configuration
      # Only used when AUTH_PROVIDER=password
      #- EMAIL_HOST=smtp.gmail.com
      #- EMAIL_PORT=587
      #- EMAIL_USERNAME=your-email@gmail.com
      #- EMAIL_PASSWORD=your-password
      #- EMAIL_FROM=your-email@gmail.com

      # MCP configuration file path
      #- MCP_CONFIG_PATH=/etc/mcp.json

      # Application log level
      - LOG_LEVEL=INFO

  sandbox:
    image: simpleyyt/manus-sandbox
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge
```
<!-- /docker-compose-example.yml -->

保存成`docker-compose.yml`文件，并运行

```shell
docker compose up -d
```

> 注意：如果提示`sandbox-1 exited with code 0`，这是正常的，这是为了让 sandbox 镜像成功拉取到本地。

打开浏览器访问<http://localhost:5173>即可访问 Manus。

## 开发指南

### 项目结构

本项目由三个独立的子项目组成：

* `frontend`: manus 前端
* `backend`: Manus 后端
* `sandbox`: Manus 沙盒

### 整体设计

![Image](https://github.com/user-attachments/assets/69775011-1eb7-452f-adaf-cd6603a4dde5)

**当用户发起对话时：**

1. Web 向 Server 发送创建 Agent 请求，Server 通过`/var/run/docker.sock`创建出 Sandbox，并返回会话 ID。
2. Sandbox 是一个 Ubuntu Docker 环境，里面会启动 chrome 浏览器及 File/Shell 等工具的 API 服务。
3. Web 往会话 ID 中发送用户消息，Server 收到用户消息后，将消息发送给 PlanAct Agent 处理。
4. PlanAct Agent 处理过程中会调用相关工具完成任务。
5. Agent 处理过程中产生的所有事件通过 SSE 发回 Web。

**当用户浏览工具时：**

- 浏览器：
    1. Sandbox 的无头浏览器通过 xvfb 与 x11vnc 启动了 vnc 服务，并且通过 websockify 将 vnc 转化成 websocket。
    2. Web 的 NoVNC 组件通过 Server 的 Websocket Forward 转发到 Sandbox，实现浏览器查看。
- 其它工具：其它工具原理也是差不多。

### 环境准备

1. 下载项目：
```bash
git clone https://github.com/simpleyyt/ai-manus.git
cd ai-manus
```

2. 复制配置文件：
```bash
cp .env.example .env
```

3. 修改配置文件：

<!-- .env.example -->
```env
# Model provider configuration
API_KEY=
API_BASE=http://mockserver:8090/v1

# Model configuration
MODEL_NAME=deepseek-chat
TEMPERATURE=0.7
MAX_TOKENS=2000

# MongoDB configuration
#MONGODB_URI=mongodb://mongodb:27017
#MONGODB_DATABASE=manus
#MONGODB_USERNAME=
#MONGODB_PASSWORD=

# Redis configuration
#REDIS_HOST=redis
#REDIS_PORT=6379
#REDIS_DB=0
#REDIS_PASSWORD=

# Sandbox configuration
#SANDBOX_ADDRESS=
SANDBOX_IMAGE=simpleyyt/manus-sandbox
SANDBOX_NAME_PREFIX=sandbox
SANDBOX_TTL_MINUTES=30
SANDBOX_NETWORK=manus-network
#SANDBOX_CHROME_ARGS=
#SANDBOX_HTTPS_PROXY=
#SANDBOX_HTTP_PROXY=
#SANDBOX_NO_PROXY=

# Search engine configuration
# Options: baidu, google, bing
SEARCH_PROVIDER=bing

# Google search configuration, only used when SEARCH_PROVIDER=google
#GOOGLE_SEARCH_API_KEY=
#GOOGLE_SEARCH_ENGINE_ID=

# Auth configuration
# Options: password, none, local
AUTH_PROVIDER=password

# Password auth configuration, only used when AUTH_PROVIDER=password
PASSWORD_SALT=
PASSWORD_HASH_ROUNDS=10
PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

# Local auth configuration, only used when AUTH_PROVIDER=local
#LOCAL_AUTH_EMAIL=admin@example.com
#LOCAL_AUTH_PASSWORD=admin

# JWT configuration
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Email configuration
# Only used when AUTH_PROVIDER=password
#EMAIL_HOST=smtp.gmail.com
#EMAIL_PORT=587
#EMAIL_USERNAME=your-email@gmail.com
#EMAIL_PASSWORD=your-password
#EMAIL_FROM=your-email@gmail.com

# MCP configuration
#MCP_CONFIG_PATH=/etc/mcp.json

# Log configuration
LOG_LEVEL=INFO
```
<!-- /.env.example -->

### 开发调试

1. 运行调试：
```bash
# 相当于 docker compose -f docker-compose-development.yaml up
./dev.sh up
```

各服务会以 reload 模式运行，代码改动会自动重新加载。暴露的端口如下：
- 5173: Web前端端口
- 8000: Server API服务端口
- 8080: Sandbox API服务端口
- 5900: Sandbox VNC端口
- 9222: Sandbox Chrome浏览器CDP端口

> *注意：在 Debug 模式全局只会启动一个沙盒*

2. 当依赖变化时（requirements.txt或package.json），清理并重新构建：
```bash
# 清理所有相关资源
./dev.sh down -v

# 重新构建镜像
./dev.sh build

# 调试运行
./dev.sh up
```

### 镜像发布

```bash
export IMAGE_REGISTRY=your-registry-url
export IMAGE_TAG=latest

# 构建镜像
./run build

# 推送到相应的镜像仓库
./run push
```



================================================
FILE: run.sh
================================================
#!/bin/bash

# Determine which Docker Compose command to use
if command -v docker &> /dev/null && docker compose version &> /dev/null; then
    COMPOSE="docker compose"
elif command -v docker-compose &> /dev/null; then
    COMPOSE="docker-compose"
else
    echo "Error: Neither docker compose nor docker-compose command found" >&2
    exit 1
fi


# Execute Docker Compose command
$COMPOSE -f docker-compose.yml "$@"



================================================
FILE: update_doc.sh
================================================
#!/bin/bash

# Script Description: Replace content surrounded by specific comments in all md files with corresponding file content
# Universal format: <!-- filename --> content <!-- /filename -->
# The script will automatically detect all comment tags in this format and replace them with the corresponding file content

# ===============================
# File Sync Configuration Area - Add files to sync here
# ===============================
# Format: filename:code_type (separated by colon)
# If code_type is not specified, the script will automatically infer it based on file extension

# Files to sync (format: "filename:code_type")
FILES_TO_SYNC=(
    "docker-compose-example.yml:yaml"
    ".env.example:env"
    # Add more files, uncomment and modify the following examples:
    # "package.json:json"
    # "requirements.txt:text"
    # "Dockerfile:dockerfile"
    # "nginx.conf:nginx"
    # "config.yaml:yaml"
    # "startup.sh:bash"
)

# ===============================
# Script Function Area
# ===============================

# Get filename from config entry
get_filename() {
    echo "$1" | cut -d: -f1
}

# Get code type from config entry
get_configured_code_type() {
    local entry="$1"
    if [[ "$entry" == *":"* ]]; then
        echo "$entry" | cut -d: -f2
    else
        echo ""
    fi
}

# Infer code type based on file extension
get_code_type() {
    local filename="$1"
    local extension="${filename##*.}"
    
    case "$extension" in
        yml|yaml) echo "yaml" ;;
        json) echo "json" ;;
        js|mjs) echo "javascript" ;;
        ts) echo "typescript" ;;
        py) echo "python" ;;
        sh|bash) echo "bash" ;;
        css) echo "css" ;;
        html|htm) echo "html" ;;
        xml) echo "xml" ;;
        sql) echo "sql" ;;
        md) echo "markdown" ;;
        txt|log|conf|config) echo "text" ;;
        env|example) echo "env" ;;
        dockerfile) echo "dockerfile" ;;
        nginx) echo "nginx" ;;
        *) echo "text" ;;
    esac
}

# Function to check if file exists
check_file_exists() {
    local file_path="$1"
    if [ ! -f "$file_path" ]; then
        echo "Warning: $file_path does not exist, skipping"
        return 1
    fi
    return 0
}

# Function to process file replacement
process_file() {
    local md_file="$1"
    local source_file="$2"
    local start_tag="$3"
    local end_tag="$4"
    local code_type="$5"
    
    echo "Processing file: $md_file (replacing with $source_file content)"
    
    # Temporary file
    temp_file=$(mktemp)
    
    # Use awk to replace content
    awk -v source_file="$source_file" -v start_tag="$start_tag" -v end_tag="$end_tag" -v code_type="$code_type" '
    BEGIN { 
        in_block = 0
        # Read source file content
        while ((getline line < source_file) > 0) {
            source_content = source_content line "\n"
        }
        close(source_file)
    }
    $0 ~ start_tag {
        print $0
        print "```" code_type
        printf "%s", source_content
        print "```"
        in_block = 1
        next
    }
    $0 ~ end_tag {
        in_block = 0
        print $0
        next
    }
    !in_block {
        print $0
    }
    ' "$md_file" > "$temp_file"
    
    # Replace original file
    mv "$temp_file" "$md_file"
    echo "Updated: $md_file"
}

# ===============================
# Main Program
# ===============================

echo "Starting document update process..."
echo ""

# Display configured file list
echo "Configured file list:"
for entry in "${FILES_TO_SYNC[@]}"; do
    filename=$(get_filename "$entry")
    code_type=$(get_configured_code_type "$entry")
    if [ -f "$filename" ]; then
        echo "  ✓ $filename ($code_type)"
    else
        echo "  ✗ $filename ($code_type) - file not found"
    fi
done

echo ""
echo "Starting file replacement process..."

# Process each md file (exclude .venv, .git, node_modules directories)
find . -name "*.md" -type f \
    -not -path "./.venv/*" \
    -not -path "./.git/*" \
    -not -path "./node_modules/*" \
    -not -path "./*/.venv/*" \
    -not -path "./*/.git/*" \
    -not -path "./*/node_modules/*" \
    | while read -r md_file; do
    echo "Checking file: $md_file"
    
    file_updated=false
    
    # Check configured file list
    for entry in "${FILES_TO_SYNC[@]}"; do
        source_file=$(get_filename "$entry")
        
        # Check if start and end tags exist
        if grep -q "<!-- $source_file -->" "$md_file" && grep -q "<!-- /$source_file -->" "$md_file"; then
            # Check if source file exists
            if check_file_exists "$source_file"; then
                # Get code type (prioritize configured type, otherwise auto-infer)
                code_type=$(get_configured_code_type "$entry")
                if [ -z "$code_type" ]; then
                    code_type=$(get_code_type "$source_file")
                fi
                
                # Process file
                process_file "$md_file" "$source_file" "<!-- $source_file -->" "<!-- /$source_file -->" "$code_type"
                file_updated=true
            fi
        fi
    done
    
    if [ "$file_updated" = false ]; then
        echo "Skipping file: $md_file (no configured file reference tags found)"
    fi
done

echo ""
echo "Script execution completed!"
echo ""
echo "Usage Instructions:"
echo "1. Add files to sync in the FILES_TO_SYNC array at the top of the script"
echo "2. Use format in markdown files: <!-- filename --> ... <!-- /filename -->"
echo "3. Run the script to automatically sync content"
echo ""
echo "Supported code types:"
echo "  yaml, json, javascript, typescript, python, bash, css, html, xml, sql, markdown, env, dockerfile, nginx, text"
echo ""
echo "Ignored directories:"
echo "  .venv, .git, node_modules (and their subdirectories)"



================================================
FILE: .env.example
================================================
# Model provider configuration
API_KEY=
API_BASE=http://mockserver:8090/v1

# Model configuration
MODEL_NAME=deepseek-chat
TEMPERATURE=0.7
MAX_TOKENS=2000

# MongoDB configuration
#MONGODB_URI=mongodb://mongodb:27017
#MONGODB_DATABASE=manus
#MONGODB_USERNAME=
#MONGODB_PASSWORD=

# Redis configuration
#REDIS_HOST=redis
#REDIS_PORT=6379
#REDIS_DB=0
#REDIS_PASSWORD=

# Sandbox configuration
#SANDBOX_ADDRESS=
SANDBOX_IMAGE=simpleyyt/manus-sandbox
SANDBOX_NAME_PREFIX=sandbox
SANDBOX_TTL_MINUTES=30
SANDBOX_NETWORK=manus-network
#SANDBOX_CHROME_ARGS=
#SANDBOX_HTTPS_PROXY=
#SANDBOX_HTTP_PROXY=
#SANDBOX_NO_PROXY=

# Search engine configuration
# Options: baidu, google, bing
SEARCH_PROVIDER=bing

# Google search configuration, only used when SEARCH_PROVIDER=google
#GOOGLE_SEARCH_API_KEY=
#GOOGLE_SEARCH_ENGINE_ID=

# Auth configuration
# Options: password, none, local
AUTH_PROVIDER=password

# Password auth configuration, only used when AUTH_PROVIDER=password
PASSWORD_SALT=
PASSWORD_HASH_ROUNDS=10
PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

# Local auth configuration, only used when AUTH_PROVIDER=local
#LOCAL_AUTH_EMAIL=admin@example.com
#LOCAL_AUTH_PASSWORD=admin

# JWT configuration
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Email configuration
# Only used when AUTH_PROVIDER=password
#EMAIL_HOST=smtp.gmail.com
#EMAIL_PORT=587
#EMAIL_USERNAME=your-email@gmail.com
#EMAIL_PASSWORD=your-password
#EMAIL_FROM=your-email@gmail.com

# MCP configuration
#MCP_CONFIG_PATH=/etc/mcp.json

# Log configuration
LOG_LEVEL=INFO


================================================
FILE: backend/README.md
================================================
# AI Manus Backend Service

English | [中文](README_zh.md)

AI Manus is an intelligent conversation agent system based on FastAPI and OpenAI API. The backend adopts Domain-Driven Design (DDD) architecture, supporting intelligent dialogue, file operations, Shell command execution, and browser automation.

## Project Architecture

The project adopts Domain-Driven Design (DDD) architecture, clearly separating the responsibilities of each layer:

```
backend/
├── app/
│   ├── domain/          # Domain layer: contains core business logic
│   │   ├── models/      # Domain model definitions
│   │   ├── services/    # Domain services
│   │   ├── external/    # External service interfaces
│   │   └── prompts/     # Prompt templates
│   ├── application/     # Application layer: orchestrates business processes
│   │   ├── services/    # Application services
│   │   └── schemas/     # Data schema definitions
│   ├── interfaces/      # Interface layer: defines external system interfaces
│   │   └── api/
│   │       └── routes.py # API route definitions
│   ├── infrastructure/  # Infrastructure layer: provides technical implementation
│   └── main.py          # Application entry
├── Dockerfile           # Docker configuration file
├── run.sh               # Production environment startup script
├── dev.sh               # Development environment startup script
├── requirements.txt     # Project dependencies
└── README.md            # Project documentation
```

## Core Features

1. **Session Management**: Create and manage conversation session instances
2. **Real-time Conversation**: Implement real-time conversation through Server-Sent Events (SSE)
3. **Tool Invocation**: Support for various tool calls, including:
   - Browser automation operations (using Playwright)
   - Shell command execution and viewing
   - File read/write operations
   - Web search integration
4. **Sandbox Environment**: Use Docker containers to provide isolated execution environments
5. **VNC Visualization**: Support remote viewing of the sandbox environment via WebSocket connection

## Requirements

- Python 3.9+
- Docker 20.10+
- MongoDB 4.4+
- Redis 6.0+

## Installation and Configuration

1. **Create a virtual environment**:
```bash
python -m venv .venv
source .venv/bin/activate
```

2. **Install dependencies**:
```bash
pip install -r requirements.txt
```

3. **Environment variable configuration**:
Create a `.env` file and set the following environment variables:
```
# Model provider configuration
API_KEY=your_api_key_here                # API key for OpenAI or other model providers
API_BASE=https://api.openai.com/v1       # Base URL for the model API, can be replaced with other model provider API addresses

# Model configuration
MODEL_NAME=gpt-4o                        # Model name to use
TEMPERATURE=0.7                          # Model temperature parameter
MAX_TOKENS=2000                          # Maximum output tokens per model request

# Google search configuration
GOOGLE_SEARCH_API_KEY=                   # Google Search API key for web search functionality (optional)
GOOGLE_SEARCH_ENGINE_ID=                 # Google custom search engine ID (optional)

# Sandbox configuration
SANDBOX_IMAGE=simpleyyt/manus-sandbox          # Sandbox environment Docker image
SANDBOX_NAME_PREFIX=sandbox              # Sandbox container name prefix
SANDBOX_TTL_MINUTES=30                   # Sandbox container time-to-live (minutes)
SANDBOX_NETWORK=manus-network            # Docker network name for communication between sandbox containers

# Database configuration
MONGODB_URL=mongodb://localhost:27017    # MongoDB connection URL
MONGODB_DATABASE=manus                   # MongoDB database name
REDIS_URL=redis://localhost:6379/0       # Redis connection URL

# Log configuration
LOG_LEVEL=INFO                           # Log level, options: DEBUG, INFO, WARNING, ERROR, CRITICAL
```

## Running the Service

### Development Environment
```bash
# Start the development server (with hot reload)
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

The service will start at http://localhost:8000.

### Docker Deployment
```bash
# Build Docker image
docker build -t manus-ai-agent .

# Run container
docker run -p 8000:8000 --env-file .env -v /var/run/docker.sock:/var/run/docker.sock manus-ai-agent
```

> Note: If using Docker deployment, you need to mount the Docker socket so the backend can create sandbox containers.

## API Documentation

Base URL: `/api/v1`

### 1. Create Session

- **Endpoint**: `PUT /api/v1/sessions`
- **Description**: Create a new conversation session
- **Request Body**: None
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "session_id": "string"
    }
  }
  ```

### 2. Get Session

- **Endpoint**: `GET /api/v1/sessions/{session_id}`
- **Description**: Get session information including conversation history
- **Path Parameters**:
  - `session_id`: Session ID
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "session_id": "string",
      "title": "string",
      "events": []
    }
  }
  ```

### 3. List All Sessions

- **Endpoint**: `GET /api/v1/sessions`
- **Description**: Get list of all sessions
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "sessions": [
        {
          "session_id": "string",
          "title": "string",
          "latest_message": "string",
          "latest_message_at": 1234567890,
          "status": "string",
          "unread_message_count": 0
        }
      ]
    }
  }
  ```

### 4. Delete Session

- **Endpoint**: `DELETE /api/v1/sessions/{session_id}`
- **Description**: Delete a session
- **Path Parameters**:
  - `session_id`: Session ID
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": null
  }
  ```

### 5. Stop Session

- **Endpoint**: `POST /api/v1/sessions/{session_id}/stop`
- **Description**: Stop an active session
- **Path Parameters**:
  - `session_id`: Session ID
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": null
  }
  ```

### 6. Chat with Session

- **Endpoint**: `POST /api/v1/sessions/{session_id}/chat`
- **Description**: Send a message to the session and receive streaming response
- **Path Parameters**:
  - `session_id`: Session ID
- **Request Body**:
  ```json
  {
    "message": "User message content",
    "timestamp": 1234567890,
    "event_id": "optional event ID"
  }
  ```
- **Response**: Server-Sent Events (SSE) stream
- **Event Types**:
  - `message`: Text message from assistant
  - `title`: Session title update
  - `plan`: Execution plan with steps
  - `step`: Step status update
  - `tool`: Tool invocation information
  - `error`: Error information
  - `done`: Conversation completion

### 7. View Shell Session Content

- **Endpoint**: `POST /api/v1/sessions/{session_id}/shell`
- **Description**: View shell session output in the sandbox environment
- **Path Parameters**:
  - `session_id`: Session ID
- **Request Body**:
  ```json
  {
    "session_id": "shell session ID"
  }
  ```
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "output": "shell output content",
      "session_id": "shell session ID",
      "console": [
        {
          "ps1": "prompt string",
          "command": "executed command",
          "output": "command output"
        }
      ]
    }
  }
  ```

### 8. View File Content

- **Endpoint**: `POST /api/v1/sessions/{session_id}/file`
- **Description**: View file content in the sandbox environment
- **Path Parameters**:
  - `session_id`: Session ID
- **Request Body**:
  ```json
  {
    "file": "file path"
  }
  ```
- **Response**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "content": "file content",
      "file": "file path"
    }
  }
  ```

### 9. VNC Connection

- **Endpoint**: `WebSocket /api/v1/sessions/{session_id}/vnc`
- **Description**: Establish a VNC WebSocket connection to the session's sandbox environment
- **Path Parameters**:
  - `session_id`: Session ID
- **Protocol**: WebSocket (binary mode)
- **Subprotocol**: `binary`

## Error Handling

All APIs return responses in a unified format when errors occur:
```json
{
  "code": 400,
  "msg": "Error description",
  "data": null
}
```

Common error codes:
- `400`: Request parameter error
- `404`: Resource not found
- `500`: Server internal error

## Development Guide

### Adding New Tools

1. Define the tool interface in the `domain/external` directory
2. Implement the tool functionality in the `infrastructure` layer
3. Integrate the tool in `application/services` 


================================================
FILE: backend/dev.sh
================================================
#!/bin/bash

exec uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload  --timeout-graceful-shutdown 0


================================================
FILE: backend/Dockerfile
================================================
FROM python:3.12-slim

WORKDIR /app

# Install curl
RUN apt-get update && apt-get install -y curl

# Install uv
RUN curl -fsSL https://deb.nodesource.com/setup_22.x | bash - && \
    apt-get install -y nodejs

# Install uv
RUN pip install uv

# Configure uv to use Aliyun mirror
ENV UV_INDEX_URL=https://mirrors.aliyun.com/pypi/simple/

# Install dependencies
COPY requirements.txt .
RUN uv pip install --system --no-cache -r requirements.txt

# Copy project files
COPY . .

# Set script execution permissions
RUN chmod +x run.sh

# Set environment variables
ENV PYTHONPATH=/app

# Expose port
EXPOSE 8000

# Start command
CMD ["./run.sh"] 


================================================
FILE: backend/pytest.ini
================================================
[pytest]
asyncio_mode = auto
log_cli = true
log_cli_level = info
log_cli_format = %(asctime)s %(filename)s:%(lineno)s [%(levelname)s]: %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --color=yes
    --durations=10
markers =
    file_api: marks tests for file API
filterwarnings =
    ignore::DeprecationWarning
    ignore::PendingDeprecationWarning 


================================================
FILE: backend/README_zh.md
================================================
# AI Manus 后端服务

[English](README.md) | 中文

AI Manus 是一个基于 FastAPI 和 OpenAI API 的智能对话代理系统。该后端采用领域驱动设计(DDD)架构，支持智能对话、文件操作、Shell命令执行以及浏览器自动化等功能。

## 项目架构

项目采用领域驱动设计(DDD)架构，清晰地分离各层职责：

```
backend/
├── app/
│   ├── domain/          # 领域层：包含核心业务逻辑
│   │   ├── models/      # 领域模型定义
│   │   ├── services/    # 领域服务
│   │   ├── external/    # 外部服务接口
│   │   └── prompts/     # 提示词模板
│   ├── application/     # 应用层：编排业务流程
│   │   ├── services/    # 应用服务
│   │   └── schemas/     # 数据模式定义
│   ├── interfaces/      # 接口层：定义系统对外接口
│   │   └── api/
│   │       └── routes.py # API路由定义
│   ├── infrastructure/  # 基础设施层：提供技术实现
│   └── main.py          # 应用入口
├── Dockerfile           # Docker配置文件
├── run.sh               # 生产环境启动脚本
├── dev.sh               # 开发环境启动脚本
├── requirements.txt     # 项目依赖
└── README.md            # 项目文档
```

## 核心功能

1. **会话管理**：创建和管理对话会话实例
2. **实时对话**：通过Server-Sent Events (SSE)实现实时对话
3. **工具调用**：支持多种工具调用，包括：
   - 浏览器自动化操作（使用Playwright）
   - Shell命令执行与查看
   - 文件读写操作
   - 网络搜索集成
4. **沙盒环境**：使用Docker容器提供隔离的执行环境
5. **VNC可视化**：通过WebSocket连接支持远程查看沙盒环境

## 环境要求

- Python 3.9+
- Docker 20.10+
- MongoDB 4.4+
- Redis 6.0+

## 安装配置

1. **创建虚拟环境**:
```bash
python -m venv .venv
source .venv/bin/activate
```

2. **安装依赖**:
```bash
pip install -r requirements.txt
```

3. **环境变量配置**:
创建 `.env` 文件并设置以下环境变量:
```
# Model provider configuration
API_KEY=your_api_key_here                # OpenAI 或其他模型供应商的 API 密钥
API_BASE=https://api.openai.com/v1       # 模型 API 的基础 URL，可替换为其他模型供应商的 API 地址

# Model configuration
MODEL_NAME=gpt-4o                        # 使用的模型名称
TEMPERATURE=0.7                          # 模型温度参数
MAX_TOKENS=2000                          # 模型单次请求最大输出 token 数量

# Google search configuration
GOOGLE_SEARCH_API_KEY=                   # Google Search API 密钥，用于网络搜索功能（可选）
GOOGLE_SEARCH_ENGINE_ID=                 # Google 自定义搜索引擎 ID（可选）

# Sandbox configuration
SANDBOX_IMAGE=simpleyyt/manus-sandbox          # 沙盒环境 Docker 镜像
SANDBOX_NAME_PREFIX=sandbox              # 沙盒容器名称前缀
SANDBOX_TTL_MINUTES=30                   # 沙盒容器生存时间（分钟）
SANDBOX_NETWORK=manus-network            # Docker 网络名称，用于沙盒容器间通信

# Database configuration
MONGODB_URL=mongodb://localhost:27017    # MongoDB 连接 URL
MONGODB_DATABASE=manus                   # MongoDB 数据库名称
REDIS_URL=redis://localhost:6379/0       # Redis 连接 URL

# Log configuration
LOG_LEVEL=INFO                           # 日志级别，可选: DEBUG, INFO, WARNING, ERROR, CRITICAL
```

## 运行方式

### 开发环境
```bash
# 启动开发服务器（带热重载功能）
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

服务将在 http://localhost:8000 启动。

### Docker部署
```bash
# 构建Docker镜像
docker build -t manus-ai-agent .

# 运行容器
docker run -p 8000:8000 --env-file .env -v /var/run/docker.sock:/var/run/docker.sock manus-ai-agent
```

> 注意：如果使用Docker部署，需要挂载Docker套接字以便后端可以创建沙盒容器。

## API接口文档

基础URL: `/api/v1`

### 1. 创建会话

- **接口**: `PUT /api/v1/sessions`
- **描述**: 创建一个新的对话会话
- **请求体**: 无
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "session_id": "string"
    }
  }
  ```

### 2. 获取会话信息

- **接口**: `GET /api/v1/sessions/{session_id}`
- **描述**: 获取会话信息，包括对话历史
- **路径参数**:
  - `session_id`: 会话ID
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "session_id": "string",
      "title": "string",
      "events": []
    }
  }
  ```

### 3. 获取所有会话列表

- **接口**: `GET /api/v1/sessions`
- **描述**: 获取所有会话的列表
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "sessions": [
        {
          "session_id": "string",
          "title": "string",
          "latest_message": "string",
          "latest_message_at": 1234567890,
          "status": "string",
          "unread_message_count": 0
        }
      ]
    }
  }
  ```

### 4. 删除会话

- **接口**: `DELETE /api/v1/sessions/{session_id}`
- **描述**: 删除指定会话
- **路径参数**:
  - `session_id`: 会话ID
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": null
  }
  ```

### 5. 停止会话

- **接口**: `POST /api/v1/sessions/{session_id}/stop`
- **描述**: 停止活跃的会话
- **路径参数**:
  - `session_id`: 会话ID
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": null
  }
  ```

### 6. 与会话对话

- **接口**: `POST /api/v1/sessions/{session_id}/chat`
- **描述**: 向会话发送消息并接收流式响应
- **路径参数**:
  - `session_id`: 会话ID
- **请求体**:
  ```json
  {
    "message": "用户消息内容",
    "timestamp": 1234567890,
    "event_id": "可选的事件ID"
  }
  ```
- **响应**: Server-Sent Events (SSE) 流
- **事件类型**:
  - `message`: 来自助手的文本消息
  - `title`: 会话标题更新
  - `plan`: 执行计划和步骤
  - `step`: 步骤状态更新
  - `tool`: 工具调用信息
  - `error`: 错误信息
  - `done`: 对话完成

### 7. 查看Shell会话内容

- **接口**: `POST /api/v1/sessions/{session_id}/shell`
- **描述**: 查看沙盒环境中的Shell会话输出
- **路径参数**:
  - `session_id`: 会话ID
- **请求体**:
  ```json
  {
    "session_id": "shell会话ID"
  }
  ```
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "output": "shell输出内容",
      "session_id": "shell会话ID",
      "console": [
        {
          "ps1": "提示符字符串",
          "command": "执行的命令",
          "output": "命令输出"
        }
      ]
    }
  }
  ```

### 8. 查看文件内容

- **接口**: `POST /api/v1/sessions/{session_id}/file`
- **描述**: 查看沙盒环境中的文件内容
- **路径参数**:
  - `session_id`: 会话ID
- **请求体**:
  ```json
  {
    "file": "文件路径"
  }
  ```
- **响应**:
  ```json
  {
    "code": 0,
    "msg": "success",
    "data": {
      "content": "文件内容",
      "file": "文件路径"
    }
  }
  ```

### 9. VNC连接

- **接口**: `WebSocket /api/v1/sessions/{session_id}/vnc`
- **描述**: 建立与会话沙盒环境的VNC WebSocket连接
- **路径参数**:
  - `session_id`: 会话ID
- **协议**: WebSocket (二进制模式)
- **子协议**: `binary`

## 错误处理

所有API在发生错误时会返回统一格式的响应：
```json
{
  "code": 400,
  "msg": "错误描述",
  "data": null
}
```

常见错误码：
- `400`: 请求参数错误
- `404`: 资源不存在
- `500`: 服务器内部错误

## 开发指南

### 添加新工具

1. 在 `domain/external` 目录下定义工具接口
2. 在 `infrastructure` 层实现工具功能
3. 在 `application/services` 中集成工具



================================================
FILE: backend/requirements.txt
================================================
fastapi
uvicorn
openai
pydantic
pydantic-settings
python-dotenv
sse-starlette
httpx
rich
playwright>=1.42.0
markdownify
docker
websockets
motor>=3.3.2
pymongo>=4.6.1
beanie>=1.25.0
async-lru>=2.0.0
redis>=5.0.1
beautifulsoup4>=4.12.0
python-multipart
mcp>=1.9.0
pyjwt[crypto]>=2.8.0
cryptography>=3.4.8


================================================
FILE: backend/run.sh
================================================
#!/bin/bash

exec uvicorn app.main:app --host 0.0.0.0 --port 8000  --timeout-graceful-shutdown 5


================================================
FILE: backend/app/__init__.py
================================================
"""
Manus AI Agent Backend
"""



================================================
FILE: backend/app/main.py
================================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logging
import asyncio

from app.core.config import get_settings
from app.infrastructure.storage.mongodb import get_mongodb
from app.infrastructure.storage.redis import get_redis
from app.interfaces.dependencies import get_agent_service
from app.interfaces.api.routes import router
from app.infrastructure.logging import setup_logging
from app.interfaces.errors.exception_handlers import register_exception_handlers
from app.infrastructure.models.documents import AgentDocument, SessionDocument, UserDocument
from app.interfaces.middleware.auth import AuthMiddleware
from beanie import init_beanie

# Initialize logging system
setup_logging()
logger = logging.getLogger(__name__)

# Load configuration
settings = get_settings()


# Create lifespan context manager
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Code executed on startup
    logger.info("Application startup - Manus AI Agent initializing")
    
    # Initialize MongoDB and Beanie
    await get_mongodb().initialize()

    # Initialize Beanie
    await init_beanie(
        database=get_mongodb().client[settings.mongodb_database],
        document_models=[AgentDocument, SessionDocument, UserDocument]
    )
    logger.info("Successfully initialized Beanie")
    
    # Initialize Redis
    await get_redis().initialize()
    
    try:
        yield
    finally:
        # Code executed on shutdown
        logger.info("Application shutdown - Manus AI Agent terminating")
        # Disconnect from MongoDB
        await get_mongodb().shutdown()
        # Disconnect from Redis
        await get_redis().shutdown()


        logger.info("Cleaning up AgentService instance")
        try:
            await asyncio.wait_for(get_agent_service().shutdown(), timeout=30.0)
            logger.info("AgentService shutdown completed successfully")
        except asyncio.TimeoutError:
            logger.warning("AgentService shutdown timed out after 30 seconds")
        except Exception as e:
            logger.error(f"Error during AgentService cleanup: {str(e)}")

app = FastAPI(title="Manus AI Agent", lifespan=lifespan)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add authentication middleware
app.add_middleware(AuthMiddleware)

# Register exception handlers
register_exception_handlers(app)

# Register routes
app.include_router(router, prefix="/api/v1")


================================================
FILE: backend/app/application/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/application/errors/exceptions.py
================================================
class AppException(RuntimeError):
    def __init__(
        self,
        code: int,
        msg: str,
        status_code: int = 400,
    ):
        super().__init__(msg)
        self.code = code
        self.msg = msg
        self.status_code = status_code


class NotFoundError(AppException):
    def __init__(self, msg: str = "Resource not found"):
        super().__init__(code=404, msg=msg, status_code=404)


class BadRequestError(AppException):
    def __init__(self, msg: str = "Bad request parameters"):
        super().__init__(code=400, msg=msg, status_code=400)


class ValidationError(AppException):
    def __init__(self, msg: str = "Validation error"):
        super().__init__(code=422, msg=msg, status_code=422)


class ServerError(AppException):
    def __init__(self, msg: str = "Internal server error"):
        super().__init__(code=500, msg=msg, status_code=500)


class UnauthorizedError(AppException):
    def __init__(self, msg: str = "Unauthorized"):
        super().__init__(code=401, msg=msg, status_code=401) 


================================================
FILE: backend/app/application/services/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/application/services/agent_service.py
================================================
from typing import AsyncGenerator, Optional, List
import logging
from datetime import datetime
from app.domain.models.session import Session
from app.domain.repositories.session_repository import SessionRepository

from app.interfaces.schemas.session import ShellViewResponse
from app.interfaces.schemas.file import FileViewResponse
from app.domain.models.agent import Agent
from app.domain.services.agent_domain_service import AgentDomainService
from app.domain.models.event import AgentEvent
from typing import Type
from app.domain.models.agent import Agent
from app.domain.external.sandbox import Sandbox
from app.domain.external.search import SearchEngine
from app.domain.external.llm import LLM
from app.domain.external.file import FileStorage
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.external.task import Task
from app.domain.utils.json_parser import JsonParser
from app.domain.models.file import FileInfo
from app.domain.repositories.mcp_repository import MCPRepository
from app.domain.models.session import SessionStatus

# Set up logger
logger = logging.getLogger(__name__)

class AgentService:
    def __init__(
        self,
        llm: LLM,
        agent_repository: AgentRepository,
        session_repository: SessionRepository,
        sandbox_cls: Type[Sandbox],
        task_cls: Type[Task],
        json_parser: JsonParser,
        file_storage: FileStorage,
        mcp_repository: MCPRepository,
        search_engine: Optional[SearchEngine] = None,
    ):
        logger.info("Initializing AgentService")
        self._agent_repository = agent_repository
        self._session_repository = session_repository
        self._file_storage = file_storage
        self._agent_domain_service = AgentDomainService(
            self._agent_repository,
            self._session_repository,
            llm,
            sandbox_cls,
            task_cls,
            json_parser,
            file_storage,
            mcp_repository,
            search_engine,
        )
        self._llm = llm
        self._search_engine = search_engine
        self._sandbox_cls = sandbox_cls
    
    async def create_session(self, user_id: str) -> Session:
        logger.info(f"Creating new session for user: {user_id}")
        agent = await self._create_agent()
        session = Session(agent_id=agent.id, user_id=user_id)
        logger.info(f"Created new Session with ID: {session.id} for user: {user_id}")
        await self._session_repository.save(session)
        return session

    async def _create_agent(self) -> Agent:
        logger.info("Creating new agent")
        
        # Create Agent instance
        agent = Agent(
            model_name=self._llm.model_name,
            temperature=self._llm.temperature,
            max_tokens=self._llm.max_tokens,
        )
        logger.info(f"Created new Agent with ID: {agent.id}")
        
        # Save agent to repository
        await self._agent_repository.save(agent)
        logger.info(f"Saved agent {agent.id} to repository")
        
        logger.info(f"Agent created successfully with ID: {agent.id}")
        return agent

    async def chat(
        self,
        session_id: str,
        user_id: str,
        message: Optional[str] = None,
        timestamp: Optional[datetime] = None,
        event_id: Optional[str] = None,
        attachments: Optional[List[str]] = None
    ) -> AsyncGenerator[AgentEvent, None]:
        logger.info(f"Starting chat with session {session_id}: {message[:50]}...")
        # Directly use the domain service's chat method, which will check if the session exists
        async for event in self._agent_domain_service.chat(session_id, user_id, message, timestamp, event_id, attachments):
            logger.debug(f"Received event: {event}")
            yield event
        logger.info(f"Chat with session {session_id} completed")
    
    async def get_session(self, session_id: str, user_id: str) -> Optional[Session]:
        """Get a session by ID, ensuring it belongs to the user"""
        logger.info(f"Getting session {session_id} for user {user_id}")
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
        return session
    
    async def get_all_sessions(self, user_id: str) -> List[Session]:
        """Get all sessions for a specific user"""
        logger.info(f"Getting all sessions for user {user_id}")
        return await self._session_repository.find_by_user_id(user_id)

    async def delete_session(self, session_id: str, user_id: str) -> None:
        """Delete a session, ensuring it belongs to the user"""
        logger.info(f"Deleting session {session_id} for user {user_id}")
        # First verify the session belongs to the user
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
            raise RuntimeError("Session not found")
        
        await self._session_repository.delete(session_id)
        logger.info(f"Session {session_id} deleted successfully")

    async def stop_session(self, session_id: str, user_id: str) -> None:
        """Stop a session, ensuring it belongs to the user"""
        logger.info(f"Stopping session {session_id} for user {user_id}")
        # First verify the session belongs to the user
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
            raise RuntimeError("Session not found")
        await self._agent_domain_service.stop_session(session_id)
        logger.info(f"Session {session_id} stopped successfully")

    async def clear_unread_message_count(self, session_id: str, user_id: str) -> None:
        """Clear the unread message count for a session, ensuring it belongs to the user"""
        logger.info(f"Clearing unread message count for session {session_id} for user {user_id}")
        await self._session_repository.update_unread_message_count(session_id, 0)
        logger.info(f"Unread message count cleared for session {session_id}")

    async def shutdown(self):
        logger.info("Closing all agents and cleaning up resources")
        # Clean up all Agents and their associated sandboxes
        await self._agent_domain_service.shutdown()
        logger.info("All agents closed successfully")

    async def shell_view(self, session_id: str, shell_session_id: str, user_id: str) -> ShellViewResponse:
        """View shell session output, ensuring session belongs to the user"""
        logger.info(f"Getting shell view for session {session_id} for user {user_id}")
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
            raise RuntimeError("Session not found")
        
        if not session.sandbox_id:
            raise RuntimeError("Session has no sandbox environment")
        
        # Get sandbox and shell output
        sandbox = await self._sandbox_cls.get(session.sandbox_id)
        if not sandbox:
            raise RuntimeError("Sandbox environment not found")
        
        result = await sandbox.view_shell(shell_session_id, console=True)
        if result.success:
            return ShellViewResponse(**result.data)
        else:
            raise RuntimeError(f"Failed to get shell output: {result.message}")

    async def get_vnc_url(self, session_id: str) -> str:
        """Get VNC URL for a session, ensuring it belongs to the user"""
        logger.info(f"Getting VNC URL for session {session_id}")
        
        session = await self._session_repository.find_by_id(session_id)
        if not session:
            logger.error(f"Session {session_id} not found")
            raise RuntimeError("Session not found")
        
        if not session.sandbox_id:
            raise RuntimeError("Session has no sandbox environment")
        
        # Get sandbox and return VNC URL
        sandbox = await self._sandbox_cls.get(session.sandbox_id)
        if not sandbox:
            raise RuntimeError("Sandbox environment not found")
        
        return sandbox.vnc_url

    async def file_view(self, session_id: str, file_path: str, user_id: str) -> FileViewResponse:
        """View file content, ensuring session belongs to the user"""
        logger.info(f"Getting file view for session {session_id} for user {user_id}")
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
            raise RuntimeError("Session not found")
        
        if not session.sandbox_id:
            raise RuntimeError("Session has no sandbox environment")
        
        # Get sandbox and file content
        sandbox = await self._sandbox_cls.get(session.sandbox_id)
        if not sandbox:
            raise RuntimeError("Sandbox environment not found")
        
        result = await sandbox.file_read(file_path)
        if result.success:
            return FileViewResponse(**result.data)
        else:
            raise RuntimeError(f"Failed to read file: {result.message}")

    async def get_session_files(self, session_id: str, user_id: str) -> List[FileInfo]:
        """Get files for a session, ensuring it belongs to the user"""
        logger.info(f"Getting files for session {session_id} for user {user_id}")
        session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
        if not session:
            logger.error(f"Session {session_id} not found for user {user_id}")
            raise RuntimeError("Session not found")
        return session.files


================================================
FILE: backend/app/application/services/auth_service.py
================================================
import hashlib
import secrets
from typing import Optional
from datetime import datetime
from app.domain.models.user import User, UserRole
from app.domain.repositories.user_repository import UserRepository
from app.application.errors.exceptions import UnauthorizedError, ValidationError, BadRequestError
from app.core.config import get_settings
from app.application.services.token_service import TokenService
from app.domain.models.auth import AuthToken
import logging

logger = logging.getLogger(__name__)


class AuthService:
    """Authentication service handling user authentication and authorization"""
    
    def __init__(self, user_repository: UserRepository, token_service: TokenService):
        self.user_repository = user_repository
        self.settings = get_settings()
        self.token_service = token_service
    
    def _hash_password(self, password: str, salt: str = None) -> str:
        """Hash password using configured algorithm"""
        if salt is None:
            salt = self.settings.password_salt or secrets.token_hex(32)
        
        # Support for different hash algorithms
        if self.settings.password_hash_algorithm == "pbkdf2_sha256":
            return self._pbkdf2_sha256(password, salt)
        else:
            raise ValueError(f"Unsupported hash algorithm: {self.settings.password_hash_algorithm}")
    
    def _pbkdf2_sha256(self, password: str, salt: str) -> str:
        """PBKDF2 with SHA-256 implementation"""
        password_bytes = password.encode('utf-8')
        salt_bytes = salt.encode('utf-8')
        
        # Use configured rounds
        rounds = self.settings.password_hash_rounds
        
        # Generate hash
        hash_bytes = hashlib.pbkdf2_hmac('sha256', password_bytes, salt_bytes, rounds)
        
        # Return salt + hash as hex string
        return salt + hash_bytes.hex()
    
    def _verify_password(self, password: str, password_hash: str) -> bool:
        """Verify password against hash"""
        if not password_hash:
            return False
        
        try:
            # Extract salt from hash (first 64 chars for 32-byte salt)
            salt = password_hash[:64]
            expected_hash = password_hash[64:]
            
            # Generate hash with extracted salt
            generated_hash = self._pbkdf2_sha256(password, salt)[64:]
            
            return generated_hash == expected_hash
        except Exception as e:
            logger.error(f"Password verification error: {e}")
            return False
    
    def _generate_user_id(self) -> str:
        """Generate unique user ID"""
        return secrets.token_urlsafe(16)
    
    async def register_user(self, fullname: str, password: str, email: str, role: UserRole = UserRole.USER) -> User:
        """Register a new user"""
        logger.info(f"Registering user: {email}")

        if self.settings.auth_provider != "password":
            raise BadRequestError("Registration is not allowed")
        
        # Validate input
        if not fullname or len(fullname.strip()) < 2:
            raise ValidationError("Full name must be at least 2 characters long")
        
        if not email or '@' not in email:
            raise ValidationError("Valid email is required")
        
        if not password or len(password) < 6:
            raise ValidationError("Password must be at least 6 characters long")
        
        # Check if email already exists
        if await self.user_repository.email_exists(email):
            raise ValidationError("Email already exists")
        
        # Hash password
        password_hash = self._hash_password(password)
        
        # Create user
        user = User(
            id=self._generate_user_id(),
            fullname=fullname.strip(),
            email=email.lower(),
            password_hash=password_hash,
            role=role,
            is_active=True,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        # Save to database
        created_user = await self.user_repository.create_user(user)
        
        logger.info(f"User registered successfully: {created_user.id}")
        return created_user
    
    async def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """Authenticate user by email and password"""
        logger.debug(f"Authenticating user: {email}")
        
        # Handle different auth providers
        if self.settings.auth_provider == "none":
            # No authentication required - return a default user
            return User(
                id="anonymous",
                fullname="anonymous",
                email="anonymous@localhost",
                role=UserRole.USER,
                is_active=True
            )
        
        elif self.settings.auth_provider == "local":
            # Local authentication using configured credentials
            if (email == self.settings.local_auth_email and 
                password == self.settings.local_auth_password):
                return User(
                    id="local_admin",
                    fullname="Local Admin",
                    email=email,
                    role=UserRole.ADMIN,
                    is_active=True
                )
            else:
                logger.warning(f"Local authentication failed for user: {email}")
                return None
        
        elif self.settings.auth_provider == "password":
            # Database password authentication
            user = await self.user_repository.get_user_by_email(email)
            if not user:
                logger.warning(f"User not found: {email}")
                return None
            
            if not user.is_active:
                logger.warning(f"User account is inactive: {email}")
                return None
            
            if not user.password_hash:
                logger.warning(f"User has no password hash: {email}")
                return None
            
            # Verify password
            if not self._verify_password(password, user.password_hash):
                logger.warning(f"Invalid password for user: {email}")
                return None
            
            # Update last login
            user.update_last_login()
            await self.user_repository.update_user(user)
            
            logger.info(f"User authenticated successfully: {email}")
            return user
        
        else:
            raise ValueError(f"Unsupported auth provider: {self.settings.auth_provider}")
    
    async def login_with_tokens(self, email: str, password: str) -> AuthToken:
        """Authenticate user and return JWT tokens"""
        user = await self.authenticate_user(email, password)
        
        if not user:
            raise UnauthorizedError("Invalid email or password")
        
        # Generate JWT tokens
        access_token = self.token_service.create_access_token(user)
        refresh_token = self.token_service.create_refresh_token(user)
        
        return AuthToken(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
            user=user
        )
    
    async def refresh_access_token(self, refresh_token: str) -> AuthToken:
        """Refresh access token using refresh token"""
        payload = self.token_service.verify_token(refresh_token)
        
        if not payload:
            raise UnauthorizedError("Invalid refresh token")
        
        if payload.get("type") != "refresh":
            raise UnauthorizedError("Invalid token type")
        
        # Get user from database
        user_id = payload.get("sub")
        user = await self.user_repository.get_user_by_id(user_id)
        
        if not user or not user.is_active:
            raise UnauthorizedError("User not found or inactive")
        
        # Generate new access token
        new_access_token = self.token_service.create_access_token(user)
        
        return AuthToken(
            access_token=new_access_token,
            token_type="bearer"
        )
    
    async def verify_token(self, token: str) -> Optional[User]:
        """Verify JWT token and return user"""
        user_info = self.token_service.get_user_from_token(token)
        
        if not user_info:
            return None
        
        # For database users, verify user still exists and is active
        if self.settings.auth_provider == "password":
            user = await self.user_repository.get_user_by_id(user_info["id"])
            if not user or not user.is_active:
                return None
            return user
        
        # For local/none authentication, create user from token info
        return User(
            id=user_info["id"],
            fullname=user_info["fullname"],
            email=user_info.get("email"),
            role=UserRole(user_info.get("role", "user")),
            is_active=user_info.get("is_active", True)
        )
    
    async def logout(self, token: str) -> bool:
        """Logout user by revoking token"""
        if self.settings.auth_provider == "none":
            raise BadRequestError("Logout is not allowed")
        return self.token_service.revoke_token(token)
    
    async def change_password(self, user_id: str, old_password: str, new_password: str) -> bool:
        """Change user password"""
        logger.info(f"Changing password for user: {user_id}")
        
        # Get user
        user = await self.user_repository.get_user_by_id(user_id)
        if not user:
            raise ValidationError("User not found")
        
        if not user.is_active:
            raise UnauthorizedError("User account is inactive")
        
        # Verify old password
        if not user.password_hash or not self._verify_password(old_password, user.password_hash):
            raise UnauthorizedError("Invalid old password")
        
        # Validate new password
        if not new_password or len(new_password) < 6:
            raise ValidationError("New password must be at least 6 characters long")
        
        # Hash new password
        new_password_hash = self._hash_password(new_password)
        
        # Update user password
        user.password_hash = new_password_hash
        user.updated_at = datetime.utcnow()
        
        await self.user_repository.update_user(user)
        
        logger.info(f"Password changed successfully for user: {user_id}")
        return True
    
    async def change_fullname(self, user_id: str, new_fullname: str) -> User:
        """Change user fullname"""
        logger.info(f"Changing fullname for user: {user_id}")
        
        # Get user
        user = await self.user_repository.get_user_by_id(user_id)
        if not user:
            raise ValidationError("User not found")
        
        if not user.is_active:
            raise UnauthorizedError("User account is inactive")
        
        # Validate new fullname
        if not new_fullname or len(new_fullname.strip()) < 2:
            raise ValidationError("Full name must be at least 2 characters long")
        
        # Update user fullname
        user.fullname = new_fullname.strip()
        user.updated_at = datetime.utcnow()
        
        updated_user = await self.user_repository.update_user(user)
        
        logger.info(f"Fullname changed successfully for user: {user_id}")
        return updated_user
    
    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """Get user by ID"""
        return await self.user_repository.get_user_by_id(user_id)
    
    async def deactivate_user(self, user_id: str) -> bool:
        """Deactivate user account"""
        logger.info(f"Deactivating user: {user_id}")
        
        user = await self.user_repository.get_user_by_id(user_id)
        if not user:
            raise ValidationError("User not found")
        
        user.deactivate()
        await self.user_repository.update_user(user)
        
        logger.info(f"User deactivated successfully: {user_id}")
        return True
    
    async def activate_user(self, user_id: str) -> bool:
        """Activate user account"""
        logger.info(f"Activating user: {user_id}")
        
        user = await self.user_repository.get_user_by_id(user_id)
        if not user:
            raise ValidationError("User not found")
        
        user.activate()
        await self.user_repository.update_user(user)
        
        logger.info(f"User activated successfully: {user_id}")
        return True
    
    async def reset_password(self, email: str, new_password: str) -> bool:
        """Reset user password with email"""
        logger.info(f"Resetting password for user: {email}")
        
        if self.settings.auth_provider != "password":
            raise BadRequestError("Password reset is not allowed")
        
        # Get user by email
        user = await self.user_repository.get_user_by_email(email)
        if not user:
            raise ValidationError("User not found")
        
        if not user.is_active:
            raise UnauthorizedError("User account is inactive")
        
        # Validate new password
        if not new_password or len(new_password) < 6:
            raise ValidationError("New password must be at least 6 characters long")
        
        # Hash new password
        new_password_hash = self._hash_password(new_password)
        
        # Update user password
        user.password_hash = new_password_hash
        user.updated_at = datetime.utcnow()
        
        await self.user_repository.update_user(user)
        
        logger.info(f"Password reset successfully for user: {email}")
        return True 


================================================
FILE: backend/app/application/services/email_service.py
================================================
import smtplib
import logging
import random
import asyncio
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Optional, Dict
from app.core.config import get_settings
from app.domain.external.cache import Cache
from app.application.errors.exceptions import BadRequestError

logger = logging.getLogger(__name__)


class EmailService:
    """Email service for sending verification codes and notifications"""
    
    # Class variables
    VERIFICATION_CODE_PREFIX = "verification_code:"
    VERIFICATION_CODE_EXPIRY_SECONDS = 300  # 5 minutes
    
    def __init__(self, cache: Cache):
        self.settings = get_settings()
        self.cache = cache
    
    def _generate_verification_code(self) -> str:
        """Generate 6-digit verification code"""
        return f"{random.randint(100000, 999999)}"
    
    async def _store_verification_code(self, email: str, code: str) -> None:
        """Store verification code with expiration time in cache"""
        now = datetime.now()
        # Create verification code data
        code_data = {
            "code": code,
            "created_at": now.isoformat(),
            "expires_at": (now + timedelta(seconds=self.VERIFICATION_CODE_EXPIRY_SECONDS)).isoformat(),
            "attempts": 0
        }
        
        # Store in cache with TTL
        key = f"{self.VERIFICATION_CODE_PREFIX}{email}"
        await self.cache.set(key, code_data, ttl=self.VERIFICATION_CODE_EXPIRY_SECONDS)
    
    async def verify_code(self, email: str, code: str) -> bool:
        """Verify if the provided code is valid for the email"""
        key = f"{self.VERIFICATION_CODE_PREFIX}{email}"
        
        # Get stored data from cache
        stored_data = await self.cache.get(key)
        if not stored_data:
            return False
        
        # Check if code has expired (cache TTL should handle this, but double-check)
        expires_at = datetime.fromisoformat(stored_data["expires_at"])
        if datetime.now() > expires_at:
            await self.cache.delete(key)
            return False
        
        # Check attempts limit (max 3 attempts)
        if stored_data["attempts"] >= 3:
            await self.cache.delete(key)
            return False
        
        # Increment attempt count
        stored_data["attempts"] += 1
        
        # Check if code matches
        if stored_data["code"] == code:
            # Remove the code after successful verification
            await self.cache.delete(key)
            return True
        
        # Update attempt count in cache
        remaining_ttl = int((expires_at - datetime.now()).total_seconds())
        if remaining_ttl > 0:
            await self.cache.set(key, stored_data, ttl=remaining_ttl)
        
        return False
    
    def _create_verification_email(self, email: str, code: str) -> MIMEMultipart:
        """Create verification email content"""
        msg = MIMEMultipart()
        msg['From'] = self.settings.email_from or self.settings.email_username
        msg['To'] = email
        msg['Subject'] = "Password Reset Verification Code"
        
        # Email body
        body = f"""
        <html>
        <body>
            <h2>Password Reset Verification</h2>
            <p>You have requested to reset your password. Please use the following verification code:</p>
            <h3 style="color: #007bff; font-size: 24px; letter-spacing: 2px;">{code}</h3>
            <p><strong>This code will expire in 5 minutes.</strong></p>
            <p>If you did not request this password reset, please ignore this email.</p>
            <br>
            <p>Best regards,<br>AI Manus Team</p>
        </body>
        </html>
        """
        
        msg.attach(MIMEText(body, 'html'))
        return msg
    
    async def send_verification_code(self, email: str):
        """Send verification code to email address"""
        # Check if email configuration is available
        if not all([
            self.settings.email_host,
            self.settings.email_port,
            self.settings.email_username,
            self.settings.email_password
        ]):
            logger.error("Email configuration is incomplete, simulating email send")
            raise BadRequestError("Email configuration is incomplete")
        
        # Check if there's an existing verification code that's too recent
        key = f"{self.VERIFICATION_CODE_PREFIX}{email}"
        existing_data = await self.cache.get(key)
        if existing_data:
            try:
                # Check if the existing code was created less than 60 seconds ago
                created_at = datetime.fromisoformat(existing_data["created_at"])
                time_since_creation = (datetime.now() - created_at).total_seconds()
                
                if time_since_creation < 60:
                    remaining_wait = int(60 - time_since_creation)
                    raise BadRequestError(f"Please wait {remaining_wait} seconds before requesting a new verification code")
            except (KeyError, ValueError):
                # Invalid data, continue with new code generation
                pass
        
        # Generate verification code
        code = self._generate_verification_code()
        logger.debug(f"Generated verification code: {code}")
        
        # Create email message
        msg = self._create_verification_email(email, code)
        logger.debug(f"Created email message: {msg}")
        
        # Send email using SMTP
        await self._send_smtp_email(msg, email)

        # Store verification code
        await self._store_verification_code(email, code)
        
        logger.info(f"Verification code sent to {email}")
    
    async def _send_smtp_email(self, msg: MIMEMultipart, email: str) -> None:
        """Send email using SMTP (runs in thread pool to avoid blocking)"""
        logger.debug(f"Sending email to {email}")
        server = None
        try:
            # Create SMTP server connection
            logger.debug(f"Creating SMTP server connection to {self.settings.email_host}:{self.settings.email_port}")
            server = smtplib.SMTP_SSL(self.settings.email_host, self.settings.email_port)
            logger.debug(f"SMTP server created, {server}")
            result = server.login(self.settings.email_username, self.settings.email_password)
            logger.debug(f"SMTP server login result: {result}")
            
            # Send email
            text = msg.as_string()
            result = server.sendmail(msg['From'], email, text)
            logger.debug(f"SMTP server sendmail result: {result}")
        finally:
            if server:
                server.quit()
    
    async def cleanup_expired_codes(self) -> None:
        """Clean up expired verification codes - Cache TTL handles this automatically"""
        # Cache automatically handles expiration via TTL, so this method is mainly for manual cleanup
        
        # Get all verification code keys
        pattern = f"{self.VERIFICATION_CODE_PREFIX}*"
        keys = await self.cache.keys(pattern)
        
        expired_count = 0
        for key in keys:
            data = await self.cache.get(key)
            if data:
                try:
                    expires_at = datetime.fromisoformat(data["expires_at"])
                    if datetime.now() > expires_at:
                        await self.cache.delete(key)
                        expired_count += 1
                except (KeyError, ValueError):
                    # Invalid data, delete it
                    await self.cache.delete(key)
                    expired_count += 1
        
        if expired_count > 0:
            logger.info(f"Cleaned up {expired_count} expired verification codes")



================================================
FILE: backend/app/application/services/file_service.py
================================================
from typing import Dict, Any, Optional, BinaryIO, Tuple
import logging
from app.domain.external.file import FileStorage
from app.domain.models.file import FileInfo

# Set up logger
logger = logging.getLogger(__name__)

class FileService:
    def __init__(self, file_storage: Optional[FileStorage] = None):
        self._file_storage = file_storage

    async def upload_file(self, file_data: BinaryIO, filename: str, user_id: str, content_type: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -> FileInfo:
        """Upload file"""
        logger.info(f"Upload file request: filename={filename}, user_id={user_id}, content_type={content_type}")
        if not self._file_storage:
            logger.error("File storage service not available")
            raise RuntimeError("File storage service not available")
        
        try:
            result = await self._file_storage.upload_file(file_data, filename, user_id, content_type, metadata)
            logger.info(f"File uploaded successfully: file_id={result.file_id}, user_id={user_id}")
            return result
        except Exception as e:
            logger.error(f"Failed to upload file for user {user_id}: {str(e)}")
            raise
    
    async def download_file(self, file_id: str, user_id: Optional[str] = None) -> Tuple[BinaryIO, FileInfo]:
        """Download file"""
        logger.info(f"Download file request: file_id={file_id}, user_id={user_id}")
        if not self._file_storage:
            logger.error("File storage service not available")
            raise RuntimeError("File storage service not available")
        
        try:
            result = await self._file_storage.download_file(file_id, user_id)
            logger.info(f"File downloaded successfully: file_id={file_id}, user_id={user_id}")
            return result
        except Exception as e:
            logger.error(f"Failed to download file {file_id} for user {user_id}: {str(e)}")
            raise

    async def delete_file(self, file_id: str, user_id: str) -> bool:
        """Delete file"""
        logger.info(f"Delete file request: file_id={file_id}, user_id={user_id}")
        if not self._file_storage:
            logger.error("File storage service not available")
            raise RuntimeError("File storage service not available")
        
        try:
            result = await self._file_storage.delete_file(file_id, user_id)
            if result:
                logger.info(f"File deleted successfully: file_id={file_id}, user_id={user_id}")
            else:
                logger.warning(f"File deletion failed or file not found: file_id={file_id}, user_id={user_id}")
            return result
        except Exception as e:
            logger.error(f"Failed to delete file {file_id} for user {user_id}: {str(e)}")
            raise

    async def get_file_info(self, file_id: str, user_id: str) -> Optional[FileInfo]:
        """Get file information"""
        logger.info(f"Get file info request: file_id={file_id}, user_id={user_id}")
        if not self._file_storage:
            logger.error("File storage service not available")
            raise RuntimeError("File storage service not available")
        
        try:
            result = await self._file_storage.get_file_info(file_id, user_id)
            if result:
                logger.info(f"File info retrieved successfully: file_id={file_id}, user_id={user_id}")
            else:
                logger.warning(f"File not found or access denied: file_id={file_id}, user_id={user_id}")
            return result
        except Exception as e:
            logger.error(f"Failed to get file info {file_id} for user {user_id}: {str(e)}")
            raise



================================================
FILE: backend/app/application/services/token_service.py
================================================
import jwt
from datetime import datetime, timedelta, UTC
from typing import Optional, Dict, Any
from app.core.config import get_settings
from app.domain.models.user import User
import logging

import hashlib
import hmac
import urllib.parse

logger = logging.getLogger(__name__)


class TokenService:
    """Token manager for authentication and URL signing"""
    
    def __init__(self):
        self.settings = get_settings()
    
    def create_access_token(self, user: User) -> str:
        """Create JWT access token for user"""
        now = datetime.now(UTC)
        expire = now + timedelta(minutes=self.settings.jwt_access_token_expire_minutes)
        
        payload = {
            "sub": user.id,  # Subject (user ID)
            "fullname": user.fullname,
            "email": user.email,
            "role": user.role.value,
            "is_active": user.is_active,
            "iat": int(now.timestamp()),  # Issued at (timestamp)
            "exp": int(expire.timestamp()),  # Expiration time (timestamp)
            "type": "access"
        }
        
        try:
            token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            logger.debug(f"Created access token for user: {user.fullname}")
            return token
        except Exception as e:
            logger.error(f"Failed to create access token: {e}")
            raise
    
    def create_refresh_token(self, user: User) -> str:
        """Create JWT refresh token for user"""
        now = datetime.now(UTC)
        expire = now + timedelta(days=self.settings.jwt_refresh_token_expire_days)
        
        payload = {
            "sub": user.id,  # Subject (user ID)
            "fullname": user.fullname,
            "iat": int(now.timestamp()),  # Issued at (timestamp)
            "exp": int(expire.timestamp()),  # Expiration time (timestamp)
            "type": "refresh"
        }
        
        try:
            token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            logger.debug(f"Created refresh token for user: {user.fullname}")
            return token
        except Exception as e:
            logger.error(f"Failed to create refresh token: {e}")
            raise
    
    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verify JWT token and return payload"""
        try:
            payload = jwt.decode(
                token,
                self.settings.jwt_secret_key,
                algorithms=[self.settings.jwt_algorithm]
            )
            
            # Check if token is not expired
            exp = payload.get("exp")
            if exp and exp < int(datetime.now(UTC).timestamp()):
                logger.warning("Token has expired")
                return None
            
            logger.debug(f"Token verified for user: {payload.get('fullname')}")
            return payload
            
        except jwt.ExpiredSignatureError:
            logger.warning("Token has expired")
            return None
        except jwt.InvalidTokenError as e:
            logger.warning(f"Invalid token: {e}")
            return None
        except Exception as e:
            logger.error(f"Token verification failed: {e}")
            return None
    
    def get_user_from_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Extract user information from JWT token"""
        payload = self.verify_token(token)
        
        if not payload:
            return None
        
        # Return user info from token payload
        return {
            "id": payload.get("sub"),
            "fullname": payload.get("fullname"),
            "email": payload.get("email"),
            "role": payload.get("role"),
            "is_active": payload.get("is_active", True),
            "token_type": payload.get("type", "access")
        }
    
    def is_token_valid(self, token: str) -> bool:
        """Check if token is valid"""
        return self.verify_token(token) is not None
    
    def get_token_expiration(self, token: str) -> Optional[datetime]:
        """Get token expiration time"""
        payload = self.verify_token(token)
        if not payload:
            return None
        
        exp = payload.get("exp")
        if exp:
            return datetime.fromtimestamp(exp, UTC)
        return None
    
    def create_resource_access_token(self, resource_type: str, resource_id: str, user_id: str, expire_minutes: int = 60) -> str:
        """Create JWT resource access token for URL-based access
        
        Args:
            resource_type: Type of resource (file, vnc, etc.)
            resource_id: ID of the resource (file_id, session_id, etc.)
            user_id: User ID who requested the token
            expire_minutes: Token expiration time in minutes
        """
        now = datetime.now(UTC)
        expire = now + timedelta(minutes=expire_minutes)
        
        payload = {
            "resource_type": resource_type,
            "resource_id": resource_id,
            "user_id": user_id,
            "iat": int(now.timestamp()),  # Issued at (timestamp)
            "exp": int(expire.timestamp()),  # Expiration time (timestamp)
            "type": "resource_access"
        }
        
        try:
            token = jwt.encode(
                payload,
                self.settings.jwt_secret_key,
                algorithm=self.settings.jwt_algorithm
            )
            logger.debug(f"Created resource access token for {resource_type}: {resource_id}, user: {user_id}")
            return token
        except Exception as e:
            logger.error(f"Failed to create resource access token: {e}")
            raise

    def revoke_token(self, token: str) -> bool:
        """Revoke token (placeholder for token blacklist implementation)"""
        # TODO:In a real implementation, you would add the token to a blacklist
        # stored in Redis or database with expiration time
        logger.warning(f"Token revoked (placeholder implementation)")
        return True

    def create_signed_url(self, base_url: str, expire_minutes: int = 60) -> str:
        """Create URL with signature for resource access
        
        Args:
            base_url: Base URL for the resource (e.g., '/api/v1/files/123' or '/api/v1/sessions/456/vnc')
            expire_minutes: URL expiration time in minutes
            
        Returns:
            Signed URL with signature and expiration parameters
        """
        now = datetime.now(UTC)
        expire = now + timedelta(minutes=expire_minutes)
        expires_timestamp = int(expire.timestamp())
        
        # Use the base URL directly - no placeholder replacement needed
        final_url = base_url
        
        # Create signature payload - simplified to only include URL and expiration
        payload_data = f"{final_url}|{expires_timestamp}"
        
        # Generate HMAC signature
        signature = hmac.new(
            self.settings.jwt_secret_key.encode('utf-8'),
            payload_data.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        # Parse URL to add query parameters
        parsed_url = urllib.parse.urlparse(final_url)
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        # Add signature parameters
        query_params['signature'] = [signature]
        query_params['expires'] = [str(expires_timestamp)]
        
        # Rebuild URL with signature parameters
        new_query = urllib.parse.urlencode(query_params, doseq=True)
        signed_url = urllib.parse.urlunparse((
            '',
            '',
            parsed_url.path,
            parsed_url.params,
            new_query,
            parsed_url.fragment
        ))
        
        logger.debug(f"Created signed URL for: {final_url}")
        return signed_url
    
    def verify_signed_url(self, request_url: str) -> bool:
        """Verify signed URL
        
        Args:
            request_url: Full request URL with query parameters
            
        Returns:
            True if valid, False if invalid
        """
        try:
            logger.info(f"Verifying signed URL: {request_url}")
            # Parse URL and extract query parameters
            parsed_url = urllib.parse.urlparse(request_url)
            query_params = urllib.parse.parse_qs(parsed_url.query)
            
            # Extract required parameters
            signature = query_params.get('signature', [None])[0]
            expires_str = query_params.get('expires', [None])[0]
            
            if not all([signature, expires_str]):
                logger.warning("Missing required signature parameters in URL")
                return False
            
            # Check expiration
            expires_timestamp = int(expires_str)
            if expires_timestamp < int(datetime.now(UTC).timestamp()):
                logger.warning("Signed URL has expired")
                return False
            
            # Reconstruct base URL without signature parameters
            base_query_params = {k: v for k, v in query_params.items() 
                               if k not in ['signature', 'expires']}
            base_query = urllib.parse.urlencode(base_query_params, doseq=True)
            base_url = urllib.parse.urlunparse((
                '',
                '',
                parsed_url.path,
                parsed_url.params,
                base_query,
                parsed_url.fragment
            ))
            
            # Recreate payload for signature verification using simplified method
            payload_data = f"{base_url}|{expires_timestamp}"
            
            # Generate expected signature
            expected_signature = hmac.new(
                self.settings.jwt_secret_key.encode('utf-8'),
                payload_data.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            # Compare signatures using constant-time comparison to prevent timing attacks
            if not hmac.compare_digest(signature, expected_signature):
                logger.warning("Invalid signature in signed URL")
                return False
            
            logger.debug(f"Signed URL verified for: {base_url}")
            return True
            
        except Exception as e:
            logger.error(f"Signed URL verification failed: {e}")
            return False



================================================
FILE: backend/app/core/config.py
================================================
from pydantic_settings import BaseSettings
from functools import lru_cache


class Settings(BaseSettings):
    
    # Model provider configuration
    api_key: str | None = None
    api_base: str = "https://api.deepseek.com/v1"
    
    # Model configuration
    model_name: str = "deepseek-chat"
    temperature: float = 0.7
    max_tokens: int = 2000
    
    # MongoDB configuration
    mongodb_uri: str = "mongodb://mongodb:27017"
    mongodb_database: str = "manus"
    mongodb_username: str | None = None
    mongodb_password: str | None = None
    
    # Redis configuration
    redis_host: str = "redis"
    redis_port: int = 6379
    redis_db: int = 0
    redis_password: str | None = None
    
    # Sandbox configuration
    sandbox_address: str | None = None
    sandbox_image: str | None = None
    sandbox_name_prefix: str | None = None
    sandbox_ttl_minutes: int | None = 30
    sandbox_network: str | None = None  # Docker network bridge name
    sandbox_chrome_args: str | None = ""
    sandbox_https_proxy: str | None = None
    sandbox_http_proxy: str | None = None
    sandbox_no_proxy: str | None = None
    
    # Search engine configuration
    search_provider: str | None = "bing"  # "baidu", "google", "bing"
    google_search_api_key: str | None = None
    google_search_engine_id: str | None = None
    
    # Auth configuration
    auth_provider: str = "password"  # "password", "none", "local"
    password_salt: str | None = None
    password_hash_rounds: int = 10
    password_hash_algorithm: str = "pbkdf2_sha256"
    local_auth_email: str = "admin@example.com"
    local_auth_password: str = "admin"
    
    # Email configuration
    email_host: str | None = None  # "smtp.gmail.com"
    email_port: int | None = None  # 587
    email_username: str | None = None
    email_password: str | None = None
    email_from: str | None = None
    
    # JWT configuration
    jwt_secret_key: str = "your-secret-key-here"  # Should be set in production
    jwt_algorithm: str = "HS256"
    jwt_access_token_expire_minutes: int = 30
    jwt_refresh_token_expire_days: int = 7
    
    # MCP configuration
    mcp_config_path: str = "/etc/mcp.json"
    
    # Logging configuration
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
        
    def validate(self):
        """Validate configuration settings"""
        if not self.api_key:
            raise ValueError("API key is required")

@lru_cache()
def get_settings() -> Settings:
    """Get application settings"""
    settings = Settings()
    settings.validate()
    return settings 



================================================
FILE: backend/app/domain/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/domain/external/__init__.py
================================================
from app.domain.external.llm import LLM
from app.domain.external.sandbox import Sandbox
from app.domain.external.browser import Browser
from app.domain.external.search import SearchEngine
from app.domain.external.cache import Cache

__all__ = ['LLM', 'Sandbox', 'Browser', 'SearchEngine', 'Cache'] 


================================================
FILE: backend/app/domain/external/browser.py
================================================
from typing import Optional, Protocol
from app.domain.models.tool_result import ToolResult

class Browser(Protocol):
    """Browser service gateway interface"""
    
    async def view_page(self) -> ToolResult:
        """View current page content"""
        ...
    
    async def navigate(self, url: str) -> ToolResult:
        """Navigate to specified URL"""
        ...
    
    async def restart(self, url: str) -> ToolResult:
        """Restart browser and navigate to specified URL"""
        ...
    
    async def click(
        self,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Click element"""
        ...
    
    async def input(
        self,
        text: str,
        press_enter: bool,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Input text"""
        ...
    
    async def move_mouse(
        self,
        coordinate_x: float,
        coordinate_y: float
    ) -> ToolResult:
        """Move mouse"""
        ...
    
    async def press_key(self, key: str) -> ToolResult:
        """Simulate key press"""
        ...
    
    async def select_option(
        self,
        index: int,
        option: int
    ) -> ToolResult:
        """Select dropdown option"""
        ...
    
    async def scroll_up(
        self,
        to_top: Optional[bool] = None
    ) -> ToolResult:
        """Scroll up"""
        ...
    
    async def scroll_down(
        self,
        to_bottom: Optional[bool] = None
    ) -> ToolResult:
        """Scroll down"""
        ...
    
    async def screenshot(
        self,
        full_page: Optional[bool] = False
    ) -> bytes:
        """Take a screenshot of the current page"""
        ...
    
    async def console_exec(self, javascript: str) -> ToolResult:
        """Execute JavaScript code"""
        ...
    
    async def console_view(self, max_lines: Optional[int] = None) -> ToolResult:
        """View console output"""
        ...



================================================
FILE: backend/app/domain/external/cache.py
================================================
from typing import Protocol, Optional, Any
from datetime import timedelta

class Cache(Protocol):
    """Cache storage interface for temporary data storage"""
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """Store a value with optional TTL (time to live)
        
        Args:
            key: The cache key
            value: The value to store (will be JSON serialized)
            ttl: Time to live in seconds, None means no expiration
            
        Returns:
            bool: True if stored successfully, False otherwise
        """
        ...
    
    async def get(self, key: str) -> Optional[Any]:
        """Retrieve a value from cache
        
        Args:
            key: The cache key
            
        Returns:
            Any: The stored value (JSON deserialized), None if not found or expired
        """
        ...
    
    async def delete(self, key: str) -> bool:
        """Delete a value from cache
        
        Args:
            key: The cache key
            
        Returns:
            bool: True if deleted successfully, False if key didn't exist
        """
        ...
    
    async def exists(self, key: str) -> bool:
        """Check if a key exists in cache
        
        Args:
            key: The cache key
            
        Returns:
            bool: True if key exists and not expired, False otherwise
        """
        ...
    
    async def get_ttl(self, key: str) -> Optional[int]:
        """Get the remaining TTL of a key
        
        Args:
            key: The cache key
            
        Returns:
            int: Remaining TTL in seconds, None if key doesn't exist or has no expiration
        """
        ...
    
    async def keys(self, pattern: str) -> list[str]:
        """Get all keys matching a pattern
        
        Args:
            pattern: Pattern to match (implementation specific)
            
        Returns:
            list[str]: List of matching keys
        """
        ...
    
    async def clear_pattern(self, pattern: str) -> int:
        """Clear all keys matching a pattern
        
        Args:
            pattern: Pattern to match
            
        Returns:
            int: Number of keys deleted
        """
        ...



================================================
FILE: backend/app/domain/external/file.py
================================================
from typing import Protocol, BinaryIO, Optional, Dict, Any, Tuple
from app.domain.models.file import FileInfo

class FileStorage(Protocol):
    """File storage service interface for file upload and download operations"""
    
    async def upload_file(
        self,
        file_data: BinaryIO,
        filename: str,
        user_id: str,
        content_type: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> FileInfo:
        """Upload file to storage
        
        Args:
            file_data: Binary file data stream
            filename: Name of the file to be stored
            user_id: ID of the user uploading the file
            content_type: MIME type of the file (optional)
            metadata: Additional metadata to store with the file (optional)
            
        Returns:
            FileUploadResult containing file_id and upload information
        """
        ...
    
    async def download_file(
        self,
        file_id: str,
        user_id: Optional[str] = None
    ) -> Tuple[BinaryIO, FileInfo]:
        """Download file from storage by file ID
        
        Args:
            file_id: File ID
            user_id: ID of the user downloading the file (optional, if None skips access control)
            
        Returns:
            FileDownloadResult containing file data and metadata for FastAPI streaming
        """
        ...
    

    
    async def delete_file(
        self,
        file_id: str,
        user_id: str
    ) -> bool:
        """Delete file from storage
        
        Args:
            file_id: File ID
            user_id: ID of the user deleting the file
            
        Returns:
            True if deletion successful, False otherwise
        """
        ...
    
    async def get_file_info(
        self,
        file_id: str,
        user_id: str
    ) -> Optional[FileInfo]:
        """Get file metadata from storage
        
        Args:
            file_id: File ID
            user_id: ID of the user requesting file info
            
        Returns:
            FileInfo containing file metadata, None if file not found
        """
        ...




================================================
FILE: backend/app/domain/external/llm.py
================================================
from typing import List, Dict, Any, Optional, Protocol

class LLM(Protocol):
    """AI service gateway interface for interacting with AI services"""
    
    async def ask(
        self,
        messages: List[Dict[str, str]],
        tools: Optional[List[Dict[str, Any]]] = None,
        response_format: Optional[Dict[str, Any]] = None,
        tool_choice: Optional[str] = None
    ) -> Dict[str, Any]:
        """Send chat request to AI service
        
        Args:
            messages: List of messages, including conversation history
            tools: Optional list of tools for function calling
            response_format: Optional response format configuration
            tool_choice: Optional tool choice configuration
        Returns:
            Response message from AI service
        """
        ... 

    @property
    def model_name(self) -> str:
        """Get the model name"""
        ...
    
    @property
    def temperature(self) -> float:
        """Get the temperature"""
        ...

    @property
    def max_tokens(self) -> int:
        """Get the max tokens"""
        ...


================================================
FILE: backend/app/domain/external/message_queue.py
================================================
from typing import Any, Protocol, Tuple, Optional

class MessageQueue(Protocol):
    """Message queue interface for agent communication"""
    
    async def put(self, message: Any) -> str:
        """Put a message into the queue
        
        Returns:
            str: Message ID
        """
        ...
    
    async def get(self, start_id: Optional[str] = None, block_ms: Optional[int] = None) -> Tuple[str, Any]:
        """Get a message from the queue
        
        Args:
            start_id: Message ID to start reading from, defaults to "0" meaning from the earliest message
            block_ms: Block time in milliseconds, defaults to None meaning no blocking
            
        Returns:
            Tuple[str, Any]: (Message ID, Message content), returns (None, None) if no message
        """
        ...
    
    async def pop(self) -> Tuple[str, Any]:
        """Get and remove the first message from the queue
        
        Returns:
            Tuple[str, Any]: (Message ID, Message content), returns (None, None) if queue is empty
        """
        ...
    
    async def clear(self) -> None:
        """Clear all messages from the queue"""
        ...
    
    async def is_empty(self) -> bool:
        """Check if the queue is empty"""
        ...
    
    async def size(self) -> int:
        """Get the current size of the queue"""
        ...

    async def delete_message(self, message_id: str) -> bool:
        """Delete a specific message from the queue
        
        Args:
            message_id: ID of the message to delete
            
        Returns:
            bool: True if message was deleted successfully, False otherwise
        """
        ... 



================================================
FILE: backend/app/domain/external/sandbox.py
================================================
from typing import Any, Optional, Protocol, BinaryIO
from app.domain.models.tool_result import ToolResult
from app.domain.external.browser import Browser
from app.domain.external.llm import LLM

class Sandbox(Protocol):
    """Sandbox service gateway interface"""

    async def ensure_sandbox(self) -> None:
        """Ensure sandbox is ready"""
        ...
    
    async def exec_command(
        self,
        session_id: str,
        exec_dir: str,
        command: str
    ) -> ToolResult:
        """Execute command
        
        Args:
            session_id: Session ID
            exec_dir: Execution directory
            command: Command to execute
            
        Returns:
            Command execution result
        """
        ...
    
    async def view_shell(self, session_id: str, console: bool = False) -> ToolResult:
        """View shell status
        
        Args:
            session_id: Session ID
            console: Whether to return console records

        Returns:
            Shell status information
        """
        ...
    
    async def wait_for_process(
        self,
        session_id: str,
        seconds: Optional[int] = None
    ) -> ToolResult:
        """Wait for process
        
        Args:
            session_id: Session ID
            seconds: Wait seconds
            
        Returns:
            Wait result
        """
        ...
    
    async def write_to_process(
        self,
        session_id: str,
        input_text: str,
        press_enter: bool = True
    ) -> ToolResult:
        """Write input to process
        
        Args:
            session_id: Session ID
            input_text: Input text
            press_enter: Whether to press enter
            
        Returns:
            Write result
        """
        ...
    
    async def kill_process(self, session_id: str) -> ToolResult:
        """Terminate process
        
        Args:
            session_id: Session ID
            
        Returns:
            Termination result
        """
        ...
    
    async def file_write(
        self, 
        file: str, 
        content: str, 
        append: bool = False, 
        leading_newline: bool = False, 
        trailing_newline: bool = False, 
        sudo: bool = False
    ) -> ToolResult:
        """Write content to file
        
        Args:
            file: File path
            content: Content to write
            append: Whether to append content
            leading_newline: Whether to add newline before content
            trailing_newline: Whether to add newline after content
            sudo: Whether to use sudo privileges
            
        Returns:
            Write operation result
        """
        ...
    
    async def file_read(
        self, 
        file: str, 
        start_line: int = None, 
        end_line: int = None, 
        sudo: bool = False
    ) -> ToolResult:
        """Read file content
        
        Args:
            file: File path
            start_line: Start line number
            end_line: End line number
            sudo: Whether to use sudo privileges
            
        Returns:
            File content
        """
        ...
    
    async def file_exists(self, path: str) -> ToolResult:
        """Check if file exists
        
        Args:
            path: File path
            
        Returns:
            Whether file exists
        """
        ...
    
    async def file_delete(self, path: str) -> ToolResult:
        """Delete file
        
        Args:
            path: File path
            
        Returns:
            Delete operation result
        """
        ...
    
    async def file_list(self, path: str) -> ToolResult:
        """List directory contents
        
        Args:
            path: Directory path
            
        Returns:
            Directory content list
        """
        ...
    
    async def file_replace(
        self, 
        file: str, 
        old_str: str, 
        new_str: str, 
        sudo: bool = False
    ) -> ToolResult:
        """Replace string in file
        
        Args:
            file: File path
            old_str: String to replace
            new_str: Replacement string
            sudo: Whether to use sudo privileges
            
        Returns:
            Replace operation result
        """
        ...
    
    async def file_search(
        self, 
        file: str, 
        regex: str, 
        sudo: bool = False
    ) -> ToolResult:
        """Search in file content
        
        Args:
            file: File path
            regex: Regular expression
            sudo: Whether to use sudo privileges
            
        Returns:
            Search result
        """
        ...
    
    async def file_find(
        self, 
        path: str, 
        glob_pattern: str
    ) -> ToolResult:
        """Find files by name pattern
        
        Args:
            path: Search directory path
            glob_pattern: Glob matching pattern
            
        Returns:
            Found file list
        """
        ...
    
    async def file_upload(
        self,
        file_data: BinaryIO,
        path: str,
        filename: str = None
    ) -> ToolResult:
        """Upload file to sandbox
        
        Args:
            file_data: File content as binary stream
            path: Target file path in sandbox
            filename: Original filename (optional)
            
        Returns:
            Upload operation result
        """
        ...
    
    async def file_download(
        self,
        path: str
    ) -> BinaryIO:
        """Download file from sandbox
        
        Args:
            path: File path in sandbox
            
        Returns:
            File content as binary stream
        """
        ...
    
    async def destroy(self) -> bool:
        """Destroy current sandbox instance
        
        Returns:
            Whether destroyed successfully
        """
        ...
    
    async def get_browser(self) -> Browser:
        """Get browser instance
        
        Returns:
            Browser: Returns a configured browser instance for web automation
        """
        ...

    @property
    def id(self) -> str:
        """Sandbox ID"""
        ...

    @property
    def cdp_url(self) -> str:
        """CDP URL"""
        ...

    @property
    def vnc_url(self) -> str:
        """VNC URL"""
        ...
    
    @classmethod
    async def create(cls) -> 'Sandbox':
        """Create a new sandbox instance"""
        ...
    
    @classmethod
    async def get(cls, id: str) -> 'Sandbox':
        """Get sandbox by ID
        
        Args:
            id: Sandbox ID
            
        Returns:
            Sandbox instance
        """
        ...



================================================
FILE: backend/app/domain/external/search.py
================================================
from typing import Optional, Protocol
from app.domain.models.tool_result import ToolResult
from app.domain.models.search import SearchResults

class SearchEngine(Protocol):
    """Search engine service gateway interface"""
    
    async def search(
        self, 
        query: str, 
        date_range: Optional[str] = None
    ) -> ToolResult[SearchResults]:
        """Search webpages using search engine
        
        Args:
            query: Search query, Google search style, using 3-5 keywords
            date_range: (Optional) Time range filter for search results
            
        Returns:
            Search results
        """
        ... 


================================================
FILE: backend/app/domain/external/task.py
================================================
from typing import Protocol, Any, Awaitable, Optional, Callable
from abc import ABC, abstractmethod
from app.domain.external.message_queue import MessageQueue


class TaskRunner(ABC):
    """Abstract base class defining the interface for task runners.
    
    This interface defines two essential lifecycle methods:
    - run: Main task execution logic
    - on_stop: Called when task execution needs to stop
    """

    @abstractmethod
    async def run(self, task: "Task") -> None:
        """Main task execution logic.
        
        This method contains the core functionality of the task.
        Implementations should handle setup, execution, and cleanup.
        """
        ...
    
    @abstractmethod
    async def destroy(self) -> None:
        """Destroy the task and release resources.
        
        Called when the task needs to be destroyed.
        This method is responsible for cleaning up and releasing all resources used by the task,
        including but not limited to:
        - Closing network connections
        - Freeing memory
        - Cleaning up temporary files
        - Stopping background processes etc.
        """
        ...

    @abstractmethod
    async def on_done(self, task: "Task") -> None:
        """Called when task execution is done.
        
        Use this method to handle graceful shutdown and cleanup.
        This method should ensure all resources are properly released.
        """
        ...

class Task(Protocol):
    """Protocol defining the interface for task management operations."""
    
    async def run(self) -> None:
        """Run a task."""
        ...
    
    def cancel(self) -> bool:
        """Cancel a task.

        Returns:
            bool: True if the task is cancelled, False otherwise
        """
        ...
    
    @property
    def input_stream(self) -> MessageQueue:
        """Input stream."""
        ...
    
    @property
    def output_stream(self) -> MessageQueue:
        """Output stream."""
        ...
    
    @property
    def id(self) -> str:
        """Task ID."""
        ...
    
    @property
    def done(self) -> bool:
        """Check if the task is done.

        Returns:
            bool: True if the task is done, False otherwise
        """
        ...
    
    @classmethod
    def get(cls, task_id: str) -> Optional["Task"]:
        """Get a task by its ID.

        Returns:
            Optional[Task]: Task instance if found, None otherwise
        """
        ...
    
    @classmethod
    def create(cls, runner: TaskRunner) -> "Task":
        """Create a new task instance with the specified task runner.

        Args:
            runner (TaskRunner): The task runner that will execute this task

        Returns:
            Task: New task instance
        """
        ...

    @classmethod
    async def destroy(cls) -> None:
        """Destroy all task instances.
        
        Cleans up all running tasks and releases associated resources.
        """
        ...



================================================
FILE: backend/app/domain/models/__init__.py
================================================
from .search import SearchResults, SearchResultItem



================================================
FILE: backend/app/domain/models/agent.py
================================================
from typing import Optional, Dict
from datetime import datetime, UTC
from pydantic import BaseModel, Field, field_validator
from app.domain.models.memory import Memory
import uuid

class Agent(BaseModel):
    """
    Agent aggregate root that manages the lifecycle and state of an AI agent
    Including its execution context, memory, and current plan
    """
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:16])
    memories: Dict[str, Memory] = Field(default_factory=dict)
    model_name: str = Field(default="")
    temperature: float = Field(default=0.7)
    max_tokens: int = Field(default=2000)
    
    # Context related fields
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))  # Creation timestamp
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))  # Last update timestamp

    @field_validator("temperature")
    def validate_temperature(cls, v: float) -> float:
        """Validate temperature is between 0 and 1"""
        if not 0 <= v <= 1:
            raise ValueError("Temperature must be between 0 and 1")
        return v

    @field_validator("max_tokens")
    def validate_max_tokens(cls, v: Optional[int]) -> Optional[int]:
        """Validate max_tokens is positive if provided"""
        if v is not None and v <= 0:
            raise ValueError("Max tokens must be positive")
        return v

    class Config:
        arbitrary_types_allowed = True



================================================
FILE: backend/app/domain/models/auth.py
================================================
"""Authentication related domain models"""

from pydantic import BaseModel
from typing import Optional
from app.domain.models.user import User


class AuthToken(BaseModel):
    """Authentication token model for login and refresh operations"""
    access_token: str
    token_type: str = "bearer"
    refresh_token: Optional[str] = None
    user: Optional[User] = None


================================================
FILE: backend/app/domain/models/event.py
================================================
from pydantic import BaseModel, Field, RootModel
from typing import Dict, Any, Literal, Optional, Union, List, get_args
from datetime import datetime
import time
import uuid
from enum import Enum
from app.domain.models.plan import Plan, Step
from app.domain.models.file import FileInfo
import json
from app.domain.models.search import SearchResultItem


class PlanStatus(str, Enum):
    """Plan status enum"""
    CREATED = "created"
    UPDATED = "updated"
    COMPLETED = "completed"


class StepStatus(str, Enum):
    """Step status enum"""
    STARTED = "started"
    FAILED = "failed"
    COMPLETED = "completed"


class ToolStatus(str, Enum):
    """Tool status enum"""
    CALLING = "calling"
    CALLED = "called"


class BaseEvent(BaseModel):
    """Base class for agent events"""
    type: Literal[""] = ""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=lambda: datetime.now())

class ErrorEvent(BaseEvent):
    """Error event"""
    type: Literal["error"] = "error"
    error: str

class PlanEvent(BaseEvent):
    """Plan related events"""
    type: Literal["plan"] = "plan"
    plan: Plan
    status: PlanStatus
    step: Optional[Step] = None

class BrowserToolContent(BaseModel):
    """Browser tool content"""
    screenshot: str

class SearchToolContent(BaseModel):
    """Search tool content"""
    results: List[SearchResultItem]

class ShellToolContent(BaseModel):
    """Shell tool content"""
    console: Any

class FileToolContent(BaseModel):
    """File tool content"""
    content: str

class McpToolContent(BaseModel):
    """MCP tool content"""
    result: Any

ToolContent = Union[
    BrowserToolContent,
    SearchToolContent,
    ShellToolContent,
    FileToolContent,
    McpToolContent
]

class ToolEvent(BaseEvent):
    """Tool related events"""
    type: Literal["tool"] = "tool"
    tool_call_id: str
    tool_name: str
    tool_content: Optional[ToolContent] = None
    function_name: str
    function_args: Dict[str, Any]
    status: ToolStatus
    function_result: Optional[Any] = None

class TitleEvent(BaseEvent):
    """Title event"""
    type: Literal["title"] = "title"
    title: str

class StepEvent(BaseEvent):
    """Step related events"""
    type: Literal["step"] = "step"
    step: Step
    status: StepStatus

class MessageEvent(BaseEvent):
    """Message event"""
    type: Literal["message"] = "message"
    role: Literal["user", "assistant"] = "assistant"
    message: str
    attachments: Optional[List[FileInfo]] = None

class DoneEvent(BaseEvent):
    """Done event"""
    type: Literal["done"] = "done"

class WaitEvent(BaseEvent):
    """Wait event"""
    type: Literal["wait"] = "wait"

AgentEvent = Union[
    ErrorEvent,
    PlanEvent, 
    ToolEvent,
    StepEvent,
    MessageEvent,
    DoneEvent,
    TitleEvent,
    WaitEvent,
]



================================================
FILE: backend/app/domain/models/file.py
================================================
from typing import Optional, Dict, Any, List
from datetime import datetime
from pydantic import BaseModel


class FileInfo(BaseModel):
    file_id: Optional[str] = None
    filename: Optional[str] = None
    file_path: Optional[str] = None
    content_type: Optional[str] = None
    size: Optional[int] = None
    upload_date: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    user_id: Optional[str] = None



================================================
FILE: backend/app/domain/models/mcp_config.py
================================================
from typing import Optional, Dict, List, Any
from pydantic import BaseModel, Field, field_validator
from enum import Enum


class MCPTransport(str, Enum):
    """MCP transport types"""
    STDIO = "stdio"
    SSE = "sse"
    STREAMABLE_HTTP = "streamable-http"


class MCPServerConfig(BaseModel):
    """
    MCP server configuration model
    """
    # For stdio transport
    command: Optional[str] = None
    args: Optional[List[str]] = None
    
    # For HTTP-based transports
    url: Optional[str] = None
    headers: Optional[Dict[str, str]] = None
    
    # Common fields
    transport: MCPTransport
    enabled: bool = Field(default=True)
    description: Optional[str] = None
    env: Optional[Dict[str, str]] = None
    
    @field_validator("url")
    def validate_url_for_http_transport(cls, v: Optional[str], values) -> Optional[str]:
        """Validate URL is required for HTTP-based transports"""
        if hasattr(values, 'data'):
            transport = values.data.get('transport')
            if transport in [MCPTransport.SSE, MCPTransport.STREAMABLE_HTTP] and not v:
                raise ValueError("URL is required for HTTP-based transports")
        return v
    
    @field_validator("command")
    def validate_command_for_stdio(cls, v: Optional[str], values) -> Optional[str]:
        """Validate command is required for stdio transport"""
        if hasattr(values, 'data'):
            transport = values.data.get('transport')
            if transport == MCPTransport.STDIO and not v:
                raise ValueError("Command is required for stdio transport")
        return v
    
    class Config:
        extra = "allow"


class MCPConfig(BaseModel):
    """
    MCP configuration model containing all server configurations
    """
    mcpServers: Dict[str, MCPServerConfig] = Field(default_factory=dict)
    
    class Config:
        arbitrary_types_allowed = True
        extra = "allow"


================================================
FILE: backend/app/domain/models/memory.py
================================================
import logging
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from app.domain.models.tool_result import ToolResult


logger = logging.getLogger(__name__)

class Memory(BaseModel):
    """
    Memory class, defining the basic behavior of memory
    """
    messages: List[Dict[str, Any]] = []

    def get_message_role(self, message: Dict[str, Any]) -> str:
        """Get the role of the message"""
        return message.get("role")

    def add_message(self, message: Dict[str, Any]) -> None:
        """Add message to memory"""
        self.messages.append(message)
    
    def add_messages(self, messages: List[Dict[str, Any]]) -> None:
        """Add messages to memory"""
        self.messages.extend(messages)

    def get_messages(self) -> List[Dict[str, Any]]:
        """Get all message history"""
        return self.messages
    
    def get_last_message(self) -> Optional[Dict[str, Any]]:
        """Get the last message"""
        if len(self.messages) > 0:  
            return self.messages[-1]
        return None
    
    def roll_back(self) -> None:
        """Roll back memory"""
        self.messages = self.messages[:-1]
    
    def compact(self) -> None:
        """Compact memory"""
        for message in self.messages:
            if message.get("role") == "tool":
                if message.get("function_name") in ["browser_view", "browser_navigate"]:
                    message["content"] = ToolResult(success=True, data='(removed)').model_dump_json()
                    logger.debug(f"Removed tool result from memory: {message['function_name']}")

    @property
    def empty(self) -> bool:
        """Check if memory is empty"""
        return len(self.messages) == 0



================================================
FILE: backend/app/domain/models/message.py
================================================
from typing import List
from pydantic import BaseModel

class Message(BaseModel):
    message: str = ""
    attachments: List[str] = []


================================================
FILE: backend/app/domain/models/plan.py
================================================
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from enum import Enum
import uuid

class ExecutionStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"

class Step(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    description: str = ""
    status: ExecutionStatus = ExecutionStatus.PENDING
    result: Optional[str] = None
    error: Optional[str] = None
    success: bool = False
    attachments: List[str] = []

    def is_done(self) -> bool:
        return self.status == ExecutionStatus.COMPLETED or self.status == ExecutionStatus.FAILED

class Plan(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    title: str = ""
    goal: str = ""
    language: Optional[str] = "en"
    steps: List[Step] = []
    message: Optional[str] = None
    status: ExecutionStatus = ExecutionStatus.PENDING
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

    def is_done(self) -> bool:
        return self.status == ExecutionStatus.COMPLETED or self.status == ExecutionStatus.FAILED
    
    def get_next_step(self) -> Optional[Step]:
        for step in self.steps:
            if not step.is_done():
                return step
        return None
    
    def dump_json(self) -> str:
        return self.model_dump_json(include={"goal", "language", "steps"})



================================================
FILE: backend/app/domain/models/search.py
================================================
from pydantic import BaseModel, Field
from typing import List, Optional


class SearchResultItem(BaseModel):
    """Single search result item"""
    title: str = Field(..., description="Title of the search result")
    link: str = Field(..., description="URL link of the search result")
    snippet: str = Field(default="", description="Snippet or description of the search result")


class SearchResults(BaseModel):
    """Complete search results data structure"""
    query: str = Field(..., description="Original search query")
    date_range: Optional[str] = Field(default=None, description="Date range filter applied")
    total_results: int = Field(default=0, description="Total results count")
    results: List[SearchResultItem] = Field(default_factory=list, description="List of search results")



================================================
FILE: backend/app/domain/models/session.py
================================================
from pydantic import BaseModel, Field
from datetime import datetime, UTC
from typing import List, Optional
from enum import Enum
import uuid
from app.domain.models.event import PlanEvent, AgentEvent
from app.domain.models.plan import Plan
from app.domain.models.file import FileInfo


class SessionStatus(str, Enum):
    """Session status enum"""
    PENDING = "pending"
    RUNNING = "running"
    WAITING = "waiting"
    COMPLETED = "completed"


class Session(BaseModel):
    """Session model"""
    id: str = Field(default_factory=lambda: uuid.uuid4().hex[:16])
    user_id: str  # User ID that owns this session
    sandbox_id: Optional[str] = Field(default=None)  # Identifier for the sandbox environment
    agent_id: str
    task_id: Optional[str] = None
    title: Optional[str] = None
    unread_message_count: int = 0
    latest_message: Optional[str] = None
    latest_message_at: Optional[datetime] = Field(default_factory=lambda: datetime.now(UTC))
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
    events: List[AgentEvent] = []
    files: List[FileInfo] = []
    status: SessionStatus = SessionStatus.PENDING

    def get_last_plan(self) -> Optional[Plan]:
        """Get the last plan from the events"""
        for event in reversed(self.events):
            if isinstance(event, PlanEvent):
                return event.plan
        return None


================================================
FILE: backend/app/domain/models/tool_result.py
================================================
from pydantic import BaseModel
from typing import Any, Optional, TypeVar, Generic

T = TypeVar('T')

class ToolResult(BaseModel, Generic[T]):
    success: bool
    message: Optional[str] = None
    data: Optional[T] = None



================================================
FILE: backend/app/domain/models/user.py
================================================
from typing import Optional
from datetime import datetime, UTC
from pydantic import BaseModel, field_validator, EmailStr
from enum import Enum


class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"


class User(BaseModel):
    """User domain model"""
    id: str
    fullname: str
    email: str  # Now required field for login
    password_hash: Optional[str] = None
    role: UserRole = UserRole.USER
    is_active: bool = True
    created_at: datetime = datetime.now(UTC)
    updated_at: datetime = datetime.now(UTC)
    last_login_at: Optional[datetime] = None
    
    @field_validator('fullname')
    @classmethod
    def validate_fullname(cls, v):
        if not v or len(v.strip()) < 2:
            raise ValueError("Full name must be at least 2 characters long")
        return v.strip()
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if not v or '@' not in v:
            raise ValueError("Valid email is required")
        return v.strip().lower()
    
    def update_last_login(self):
        """Update last login timestamp"""
        self.last_login_at = datetime.now(UTC)
        self.updated_at = datetime.now(UTC)
    
    def deactivate(self):
        """Deactivate user account"""
        self.is_active = False
        self.updated_at = datetime.now(UTC)
    
    def activate(self):
        """Activate user account"""
        self.is_active = True
        self.updated_at = datetime.now(UTC) 


================================================
FILE: backend/app/domain/models/sandbox/file.py
================================================
"""
File operation related models
"""
from pydantic import BaseModel, Field
from typing import List, Optional


class FileReadResult(BaseModel):
    """File read result"""
    content: str = Field(..., description="File content")
    file: str = Field(..., description="Path of the read file")


class FileWriteResult(BaseModel):
    """File write result"""
    file: str = Field(..., description="Path of the written file")
    bytes_written: Optional[int] = Field(None, description="Number of bytes written")


class FileReplaceResult(BaseModel):
    """File content replacement result"""
    file: str = Field(..., description="Path of the operated file")
    replaced_count: int = Field(0, description="Number of replacements")


class FileSearchResult(BaseModel):
    """File content search result"""
    file: str = Field(..., description="Path of the searched file")
    matches: List[str] = Field([], description="List of matched content")
    line_numbers: List[int] = Field([], description="List of matched line numbers")


class FileFindResult(BaseModel):
    """File find result"""
    path: str = Field(..., description="Path of the search directory")
    files: List[str] = Field([], description="List of found files")


class FileUploadResult(BaseModel):
    """File upload result"""
    file_path: str = Field(..., description="Path of the uploaded file")
    file_size: int = Field(..., description="Size of the uploaded file in bytes")
    success: bool = Field(..., description="Whether upload was successful")



================================================
FILE: backend/app/domain/models/sandbox/shell.py
================================================
"""
Shell business model definitions
"""
from typing import Optional, List
from pydantic import BaseModel, Field


class ConsoleRecord(BaseModel):
    """Shell command console record model"""
    ps1: str = Field(..., description="Command prompt")
    command: str = Field(..., description="Executed command")
    output: str = Field(default="", description="Command output")


class ShellTask(BaseModel):
    """Shell task model"""
    id: str = Field(..., description="Task unique identifier")
    command: str = Field(..., description="Executed command")
    status: str = Field(..., description="Task status")
    created_at: str = Field(..., description="Task creation time")
    output: Optional[str] = Field(None, description="Task output")


class ShellExecResult(BaseModel):
    """Shell command execution result model"""
    session_id: str = Field(..., description="Shell session ID")
    command: str = Field(..., description="Executed command")
    status: str = Field(..., description="Command execution status")
    returncode: Optional[int] = Field(None, description="Process return code, only has value when status is completed")
    output: Optional[str] = Field(None, description="Command execution output, only has value when status is completed")


class ShellViewResult(BaseModel):
    """Shell session content view result model"""
    output: str = Field(..., description="Shell session output content")
    session_id: str = Field(..., description="Shell session ID")
    console: Optional[List[ConsoleRecord]] = Field(None, description="Console command records")


class ShellWaitResult(BaseModel):
    """Process wait result model"""
    returncode: int = Field(..., description="Process return code")


class ShellWriteResult(BaseModel):
    """Process input write result model"""
    status: str = Field(..., description="Write status")


class ShellKillResult(BaseModel):
    """Process termination result model"""
    status: str = Field(..., description="Process status")
    returncode: int = Field(..., description="Process return code") 


================================================
FILE: backend/app/domain/models/sandbox/supervisor.py
================================================
"""
Supervisor business model definitions
"""
from typing import Optional, List
from pydantic import BaseModel, Field


class ProcessInfo(BaseModel):
    """Process information model"""
    name: str = Field(..., description="Process name")
    group: str = Field(..., description="Process group")
    description: str = Field(..., description="Process description")
    start: int = Field(..., description="Start timestamp")
    stop: int = Field(..., description="Stop timestamp")
    now: int = Field(..., description="Current timestamp")
    state: int = Field(..., description="State code")
    statename: str = Field(..., description="State name")
    spawnerr: str = Field(..., description="Spawn error")
    exitstatus: int = Field(..., description="Exit status code")
    logfile: str = Field(..., description="Log file")
    stdout_logfile: str = Field(..., description="Standard output log file")
    stderr_logfile: str = Field(..., description="Standard error log file")
    pid: int = Field(..., description="Process ID")


class SupervisorActionResult(BaseModel):
    """Supervisor operation result model"""
    status: str = Field(..., description="Operation status")
    result: Optional[List[str]] = Field(None, description="Operation result")
    stop_result: Optional[List[str]] = Field(None, description="Stop result")
    start_result: Optional[List[str]] = Field(None, description="Start result")
    shutdown_result: Optional[List[str]] = Field(None, description="Shutdown result")


class SupervisorTimeout(BaseModel):
    """Supervisor timeout model"""
    status: Optional[str] = Field(None, description="Timeout setting status")
    active: bool = Field(False, description="Whether timeout is active")
    shutdown_time: Optional[str] = Field(None, description="Shutdown time")
    timeout_minutes: Optional[float] = Field(None, description="Timeout duration (minutes)")
    remaining_seconds: Optional[float] = Field(None, description="Remaining seconds") 


================================================
FILE: backend/app/domain/repositories/agent_repository.py
================================================
from typing import Optional, List, Protocol
from app.domain.models.agent import Agent
from app.domain.models.plan import Plan
from app.domain.models.memory import Memory

class AgentRepository(Protocol):
    """Repository interface for Agent aggregate"""
    
    async def save(self, agent: Agent) -> None:
        """Save or update an agent"""
        ...
    
    async def find_by_id(self, agent_id: str) -> Optional[Agent]:
        """Find an agent by its ID"""
        ...
    
    async def add_memory(self, agent_id: str,
                        name: str,
                        memory: Memory) -> None:
        """Add or update a memory for an agent"""
        ...

    async def get_memory(self, agent_id: str, name: str) -> Memory:
        """Get memory by name from agent, create if not exists"""
        ...

    async def save_memory(self, agent_id: str, name: str, memory: Memory) -> None:
        """Update the messages of a memory"""
        ... 


================================================
FILE: backend/app/domain/repositories/mcp_repository.py
================================================
from typing import Protocol
from app.domain.models.mcp_config import MCPConfig

class MCPRepository(Protocol):
    """Repository interface for MCP aggregate"""
    
    async def get_mcp_config(self) -> MCPConfig:
        """Get the MCP config"""
        ...


================================================
FILE: backend/app/domain/repositories/session_repository.py
================================================
from typing import Optional, Protocol, List
from datetime import datetime
from app.domain.models.session import Session, SessionStatus
from app.domain.models.file import FileInfo
from app.domain.models.event import BaseEvent

class SessionRepository(Protocol):
    """Repository interface for Session aggregate"""
    
    async def save(self, session: Session) -> None:
        """Save or update a session"""
        ...
    
    async def find_by_id(self, session_id: str) -> Optional[Session]:
        """Find a session by its ID"""
        ...
    
    async def find_by_user_id(self, user_id: str) -> List[Session]:
        """Find all sessions for a specific user"""
        ...
    
    async def find_by_id_and_user_id(self, session_id: str, user_id: str) -> Optional[Session]:
        """Find a session by ID and user ID (for authorization)"""
        ...
    
    async def update_title(self, session_id: str, title: str) -> None:
        """Update the title of a session"""
        ...

    async def update_latest_message(self, session_id: str, message: str, timestamp: datetime) -> None:
        """Update the latest message of a session"""
        ...

    async def add_event(self, session_id: str, event: BaseEvent) -> None:
        """Add an event to a session"""
        ...
    
    async def add_file(self, session_id: str, file_info: FileInfo) -> None:
        """Add a file to a session"""
        ...
    
    async def remove_file(self, session_id: str, file_id: str) -> None:
        """Remove a file from a session"""
        ...

    async def get_file_by_path(self, session_id: str, file_path: str) -> Optional[FileInfo]:
        """Get file by path from a session"""
        ...

    async def update_status(self, session_id: str, status: SessionStatus) -> None:
        """Update the status of a session"""
        ...
    
    async def update_unread_message_count(self, session_id: str, count: int) -> None:
        """Update the unread message count of a session"""
        ...
    
    async def increment_unread_message_count(self, session_id: str) -> None:
        """Increment the unread message count of a session"""
        ...
    
    async def decrement_unread_message_count(self, session_id: str) -> None:
        """Decrement the unread message count of a session"""
        ...
    
    async def delete(self, session_id: str) -> None:
        """Delete a session"""
        ...
    
    async def get_all(self) -> List[Session]:
        """Get all sessions"""
        ...


================================================
FILE: backend/app/domain/repositories/user_repository.py
================================================
from abc import ABC, abstractmethod
from typing import List, Optional
from app.domain.models.user import User


class UserRepository(ABC):
    """User repository interface"""
    
    @abstractmethod
    async def create_user(self, user: User) -> User:
        """Create a new user"""
        pass
    
    @abstractmethod
    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """Get user by ID"""
        pass
    
    @abstractmethod
    async def get_user_by_fullname(self, fullname: str) -> Optional[User]:
        """Get user by fullname"""
        pass
    
    @abstractmethod
    async def get_user_by_email(self, email: str) -> Optional[User]:
        """Get user by email"""
        pass
    
    @abstractmethod
    async def update_user(self, user: User) -> User:
        """Update user information"""
        pass
    
    @abstractmethod
    async def delete_user(self, user_id: str) -> bool:
        """Delete user by ID"""
        pass
    
    @abstractmethod
    async def list_users(self, limit: int = 100, offset: int = 0) -> List[User]:
        """List users with pagination"""
        pass
    
    @abstractmethod
    async def fullname_exists(self, fullname: str) -> bool:
        """Check if fullname exists"""
        pass
    
    @abstractmethod
    async def email_exists(self, email: str) -> bool:
        """Check if email exists"""
        pass 


================================================
FILE: backend/app/domain/services/__init__.py
================================================
from .agent_domain_service import AgentDomainService

__all__ = [
    'AgentDomainService'
]



================================================
FILE: backend/app/domain/services/agent_domain_service.py
================================================
from typing import Optional, AsyncGenerator, List
import logging
import time
from datetime import datetime
from app.domain.models.session import Session, SessionStatus
from app.domain.external.llm import LLM
from app.domain.external.sandbox import Sandbox
from app.domain.external.search import SearchEngine
from app.domain.models.event import BaseEvent, ErrorEvent, DoneEvent, MessageEvent, WaitEvent, AgentEvent
from pydantic import TypeAdapter
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.repositories.session_repository import SessionRepository
from app.domain.services.agent_task_runner import AgentTaskRunner
from app.domain.external.task import Task
from app.domain.utils.json_parser import JsonParser
from typing import Type
from app.domain.external.file import FileStorage
from app.domain.models.file import FileInfo
from app.domain.repositories.mcp_repository import MCPRepository

# Setup logging
logger = logging.getLogger(__name__)

class AgentDomainService:
    """
    Agent domain service, responsible for coordinating the work of planning agent and execution agent
    """
    
    def __init__(
        self,
        agent_repository: AgentRepository,
        session_repository: SessionRepository,
        llm: LLM,
        sandbox_cls: Type[Sandbox],
        task_cls: Type[Task],
        json_parser: JsonParser,
        file_storage: FileStorage,
        mcp_repository: MCPRepository,
        search_engine: Optional[SearchEngine] = None,
    ):
        self._repository = agent_repository
        self._session_repository =session_repository
        self._llm = llm
        self._sandbox_cls = sandbox_cls
        self._search_engine = search_engine
        self._task_cls = task_cls
        self._json_parser = json_parser
        self._file_storage = file_storage
        self._mcp_repository = mcp_repository
        logger.info("AgentDomainService initialization completed")
            
    async def shutdown(self) -> None:
        """Clean up all Agent's resources"""
        logger.info(f"Starting to close all Agents")
        await self._task_cls.destroy()
        logger.info("All agents closed successfully")

    async def _create_task(self, session: Session) -> Task:
        """Create a new agent task"""
        sandbox = None
        sandbox_id = session.sandbox_id
        if sandbox_id:
            sandbox = await self._sandbox_cls.get(sandbox_id)
        if not sandbox:
            sandbox = await self._sandbox_cls.create()
            session.sandbox_id = sandbox.id
            await self._session_repository.save(session)
        browser = await sandbox.get_browser()
        if not browser:
            logger.error(f"Failed to get browser for Sandbox {sandbox_id}")
            raise RuntimeError(f"Failed to get browser for Sandbox {sandbox_id}")
        
        await self._session_repository.save(session)

        task_runner = AgentTaskRunner(
            session_id=session.id,
            agent_id=session.agent_id,
            user_id=session.user_id,
            llm=self._llm,
            sandbox=sandbox,
            browser=browser,
            file_storage=self._file_storage,
            search_engine=self._search_engine,
            session_repository=self._session_repository,
            json_parser=self._json_parser,
            agent_repository=self._repository,
            mcp_repository=self._mcp_repository,
        )

        task = self._task_cls.create(task_runner)
        session.task_id = task.id
        await self._session_repository.save(session)

        return task
        
    async def _get_task(self, session: Session) -> Optional[Task]:
        """Get a task for the given session"""

        task_id = session.task_id
        if not task_id:
            return None
        
        return self._task_cls.get(task_id)

    async def stop_session(self, session_id: str) -> None:
        """Stop a session"""
        session = await self._session_repository.find_by_id(session_id)
        if not session:
            logger.error(f"Attempted to stop non-existent Session {session_id}")
            raise RuntimeError("Session not found")
        task = await self._get_task(session)
        if task:
            task.cancel()
        await self._session_repository.update_status(session_id, SessionStatus.COMPLETED)

    async def chat(
        self,
        session_id: str,
        user_id: str,
        message: Optional[str] = None,
        timestamp: Optional[datetime] = None,
        latest_event_id: Optional[str] = None,
        attachments: Optional[List[str]] = None
    ) -> AsyncGenerator[BaseEvent, None]:
        """
        Chat with an agent
        """

        try:
            session = await self._session_repository.find_by_id_and_user_id(session_id, user_id)
            if not session:
                logger.error(f"Attempted to chat with non-existent Session {session_id} for user {user_id}")
                raise RuntimeError("Session not found")

            task = await self._get_task(session)

            if message:
                if session.status != SessionStatus.RUNNING:
                    task = await self._create_task(session)
                    if not task:
                        raise RuntimeError("Failed to create task")
                
                await self._session_repository.update_latest_message(session_id, message, timestamp or datetime.now())

                message_event = MessageEvent(
                    message=message, 
                    role="user", 
                    attachments=[FileInfo(file_id=attachment) for attachment in attachments]
                )

                event_id = await task.input_stream.put(message_event.model_dump_json())

                message_event.id = event_id
                await self._session_repository.add_event(session_id, message_event)
                
                await task.run()
                logger.debug(f"Put message into Session {session_id}'s event queue: {message[:50]}...")
            
            logger.info(f"Session {session_id} started")
            logger.debug(f"Session {session_id} task: {task}")
           
            while task and not task.done:
                event_id, event_str = await task.output_stream.get(start_id=latest_event_id, block_ms=0)
                latest_event_id = event_id
                if event_str is None:
                    logger.debug(f"No event found in Session {session_id}'s event queue")
                    continue
                event = TypeAdapter(AgentEvent).validate_json(event_str)
                event.id = event_id
                logger.debug(f"Got event from Session {session_id}'s event queue: {type(event).__name__}")
                await self._session_repository.update_unread_message_count(session_id, 0)
                yield event
                if isinstance(event, (DoneEvent, ErrorEvent, WaitEvent)):
                    break
            
            logger.info(f"Session {session_id} completed")

        except Exception as e:
            logger.exception(f"Error in Session {session_id}")
            event = ErrorEvent(error=str(e))
            await self._session_repository.add_event(session_id, event)
            yield event # TODO: raise api exception
        finally:
            await self._session_repository.update_unread_message_count(session_id, 0)


================================================
FILE: backend/app/domain/services/agent_task_runner.py
================================================
from typing import Optional, AsyncGenerator, List
import asyncio
import logging
from pydantic import TypeAdapter
from app.domain.models.message import Message
from app.domain.models.event import (
    BaseEvent,
    ErrorEvent,
    TitleEvent,
    MessageEvent,
    DoneEvent,
    ToolEvent,
    WaitEvent,
    FileToolContent,
    ShellToolContent,
    SearchToolContent,
    BrowserToolContent,
    ToolStatus,
    AgentEvent,
    McpToolContent,
    ToolStatus
)
from app.domain.services.flows.plan_act import PlanActFlow
from app.domain.external.sandbox import Sandbox
from app.domain.external.browser import Browser
from app.domain.external.search import SearchEngine
from app.domain.external.llm import LLM
from app.domain.external.file import FileStorage
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.external.task import TaskRunner, Task
from app.domain.repositories.session_repository import SessionRepository
from app.domain.repositories.mcp_repository import MCPRepository
from app.domain.models.session import SessionStatus
from app.domain.models.file import FileInfo
from app.domain.utils.json_parser import JsonParser
from app.domain.services.tools.mcp import MCPTool
from app.domain.models.tool_result import ToolResult
from app.domain.models.search import SearchResults

logger = logging.getLogger(__name__)

class AgentTaskRunner(TaskRunner):
    """Agent task that can be cancelled"""
    def __init__(
        self,
        session_id: str,
        agent_id: str,
        user_id: str,
        llm: LLM,
        sandbox: Sandbox,
        browser: Browser,
        agent_repository: AgentRepository,
        session_repository: SessionRepository,
        json_parser: JsonParser,
        file_storage: FileStorage,
        mcp_repository: MCPRepository,
        search_engine: Optional[SearchEngine] = None,
    ):
        self._session_id = session_id
        self._agent_id = agent_id
        self._user_id = user_id
        self._llm = llm
        self._sandbox = sandbox
        self._browser = browser
        self._search_engine = search_engine
        self._repository = agent_repository
        self._session_repository = session_repository
        self._json_parser = json_parser
        self._file_storage = file_storage
        self._mcp_repository = mcp_repository
        self._mcp_tool = MCPTool()
        self._flow = PlanActFlow(
            self._agent_id,
            self._repository,
            self._session_id,
            self._session_repository,
            self._llm,
            self._sandbox,
            self._browser,
            self._json_parser,
            self._mcp_tool,
            self._search_engine,
        )

    async def _put_and_add_event(self, task: Task, event: AgentEvent) -> None:
        event_id = await task.output_stream.put(event.model_dump_json())
        event.id = event_id
        await self._session_repository.add_event(self._session_id, event)
    
    async def _pop_event(self, task: Task) -> AgentEvent:
        event_id, event_str = await task.input_stream.pop()
        if event_str is None:
            logger.warning(f"Agent {self._agent_id} received empty message")
            return
        event = TypeAdapter(AgentEvent).validate_json(event_str)
        event.id = event_id
        return event
    
    async def _get_browser_screenshot(self) -> str:
        screenshot = await self._browser.screenshot()
        result = await self._file_storage.upload_file(screenshot, "screenshot.png", self._user_id)
        return result.file_id

    async def _sync_file_to_storage(self, file_path: str) -> Optional[FileInfo]:
        """Upload or update file and return FileInfo"""
        try:
            file_info = await self._session_repository.get_file_by_path(self._session_id, file_path)
            file_data = await self._sandbox.file_download(file_path)
            if file_info:
                await self._session_repository.remove_file(self._session_id, file_info.file_id)
            file_name = file_path.split("/")[-1]
            file_info = await self._file_storage.upload_file(file_data, file_name, self._user_id)
            file_info.file_path = file_path
            await self._session_repository.add_file(self._session_id, file_info)
            return file_info
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} failed to sync file: {e}")
    
    async def _sync_file_to_sandbox(self, file_id: str) -> Optional[FileInfo]:
        """Download file from storage to sandbox"""
        try:
            file_data, file_info = await self._file_storage.download_file(file_id, self._user_id)
            file_path = "/home/ubuntu/upload/" + file_info.filename
            result = await self._sandbox.file_upload(file_data, file_path)
            if result.success:
                file_info.file_path = file_path
                return file_info
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} failed to sync file: {e}")

    async def _sync_message_attachments_to_storage(self, event: MessageEvent) -> None:
        """Sync message attachments and update event attachments"""
        attachments: List[FileInfo] = []
        try:
            if event.attachments:
                for attachment in event.attachments:
                    file_info = await self._sync_file_to_storage(attachment.file_path)
                    if file_info:
                        attachments.append(file_info)
            event.attachments = attachments
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} failed to sync attachments to storage: {e}")
    
    async def _sync_message_attachments_to_sandbox(self, event: MessageEvent) -> None:
        """Sync message attachments and update event attachments"""
        attachments: List[FileInfo] = []
        try:
            if event.attachments:
                for attachment in event.attachments:
                    file_info = await self._sync_file_to_sandbox(attachment.file_id)
                    if file_info:
                        attachments.append(file_info)
                        await self._session_repository.add_file(self._session_id, file_info)
            event.attachments = attachments
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} failed to sync attachments to event: {e}")
    

    # TODO: refactor this function
    async def _handle_tool_event(self, event: ToolEvent):
        """Generate tool content"""
        try:
            if event.status == ToolStatus.CALLED:
                if event.tool_name == "browser":
                    event.tool_content = BrowserToolContent(screenshot=await self._get_browser_screenshot())
                elif event.tool_name == "search":
                    search_results: ToolResult[SearchResults] = event.function_result
                    logger.debug(f"Search tool results: {search_results}")
                    event.tool_content = SearchToolContent(results=search_results.data.results)
                elif event.tool_name == "shell":
                    if "id" in event.function_args:
                        shell_result = await self._sandbox.view_shell(event.function_args["id"], console=True)
                        event.tool_content = ShellToolContent(console=shell_result.data.get("console", []))
                    else:
                        event.tool_content = ShellToolContent(console="(No Console)")
                elif event.tool_name == "file":
                    if "file" in event.function_args:
                        file_path = event.function_args["file"]
                        file_read_result = await self._sandbox.file_read(file_path)
                        file_content: str = file_read_result.data.get("content", "")
                        event.tool_content = FileToolContent(content=file_content)
                        await self._sync_file_to_storage(file_path)
                    else:
                        event.tool_content = FileToolContent(content="(No Content)")
                elif event.tool_name == "mcp":
                    logger.debug(f"Processing MCP tool event: function_result={event.function_result}")
                    if event.function_result:
                        if hasattr(event.function_result, 'data') and event.function_result.data:
                            logger.debug(f"MCP tool result data: {event.function_result.data}")
                            event.tool_content = McpToolContent(result=event.function_result.data)
                        elif hasattr(event.function_result, 'success') and event.function_result.success:
                            logger.debug(f"MCP tool result (success, no data): {event.function_result}")
                            result_data = event.function_result.model_dump() if hasattr(event.function_result, 'model_dump') else str(event.function_result)
                            event.tool_content = McpToolContent(result=result_data)
                        else:
                            logger.debug(f"MCP tool result (fallback): {event.function_result}")
                            event.tool_content = McpToolContent(result=str(event.function_result))
                    else:
                        logger.warning("MCP tool: No function_result found")
                        event.tool_content = McpToolContent(result="No result available")
                    
                    logger.debug(f"MCP tool_content set to: {event.tool_content}")
                    if event.tool_content:
                        logger.debug(f"MCP tool_content.result: {event.tool_content.result}")
                        logger.debug(f"MCP tool_content dict: {event.tool_content.model_dump()}")
                else:
                    logger.warning(f"Agent {self._agent_id} received unknown tool event: {event.tool_name}")
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} failed to generate tool content: {e}")

    async def run(self, task: Task) -> None:
        """Process agent's message queue and run the agent's flow"""
        try:
            logger.info(f"Agent {self._agent_id} message processing task started")
            await self._sandbox.ensure_sandbox()
            await self._mcp_tool.initialized(await self._mcp_repository.get_mcp_config())
            while not await task.input_stream.is_empty():
                event = await self._pop_event(task)
                message = ""
                if isinstance(event, MessageEvent):
                    message = event.message or ""
                    await self._sync_message_attachments_to_sandbox(event)
                    
                logger.info(f"Agent {self._agent_id} received new message: {message[:50]}...")

                message_obj = Message(message=message, attachments=[attachment.file_path for attachment in event.attachments])
                
                async for event in self._run_flow(message_obj):
                    await self._put_and_add_event(task, event)
                    if isinstance(event, TitleEvent):
                        await self._session_repository.update_title(self._session_id, event.title)
                    elif isinstance(event, MessageEvent):
                        await self._session_repository.update_latest_message(self._session_id, event.message, event.timestamp)
                        await self._session_repository.increment_unread_message_count(self._session_id)
                    elif isinstance(event, WaitEvent):
                        await self._session_repository.update_status(self._session_id, SessionStatus.WAITING)
                        return
                    if not await task.input_stream.is_empty():
                        break

            await self._session_repository.update_status(self._session_id, SessionStatus.COMPLETED)
        except asyncio.CancelledError:
            logger.info(f"Agent {self._agent_id} task cancelled")
            await self._put_and_add_event(task, DoneEvent())
            await self._session_repository.update_status(self._session_id, SessionStatus.COMPLETED)
        except Exception as e:
            logger.exception(f"Agent {self._agent_id} task encountered exception: {str(e)}")
            await self._put_and_add_event(task, ErrorEvent(error=f"Task error: {str(e)}"))
            await self._session_repository.update_status(self._session_id, SessionStatus.COMPLETED)
    
    async def _run_flow(self, message: Message) -> AsyncGenerator[BaseEvent, None]:
        """Process a single message through the agent's flow and yield events"""
        if not message.message:
            logger.warning(f"Agent {self._agent_id} received empty message")
            yield ErrorEvent(error="No message")
            return

        async for event in self._flow.run(message):
            if isinstance(event, ToolEvent):
                # TODO: move to tool function
                await self._handle_tool_event(event)
            elif isinstance(event, MessageEvent):
                await self._sync_message_attachments_to_storage(event)
            yield event

        logger.info(f"Agent {self._agent_id} completed processing one message")

    
    async def on_done(self, task: Task) -> None:
        """Called when the task is done"""
        logger.info(f"Agent {self._agent_id} task done")


    async def destroy(self) -> None:
        """Destroy the task and release resources"""
        logger.info(f"Starting to destroy agent task")
        
        # Destroy sandbox environment
        if self._sandbox:
            logger.debug(f"Destroying Agent {self._agent_id}'s sandbox environment")
            await self._sandbox.destroy()
        
        if self._mcp_tool:
            logger.debug(f"Destroying Agent {self._agent_id}'s MCP tool")
            await self._mcp_tool.cleanup()
        
        logger.debug(f"Agent {self._agent_id} has been fully closed and resources cleared")



================================================
FILE: backend/app/domain/services/agents/__init__.py
================================================
from ...models.agent import Agent

__all__ = [
    'Agent'
]



================================================
FILE: backend/app/domain/services/agents/base.py
================================================
import json
import logging
import asyncio
import uuid
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, AsyncGenerator
from app.domain.external.llm import LLM
from app.domain.models.agent import Agent
from app.domain.models.memory import Memory
from app.domain.models.message import Message
from app.domain.services.tools.base import BaseTool
from app.domain.models.tool_result import ToolResult
from app.domain.models.event import (
    BaseEvent,
    ToolEvent,
    ToolStatus,
    ErrorEvent,
    MessageEvent,
    DoneEvent,
)
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.utils.json_parser import JsonParser

logger = logging.getLogger(__name__)
class BaseAgent(ABC):
    """
    Base agent class, defining the basic behavior of the agent
    """

    name: str = ""
    system_prompt: str = ""
    format: Optional[str] = None
    max_iterations: int = 100
    max_retries: int = 3
    retry_interval: float = 1.0
    tool_choice: Optional[str] = None

    def __init__(
        self,
        agent_id: str,
        agent_repository: AgentRepository,
        llm: LLM,
        json_parser: JsonParser,
        tools: List[BaseTool] = []
    ):
        self._agent_id = agent_id
        self._repository = agent_repository
        self.llm = llm
        self.json_parser = json_parser
        self.tools = tools
        self.memory = None
    
    def get_available_tools(self) -> Optional[List[Dict[str, Any]]]:
        """Get all available tools list"""
        available_tools = []
        for tool in self.tools:
            available_tools.extend(tool.get_tools())
        return available_tools
    
    def get_tool(self, function_name: str) -> BaseTool:
        """Get specified tool"""
        for tool in self.tools:
            if tool.has_function(function_name):
                return tool
        raise ValueError(f"Unknown tool: {function_name}")

    async def invoke_tool(self, tool: BaseTool, function_name: str, arguments: Dict[str, Any]) -> ToolResult:
        """Invoke specified tool, with retry mechanism"""

        retries = 0
        while retries <= self.max_retries:
            try:
                return await tool.invoke_function(function_name, **arguments)
            except Exception as e:
                last_error = str(e)
                retries += 1
                if retries <= self.max_retries:
                    await asyncio.sleep(self.retry_interval)
                else:
                    logger.exception(f"Tool execution failed, {function_name}, {arguments}")
                    break
        
        return ToolResult(success=False, message=last_error)
    
    async def execute(self, request: str, format: Optional[str] = None) -> AsyncGenerator[BaseEvent, None]:
        format = format or self.format
        message = await self.ask(request, format)
        for _ in range(self.max_iterations):
            if not message.get("tool_calls"):
                break
            tool_responses = []
            for tool_call in message["tool_calls"]:
                if not tool_call.get("function"):
                    continue
                
                function_name = tool_call["function"]["name"]
                tool_call_id = tool_call["id"] or str(uuid.uuid4())
                function_args = await self.json_parser.parse(tool_call["function"]["arguments"])
                
                tool = self.get_tool(function_name)

                # Generate event before tool call
                yield ToolEvent(
                    status=ToolStatus.CALLING,
                    tool_call_id=tool_call_id,
                    tool_name=tool.name,
                    function_name=function_name,
                    function_args=function_args
                )

                result = await self.invoke_tool(tool, function_name, function_args)
                
                # Generate event after tool call
                yield ToolEvent(
                    status=ToolStatus.CALLED,
                    tool_call_id=tool_call_id,
                    tool_name=tool.name,
                    function_name=function_name,
                    function_args=function_args,
                    function_result=result
                )

                tool_response = {
                    "role": "tool",
                    "function_name": function_name,
                    "tool_call_id": tool_call_id,
                    "content": result.model_dump_json()
                }
                tool_responses.append(tool_response)

            message = await self.ask_with_messages(tool_responses)
        else:
            yield ErrorEvent(error="Maximum iteration count reached, failed to complete the task")
        
        yield MessageEvent(message=message["content"])
    
    async def _ensure_memory(self):
        if not self.memory:
            self.memory = await self._repository.get_memory(self._agent_id, self.name)
    
    async def _add_to_memory(self, messages: List[Dict[str, Any]]) -> None:
        """Update memory and save to repository"""
        await self._ensure_memory()
        if self.memory.empty:
            self.memory.add_message({
                "role": "system", "content": self.system_prompt,
            })
        self.memory.add_messages(messages)
        await self._repository.save_memory(self._agent_id, self.name, self.memory)
    
    async def _roll_back_memory(self) -> None:
        await self._ensure_memory()
        self.memory.roll_back()
        await self._repository.save_memory(self._agent_id, self.name, self.memory)

    async def ask_with_messages(self, messages: List[Dict[str, Any]], format: Optional[str] = None) -> Dict[str, Any]:
        await self._add_to_memory(messages)

        response_format = None
        if format:
            response_format = {"type": format}
        
        for _ in range(self.max_retries):
            message = await self.llm.ask(self.memory.get_messages(), 
                                            tools=self.get_available_tools(), 
                                            response_format=response_format,
                                            tool_choice=self.tool_choice)

            filtered_message = {}
            if message.get("role") == "assistant":
                if not message.get("content") and not message.get("tool_calls"):
                    logger.warning(f"Assistant message has no content, retry")
                    await self._add_to_memory([
                        {"role": "assistant", "content": ""},
                        {"role": "user", "content": "no thinking, please continue"}
                    ])
                    continue
                filtered_message = {
                    "role": "assistant",
                    "content": message.get("content"),
                }
                if message.get("tool_calls"):
                    filtered_message["tool_calls"] = message.get("tool_calls")[:1]
            else:
                logger.warning(f"Unknown message role: {message.get('role')}")
                filtered_message = message
            
            await self._add_to_memory([filtered_message])
            return filtered_message
        raise Exception(f"Empty response from LLM after {self.max_retries} retries")

    async def ask(self, request: str, format: Optional[str] = None) -> Dict[str, Any]:
        return await self.ask_with_messages([
            {
                "role": "user", "content": request
            }
        ], format)
    
    async def roll_back(self, message: Message):
        await self._ensure_memory()
        last_message = self.memory.get_last_message()
        if (not last_message or 
            not last_message.get("tool_calls") or 
            len(last_message.get("tool_calls")) == 0):
            return
        tool_call = last_message.get("tool_calls")[0]
        function_name = tool_call.get("function", {}).get("name")
        tool_call_id = tool_call.get("id")
        if function_name == "message_ask_user":
            self.memory.add_message({
                "role": "tool",
                "tool_call_id": tool_call_id,
                "function_name": function_name,
                "content": message.model_dump_json()
            })
        else:
            self.memory.roll_back()
        await self._repository.save_memory(self._agent_id, self.name, self.memory)
    
    async def compact_memory(self) -> None:
        await self._ensure_memory()
        self.memory.compact()
        await self._repository.save_memory(self._agent_id, self.name, self.memory)



================================================
FILE: backend/app/domain/services/agents/execution.py
================================================
from typing import AsyncGenerator, Optional, List
from app.domain.models.plan import Plan, Step, ExecutionStatus
from app.domain.models.file import FileInfo
from app.domain.models.message import Message
from app.domain.services.agents.base import BaseAgent
from app.domain.external.llm import LLM
from app.domain.external.sandbox import Sandbox
from app.domain.external.browser import Browser
from app.domain.external.search import SearchEngine
from app.domain.external.file import FileStorage
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.services.prompts.system import SYSTEM_PROMPT
from app.domain.services.prompts.execution import EXECUTION_SYSTEM_PROMPT, EXECUTION_PROMPT, SUMMARIZE_PROMPT
from app.domain.models.event import (
    BaseEvent,
    StepEvent,
    StepStatus,
    ErrorEvent,
    MessageEvent,
    DoneEvent,
    ToolEvent,
    ToolStatus,
    WaitEvent,
)
from app.domain.services.tools.base import BaseTool
from app.domain.services.tools.shell import ShellTool
from app.domain.services.tools.browser import BrowserTool
from app.domain.services.tools.search import SearchTool
from app.domain.services.tools.file import FileTool
from app.domain.services.tools.message import MessageTool
from app.domain.utils.json_parser import JsonParser
import logging

logger = logging.getLogger(__name__)


class ExecutionAgent(BaseAgent):
    """
    Execution agent class, defining the basic behavior of execution
    """

    name: str = "execution"
    system_prompt: str = SYSTEM_PROMPT + EXECUTION_SYSTEM_PROMPT
    format: str = "json_object"

    def __init__(
        self,
        agent_id: str,
        agent_repository: AgentRepository,
        llm: LLM,
        tools: List[BaseTool],
        json_parser: JsonParser,
    ):
        super().__init__(
            agent_id=agent_id,
            agent_repository=agent_repository,
            llm=llm,
            json_parser=json_parser,
            tools=tools
        )
    
    async def execute_step(self, plan: Plan, step: Step, message: Message) -> AsyncGenerator[BaseEvent, None]:
        message = EXECUTION_PROMPT.format(
            step=step.description, 
            message=message.message,
            attachments="\n".join(message.attachments),
            language=plan.language
        )
        step.status = ExecutionStatus.RUNNING
        yield StepEvent(status=StepStatus.STARTED, step=step)
        async for event in self.execute(message):
            if isinstance(event, ErrorEvent):
                step.status = ExecutionStatus.FAILED
                step.error = event.error
                yield StepEvent(status=StepStatus.FAILED, step=step)
            elif isinstance(event, MessageEvent):
                step.status = ExecutionStatus.COMPLETED
                parsed_response = await self.json_parser.parse(event.message)
                new_step = Step.model_validate(parsed_response)
                step.success = new_step.success
                step.result = new_step.result
                step.attachments = new_step.attachments
                yield StepEvent(status=StepStatus.COMPLETED, step=step)
                if step.result:
                    yield MessageEvent(message=step.result)
                continue
            elif isinstance(event, ToolEvent):
                if event.function_name == "message_ask_user":
                    if event.status == ToolStatus.CALLING:
                        yield MessageEvent(message=event.function_args.get("text", ""))
                    elif event.status == ToolStatus.CALLED:
                        yield WaitEvent()
                        return
                    continue
            yield event
        step.status = ExecutionStatus.COMPLETED

    async def summarize(self) -> AsyncGenerator[BaseEvent, None]:
        message = SUMMARIZE_PROMPT
        async for event in self.execute(message):
            if isinstance(event, MessageEvent):
                logger.debug(f"Execution agent summary: {event.message}")
                parsed_response = await self.json_parser.parse(event.message)
                message = Message.model_validate(parsed_response)
                attachments = [FileInfo(file_path=file_path) for file_path in message.attachments]
                yield MessageEvent(message=message.message, attachments=attachments)
                continue
            yield event


================================================
FILE: backend/app/domain/services/agents/planner.py
================================================
from typing import Dict, Any, List, AsyncGenerator, Optional
import json
import logging
from app.domain.models.plan import Plan, Step
from app.domain.models.message import Message
from app.domain.services.agents.base import BaseAgent
from app.domain.models.memory import Memory
from app.domain.external.llm import LLM
from app.domain.services.prompts.system import SYSTEM_PROMPT
from app.domain.services.prompts.planner import (
    CREATE_PLAN_PROMPT, 
    UPDATE_PLAN_PROMPT,
    PLANNER_SYSTEM_PROMPT
)
from app.domain.models.event import (
    BaseEvent,
    PlanEvent,
    PlanStatus,
    ErrorEvent,
    MessageEvent,
    DoneEvent,
)
from app.domain.external.sandbox import Sandbox
from app.domain.services.tools.base import BaseTool
from app.domain.services.tools.file import FileTool
from app.domain.services.tools.shell import ShellTool
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.utils.json_parser import JsonParser

logger = logging.getLogger(__name__)

class PlannerAgent(BaseAgent):
    """
    Planner agent class, defining the basic behavior of planning
    """

    name: str = "planner"
    system_prompt: str = SYSTEM_PROMPT + PLANNER_SYSTEM_PROMPT
    format: Optional[str] = "json_object"
    tool_choice: Optional[str] = "none"

    def __init__(
        self,
        agent_id: str,
        agent_repository: AgentRepository,
        llm: LLM,
        tools: List[BaseTool],
        json_parser: JsonParser,
    ):
        super().__init__(
            agent_id=agent_id,
            agent_repository=agent_repository,
            llm=llm,
            json_parser=json_parser,
            tools=tools,
        )


    async def create_plan(self, message: Message) -> AsyncGenerator[BaseEvent, None]:
        message = CREATE_PLAN_PROMPT.format(
            message=message.message,
            attachments="\n".join(message.attachments)
        )
        async for event in self.execute(message):
            if isinstance(event, MessageEvent):
                logger.info(event.message)
                parsed_response = await self.json_parser.parse(event.message)
                plan = Plan.model_validate(parsed_response)
                yield PlanEvent(status=PlanStatus.CREATED, plan=plan)
            else:
                yield event

    async def update_plan(self, plan: Plan, step: Step) -> AsyncGenerator[BaseEvent, None]:
        message = UPDATE_PLAN_PROMPT.format(plan=plan.dump_json(), step=step.model_dump_json())
        async for event in self.execute(message):
            if isinstance(event, MessageEvent):
                logger.debug(f"Planner agent update plan: {event.message}")
                parsed_response = await self.json_parser.parse(event.message)
                updated_plan = Plan.model_validate(parsed_response)
                new_steps = [Step.model_validate(step) for step in updated_plan.steps]
                
                # Find the index of the first pending step
                first_pending_index = None
                for i, step in enumerate(plan.steps):
                    if not step.is_done():
                        first_pending_index = i
                        break
                
                # If there are pending steps, replace all pending steps
                if first_pending_index is not None:
                    # Keep completed steps
                    updated_steps = plan.steps[:first_pending_index]
                    # Add new steps
                    updated_steps.extend(new_steps)
                    # Update steps in plan
                    plan.steps = updated_steps
                
                yield PlanEvent(status=PlanStatus.UPDATED, plan=plan)
            else:
                yield event


================================================
FILE: backend/app/domain/services/flows/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/domain/services/flows/base.py
================================================
from app.domain.models.event import BaseEvent
from app.domain.models.agent import Agent
from typing import AsyncGenerator
from abc import ABC, abstractmethod
from app.domain.repositories.agent_repository import AgentRepository

class BaseFlow(ABC):

    @abstractmethod
    def run(self) -> AsyncGenerator[BaseEvent, None]:
        pass

    @abstractmethod
    def is_done(self) -> bool:
        pass



================================================
FILE: backend/app/domain/services/flows/plan_act.py
================================================
import logging
from app.domain.services.flows.base import BaseFlow
from app.domain.models.agent import Agent
from app.domain.models.message import Message
from typing import AsyncGenerator, Optional, List
from enum import Enum
from app.domain.models.event import (
    BaseEvent,
    PlanEvent,
    PlanStatus,
    MessageEvent,
    DoneEvent,
    TitleEvent,
)
from app.domain.models.plan import ExecutionStatus
from app.domain.services.agents.planner import PlannerAgent
from app.domain.services.agents.execution import ExecutionAgent
from app.domain.external.llm import LLM
from app.domain.external.sandbox import Sandbox
from app.domain.external.browser import Browser
from app.domain.external.search import SearchEngine
from app.domain.external.file import FileStorage
from app.domain.repositories.agent_repository import AgentRepository
from app.domain.utils.json_parser import JsonParser
from app.domain.repositories.session_repository import SessionRepository
from app.domain.models.session import SessionStatus
from app.domain.services.tools.mcp import MCPTool
from app.domain.services.tools.shell import ShellTool
from app.domain.services.tools.browser import BrowserTool
from app.domain.services.tools.file import FileTool
from app.domain.services.tools.message import MessageTool
from app.domain.services.tools.search import SearchTool

logger = logging.getLogger(__name__)

class AgentStatus(str, Enum):
    IDLE = "idle"
    PLANNING = "planning"
    EXECUTING = "executing"
    SUMMARIZING = "summarizing"
    COMPLETED = "completed"
    UPDATING = "updating"

class PlanActFlow(BaseFlow):
    def __init__(
        self,
        agent_id: str,
        agent_repository: AgentRepository,
        session_id: str,
        session_repository: SessionRepository,
        llm: LLM,
        sandbox: Sandbox,
        browser: Browser,
        json_parser: JsonParser,
        mcp_tool: MCPTool,
        search_engine: Optional[SearchEngine] = None,
    ):
        self._agent_id = agent_id
        self._repository = agent_repository
        self._session_id = session_id
        self._session_repository = session_repository
        self.status = AgentStatus.IDLE
        self.plan = None

        tools = [
            ShellTool(sandbox),
            BrowserTool(browser),
            FileTool(sandbox),
            MessageTool(),
            mcp_tool
        ]
        
        # Only add search tool when search_engine is not None
        if search_engine:
            tools.append(SearchTool(search_engine))

        # Create planner and execution agents
        self.planner = PlannerAgent(
            agent_id=self._agent_id,
            agent_repository=self._repository,
            llm=llm,
            tools=tools,
            json_parser=json_parser,
        )
        logger.debug(f"Created planner agent for Agent {self._agent_id}")
            
        self.executor = ExecutionAgent(
            agent_id=self._agent_id,
            agent_repository=self._repository,
            llm=llm,
            tools=tools,
            json_parser=json_parser,
        )
        logger.debug(f"Created execution agent for Agent {self._agent_id}")

    async def run(self, message: Message) -> AsyncGenerator[BaseEvent, None]:

        # TODO: move to task runner
        session = await self._session_repository.find_by_id(self._session_id)
        if not session:
            raise ValueError(f"Session {self._session_id} not found")
        
        if session.status != SessionStatus.PENDING:
            logger.debug(f"Session {self._session_id} is not in PENDING status, rolling back")
            await self.executor.roll_back(message)
            await self.planner.roll_back(message)
        
        if session.status == SessionStatus.RUNNING:
            logger.debug(f"Session {self._session_id} is in RUNNING status")
            self.status = AgentStatus.PLANNING

        if session.status == SessionStatus.WAITING:
            logger.debug(f"Session {self._session_id} is in WAITING status")
            self.status = AgentStatus.EXECUTING

        await self._session_repository.update_status(self._session_id, SessionStatus.RUNNING)  
        self.plan = session.get_last_plan()

        logger.info(f"Agent {self._agent_id} started processing message: {message.message[:50]}...")
        step = None
        while True:
            if self.status == AgentStatus.IDLE:
                logger.info(f"Agent {self._agent_id} state changed from {AgentStatus.IDLE} to {AgentStatus.PLANNING}")
                self.status = AgentStatus.PLANNING
            elif self.status == AgentStatus.PLANNING:
                # Create plan
                logger.info(f"Agent {self._agent_id} started creating plan")
                async for event in self.planner.create_plan(message):
                    if isinstance(event, PlanEvent) and event.status == PlanStatus.CREATED:
                        self.plan = event.plan
                        logger.info(f"Agent {self._agent_id} created plan successfully with {len(event.plan.steps)} steps")
                        yield TitleEvent(title=event.plan.title)
                        yield MessageEvent(role="assistant", message=event.plan.message)
                    yield event
                logger.info(f"Agent {self._agent_id} state changed from {AgentStatus.PLANNING} to {AgentStatus.EXECUTING}")
                self.status = AgentStatus.EXECUTING
                if len(event.plan.steps) == 0:
                    logger.info(f"Agent {self._agent_id} created plan successfully with no steps")
                    self.status = AgentStatus.COMPLETED
                    
            elif self.status == AgentStatus.EXECUTING:
                # Execute plan
                self.plan.status = ExecutionStatus.RUNNING
                step = self.plan.get_next_step()
                if not step:
                    logger.info(f"Agent {self._agent_id} has no more steps, state changed from {AgentStatus.EXECUTING} to {AgentStatus.COMPLETED}")
                    self.status = AgentStatus.SUMMARIZING
                    continue
                # Execute step
                logger.info(f"Agent {self._agent_id} started executing step {step.id}: {step.description[:50]}...")
                async for event in self.executor.execute_step(self.plan, step, message):
                    yield event
                logger.info(f"Agent {self._agent_id} completed step {step.id}, state changed from {AgentStatus.EXECUTING} to {AgentStatus.UPDATING}")
                await self.executor.compact_memory()
                logger.debug(f"Agent {self._agent_id} compacted memory")
                self.status = AgentStatus.UPDATING
            elif self.status == AgentStatus.UPDATING:
                # Update plan
                logger.info(f"Agent {self._agent_id} started updating plan")
                async for event in self.planner.update_plan(self.plan, step):
                    yield event
                logger.info(f"Agent {self._agent_id} plan update completed, state changed from {AgentStatus.UPDATING} to {AgentStatus.EXECUTING}")
                self.status = AgentStatus.EXECUTING
            elif self.status == AgentStatus.SUMMARIZING:
                # Conclusion
                logger.info(f"Agent {self._agent_id} started summarizing")
                async for event in self.executor.summarize():
                    yield event
                logger.info(f"Agent {self._agent_id} summarizing completed, state changed from {AgentStatus.SUMMARIZING} to {AgentStatus.COMPLETED}")
                self.status = AgentStatus.COMPLETED
            elif self.status == AgentStatus.COMPLETED:
                self.plan.status = ExecutionStatus.COMPLETED
                logger.info(f"Agent {self._agent_id} plan has been completed")
                yield PlanEvent(status=PlanStatus.COMPLETED, plan=self.plan)
                self.status = AgentStatus.IDLE
                break
        yield DoneEvent()
        
        logger.info(f"Agent {self._agent_id} message processing completed")
    
    def is_done(self) -> bool:
        return self.status == AgentStatus.IDLE


================================================
FILE: backend/app/domain/services/prompts/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/domain/services/prompts/execution.py
================================================
# Execution prompt

EXECUTION_SYSTEM_PROMPT = """
You are a task execution agent, and you need to complete the following steps:
1. Analyze Events: Understand user needs and current state, focusing on latest user messages and execution results
2. Select Tools: Choose next tool call based on current state, task planning, at least one tool call per iteration
3. Wait for Execution: Selected tool action will be executed by sandbox environment
4. Iterate: Choose only one tool call per iteration, patiently repeat above steps until task completion
5. Submit Results: Send the result to user, result must be detailed and specific
"""

EXECUTION_PROMPT = """
You are executing the task:
{step}

Note:
- **It you that to do the task, not the user**
- **You must use the language provided by user's message to execute the task**
- You must use message_notify_user tool to notify users within one sentence:
    - What tools you are going to use and what you are going to do with them
    - What you have done by tools
    - What you are going to do or have done within one sentence
- If you need to ask user for input or take control of the browser, you must use message_ask_user tool to ask user for input
- Don't tell how to do the task, determine by yourself.
- Deliver the final result to user not the todo list, advice or plan

Return format requirements:
- Must return JSON format that complies with the following TypeScript interface
- Must include all required fields as specified


TypeScript Interface Definition:
```typescript
interface Response {{
  /** Whether the task is executed successfully **/
  success: boolean;
  /** Array of file paths in sandbox for generated files to be delivered to user **/
  attachments: string[];

  /** Task result, empty if no result to deliver **/
  result: string;
}}
```

EXAMPLE JSON OUTPUT:
{{
    "success": true,
    "result": "We have finished the task",
    "attachments": [
        "/home/ubuntu/file1.md",
        "/home/ubuntu/file2.md"
    ],
}}

Input:
- message: the user's message, use this language for all text output
- attachments: the user's attachments
- task: the task to execute

Output:
- the step execution result in json format

User Message:
{message}

Attachments:
{attachments}

Working Language:
{language}

Task:
{step}
"""

SUMMARIZE_PROMPT = """
You are finished the task, and you need to deliver the final result to user.

Note:
- You should explain the final result to user in detail.
- Write a markdown content to deliver the final result to user if necessary.
- Use file tools to deliver the files generated above to user if necessary.
- Deliver the files generated above to user if necessary.

Return format requirements:
- Must return JSON format that complies with the following TypeScript interface
- Must include all required fields as specified

TypeScript Interface Definition:
```typescript
interface Response {
  /** Response to user's message and thinking about the task, as detailed as possible */
  message: string;
  /** Array of file paths in sandbox for generated files to be delivered to user */
  attachments: string[];
}
```

EXAMPLE JSON OUTPUT:
{{
    "message": "Summary message",
    "attachments": [
        "/home/ubuntu/file1.md",
        "/home/ubuntu/file2.md"
    ]
}}
"""


================================================
FILE: backend/app/domain/services/prompts/planner.py
================================================
# Planner prompt
PLANNER_SYSTEM_PROMPT = """
You are a task planner agent, and you need to create or update a plan for the task:
1. Analyze the user's message and understand the user's needs
2. Determine what tools you need to use to complete the task
3. Determine the working language based on the user's message
4. Generate the plan's goal and steps
"""

CREATE_PLAN_PROMPT = """
You are now creating a plan based on the user's message:
{message}

Note:
- **You must use the language provided by user's message to execute the task**
- Your plan must be simple and concise, don't add any unnecessary details.
- Your steps must be atomic and independent, and the next executor can execute them one by one use the tools.
- You need to determine whether a task can be broken down into multiple steps. If it can, return multiple steps; otherwise, return a single step.

Return format requirements:
- Must return JSON format that complies with the following TypeScript interface
- Must include all required fields as specified
- If the task is determined to be unfeasible, return an empty array for steps and empty string for goal

TypeScript Interface Definition:
```typescript
interface CreatePlanResponse {{
  /** Response to user's message and thinking about the task, as detailed as possible, use the user's language */
  message: string;
  /** The working language according to the user's message */
  language: string;
  /** Array of steps, each step contains id and description */
  steps: Array<{{
    /** Step identifier */
    id: string;
    /** Step description */
    description: string;
  }}>;
  /** Plan goal generated based on the context */
  goal: string;
  /** Plan title generated based on the context */
  title: string;
}}
```

EXAMPLE JSON OUTPUT:
{{
    "message": "User response message",
    "goal": "Goal description",
    "title": "Plan title",
    "language": "en",
    "steps": [
        {{
            "id": "1",
            "description": "Step 1 description"
        }}
    ]
}}

Input:
- message: the user's message
- attachments: the user's attachments

Output:
- the plan in json format


User message:
{message}

Attachments:
{attachments}
"""

UPDATE_PLAN_PROMPT = """
You are updating the plan, you need to update the plan based on the step execution result:
{step}

Note:
- You can delete, add or modify the plan steps, but don't change the plan goal
- Don't change the description if the change is small
- Only re-plan the following uncompleted steps, don't change the completed steps
- Output the step id start with the id of first uncompleted step, re-plan the following steps
- Delete the step if it is completed or not necessary
- Carefully read the step result to determine if it is successful, if not, change the following steps
- According to the step result, you need to update the plan steps accordingly

Return format requirements:
- Must return JSON format that complies with the following TypeScript interface
- Must include all required fields as specified

TypeScript Interface Definition:
```typescript
interface UpdatePlanResponse {{
  /** Array of updated uncompleted steps */
  steps: Array<{{
    /** Step identifier */
    id: string;
    /** Step description */
    description: string;
  }}>;
}}
```

EXAMPLE JSON OUTPUT:
{{
    "steps": [
        {{
            "id": "1",
            "description": "Step 1 description"
        }}
    ]
}}


Input:
- step: the current step
- plan: the plan to update

Output:
- the updated plan uncompleted steps in json format

Step:
{step}

Plan:
{plan}
"""


================================================
FILE: backend/app/domain/services/prompts/system.py
================================================
SYSTEM_PROMPT = """
You are Manus, an AI agent created by the Manus team.

<intro>
You excel at the following tasks:
1. Information gathering, fact-checking, and documentation
2. Data processing, analysis, and visualization
3. Writing multi-chapter articles and in-depth research reports、
4. Using programming to solve various problems beyond development
5. Various tasks that can be accomplished using computers and the internet
</intro>

<language_settings>
- Default working language: **English**
- Use the language specified by user in messages as the working language when explicitly provided
- All thinking and responses must be in the working language
- Natural language arguments in tool calls must be in the working language
- Avoid using pure lists and bullet points format in any language
</language_settings>

<system_capability>
- Access a Linux sandbox environment with internet connection
- Use shell, text editor, browser, and other software
- Write and run code in Python and various programming languages
- Independently install required software packages and dependencies via shell
- Access specialized external tools and professional services through MCP (Model Context Protocol) integration
- Suggest users to temporarily take control of the browser for sensitive operations when necessary
- Utilize various tools to complete user-assigned tasks step by step
</system_capability>

<file_rules>
- Use file tools for reading, writing, appending, and editing to avoid string escape issues in shell commands
- Actively save intermediate results and store different types of reference information in separate files
- When merging text files, must use append mode of file writing tool to concatenate content to target file
- Strictly follow requirements in <writing_rules>, and avoid using list formats in any files except todo.md
- Don't read files that are not a text file, code file or markdown file
</file_rules>

<search_rules>
- You must access multiple URLs from search results for comprehensive information or cross-validation.
- Information priority: authoritative data from web search > model's internal knowledge
- Prefer dedicated search tools over browser access to search engine result pages
- Snippets in search results are not valid sources; must access original pages via browser
- Access multiple URLs from search results for comprehensive information or cross-validation
- Conduct searches step by step: search multiple attributes of single entity separately, process multiple entities one by one
</search_rules>

<browser_rules>
- Must use browser tools to access and comprehend all URLs provided by users in messages
- Must use browser tools to access URLs from search tool results
- Actively explore valuable links for deeper information, either by clicking elements or accessing URLs directly
- Browser tools only return elements in visible viewport by default
- Visible elements are returned as `index[:]<tag>text</tag>`, where index is for interactive elements in subsequent browser actions
- Due to technical limitations, not all interactive elements may be identified; use coordinates to interact with unlisted elements
- Browser tools automatically attempt to extract page content, providing it in Markdown format if successful
- Extracted Markdown includes text beyond viewport but omits links and images; completeness not guaranteed
- If extracted Markdown is complete and sufficient for the task, no scrolling is needed; otherwise, must actively scroll to view the entire page
</browser_rules>

<shell_rules>
- Avoid commands requiring confirmation; actively use -y or -f flags for automatic confirmation
- Avoid commands with excessive output; save to files when necessary
- Chain multiple commands with && operator to minimize interruptions
- Use pipe operator to pass command outputs, simplifying operations
- Use non-interactive `bc` for simple calculations, Python for complex math; never calculate mentally
- Use `uptime` command when users explicitly request sandbox status check or wake-up
</shell_rules>

<coding_rules>
- Must save code to files before execution; direct code input to interpreter commands is forbidden
- Write Python code for complex mathematical calculations and analysis
- Use search tools to find solutions when encountering unfamiliar problems
</coding_rules>

<writing_rules>
- Write content in continuous paragraphs using varied sentence lengths for engaging prose; avoid list formatting
- Use prose and paragraphs by default; only employ lists when explicitly requested by users
- All writing must be highly detailed with a minimum length of several thousand words, unless user explicitly specifies length or format requirements
- When writing based on references, actively cite original text with sources and provide a reference list with URLs at the end
- For lengthy documents, first save each section as separate draft files, then append them sequentially to create the final document
- During final compilation, no content should be reduced or summarized; the final length must exceed the sum of all individual draft files
</writing_rules>

<sandbox_environment>
System Environment:
- Ubuntu 22.04 (linux/amd64), with internet access
- User: `ubuntu`, with sudo privileges
- Home directory: /home/ubuntu

Development Environment:
- Python 3.10.12 (commands: python3, pip3)
- Node.js 20.18.0 (commands: node, npm)
- Basic calculator (command: bc)
</sandbox_environment>

<important_notes>
- ** You must execute the task, not the user. **
- ** Don't deliver the todo list, advice or plan to user, deliver the final result to user **
</important_notes>
""" 


================================================
FILE: backend/app/domain/services/tools/__init__.py
================================================
from app.domain.services.tools.base import BaseTool
from app.domain.services.tools.browser import BrowserTool
from app.domain.services.tools.shell import ShellTool
from app.domain.services.tools.search import SearchTool
from app.domain.services.tools.message import MessageTool
from app.domain.services.tools.file import FileTool
from app.domain.services.tools.mcp import MCPTool

__all__ = [
    'BaseTool',
    'BrowserTool',
    'ShellTool',
    'SearchTool',
    'MessageTool',
    'FileTool',
    'MCPTool',
]



================================================
FILE: backend/app/domain/services/tools/base.py
================================================
from typing import Dict, Any, List, Callable
import inspect
from app.domain.models.tool_result import ToolResult

def tool(
    name: str, 
    description: str,
    parameters: Dict[str, Dict[str, Any]],
    required: List[str]
) -> Callable:
    """Tool registration decorator
    
    Args:
        name: Tool name
        description: Tool description
        parameters: Tool parameter definitions
        required: List of required parameters
        
    Returns:
        Decorator function
    """
    def decorator(func):
        # Create tool schema directly using provided parameters, without automatic extraction
        schema = {
            "type": "function",
            "function": {
                "name": name,
                "description": description,
                "parameters": {
                    "type": "object", 
                    "properties": parameters,
                    "required": required
                }
            }
        }
        
        # Store tool information
        func._function_name = name
        func._tool_description = description
        func._tool_schema = schema
        
        return func
    
    return decorator

class BaseTool:
    """Base tool class, providing common tool calling methods"""

    name: str = ""
    
    def __init__(self):
        """Initialize base tool class"""
        self._tools_cache = None
    
    def get_tools(self) -> List[Dict[str, Any]]:
        """Get all registered tools
        
        Returns:
            List of tools
        """
        if self._tools_cache is not None:
            return self._tools_cache
        
        tools = []
        for _, method in inspect.getmembers(self, inspect.ismethod):
            if hasattr(method, '_tool_schema'):
                tools.append(method._tool_schema)
        
        self._tools_cache = tools
        return tools
    
    def has_function(self, function_name: str) -> bool:
        """Check if specified function exists
        
        Args:
            function_name: Function name
            
        Returns:
            Whether the tool exists
        """
        for _, method in inspect.getmembers(self, inspect.ismethod):
            if hasattr(method, '_function_name') and method._function_name == function_name:
                return True
        return False
    
    def _filter_parameters(self, method: Callable, kwargs: Dict[str, Any]) -> Dict[str, Any]:
        """Filter parameters to match method signature
        
        Args:
            method: Target method
            kwargs: Input parameters
            
        Returns:
            Filtered parameters that match the method signature
        """
        # Get method signature
        sig = inspect.signature(method)
        
        # Filter kwargs to only include parameters that the method accepts
        filtered_kwargs = {}
        for param_name, param_value in kwargs.items():
            if param_name in sig.parameters:
                filtered_kwargs[param_name] = param_value
        
        return filtered_kwargs
    
    async def invoke_function(self, function_name: str, **kwargs) -> ToolResult:
        """Invoke specified tool
        
        Args:
            function_name: Function name
            **kwargs: Parameters
            
        Returns:
            Invocation result
            
        Raises:
            ValueError: Raised when tool doesn't exist
        """
        for _, method in inspect.getmembers(self, inspect.ismethod):
            if hasattr(method, '_function_name') and method._function_name == function_name:
                # Filter parameters to match method signature
                filtered_kwargs = self._filter_parameters(method, kwargs)
                return await method(**filtered_kwargs)
        
        raise ValueError(f"Tool '{function_name}' not found") 


================================================
FILE: backend/app/domain/services/tools/browser.py
================================================
from typing import Optional
from app.domain.external.browser import Browser
from app.domain.services.tools.base import tool, BaseTool
from app.domain.models.tool_result import ToolResult

class BrowserTool(BaseTool):
    """Browser tool class, providing browser interaction functions"""

    name: str = "browser"
    
    def __init__(self, browser: Browser):
        """Initialize browser tool class
        
        Args:
            browser: Browser service
        """
        super().__init__()
        self.browser = browser
    
    @tool(
        name="browser_view",
        description="View content of the current browser page. Use for checking the latest state of previously opened pages.",
        parameters={},
        required=[]
    )
    async def browser_view(self) -> ToolResult:
        """View current browser page content
        
        Returns:
            Browser page content
        """
        return await self.browser.view_page()
    
    @tool(
        name="browser_navigate",
        description="Navigate browser to specified URL. Use when accessing new pages is needed.",
        parameters={
            "url": {
                "type": "string",
                "description": "Complete URL to visit. Must include protocol prefix."
            }
        },
        required=["url"]
    )
    async def browser_navigate(self, url: str) -> ToolResult:
        """Navigate browser to specified URL
        
        Args:
            url: Complete URL address, must include protocol prefix
            
        Returns:
            Navigation result
        """
        return await self.browser.navigate(url)
    
    @tool(
        name="browser_restart",
        description="Restart browser and navigate to specified URL. Use when browser state needs to be reset.",
        parameters={
            "url": {
                "type": "string",
                "description": "Complete URL to visit after restart. Must include protocol prefix."
            }
        },
        required=["url"]
    )
    async def browser_restart(self, url: str) -> ToolResult:
        """Restart browser and navigate to specified URL
        
        Args:
            url: Complete URL address to visit after restart, must include protocol prefix
            
        Returns:
            Restart result
        """
        return await self.browser.restart(url)
    
    @tool(
        name="browser_click",
        description="Click on elements in the current browser page. Use when clicking page elements is needed.",
        parameters={
            "index": {
                "type": "integer",
                "description": "(Optional) Index number of the element to click"
            },
            "coordinate_x": {
                "type": "number",
                "description": "(Optional) X coordinate of click position"
            },
            "coordinate_y": {
                "type": "number",
                "description": "(Optional) Y coordinate of click position"
            }
        },
        required=[]
    )
    async def browser_click(
        self,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Click on elements in the current browser page
        
        Args:
            index: (Optional) Index number of the element to click
            coordinate_x: (Optional) X coordinate of click position
            coordinate_y: (Optional) Y coordinate of click position
            
        Returns:
            Click result
        """
        return await self.browser.click(index, coordinate_x, coordinate_y)
    
    @tool(
        name="browser_input",
        description="Overwrite text in editable elements on the current browser page. Use when filling content in input fields.",
        parameters={
            "index": {
                "type": "integer",
                "description": "(Optional) Index number of the element to overwrite text"
            },
            "coordinate_x": {
                "type": "number",
                "description": "(Optional) X coordinate of the element to overwrite text"
            },
            "coordinate_y": {
                "type": "number",
                "description": "(Optional) Y coordinate of the element to overwrite text"
            },
            "text": {
                "type": "string",
                "description": "Complete text content to overwrite"
            },
            "press_enter": {
                "type": "boolean",
                "description": "Whether to press Enter key after input"
            }
        },
        required=["text", "press_enter"]
    )
    async def browser_input(
        self,
        text: str,
        press_enter: bool,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Overwrite text in editable elements on the current browser page
        
        Args:
            text: Complete text content to overwrite
            press_enter: Whether to press Enter key after input
            index: (Optional) Index number of the element to overwrite text
            coordinate_x: (Optional) X coordinate of the element to overwrite text
            coordinate_y: (Optional) Y coordinate of the element to overwrite text
            
        Returns:
            Input result
        """
        return await self.browser.input(text, press_enter, index, coordinate_x, coordinate_y)
    
    @tool(
        name="browser_move_mouse",
        description="Move cursor to specified position on the current browser page. Use when simulating user mouse movement.",
        parameters={
            "coordinate_x": {
                "type": "number",
                "description": "X coordinate of target cursor position"
            },
            "coordinate_y": {
                "type": "number",
                "description": "Y coordinate of target cursor position"
            }
        },
        required=["coordinate_x", "coordinate_y"]
    )
    async def browser_move_mouse(
        self,
        coordinate_x: float,
        coordinate_y: float
    ) -> ToolResult:
        """Move mouse cursor to specified position on the current browser page
        
        Args:
            coordinate_x: X coordinate of target cursor position
            coordinate_y: Y coordinate of target cursor position
            
        Returns:
            Move result
        """
        return await self.browser.move_mouse(coordinate_x, coordinate_y)
    
    @tool(
        name="browser_press_key",
        description="Simulate key press in the current browser page. Use when specific keyboard operations are needed.",
        parameters={
            "key": {
                "type": "string",
                "description": "Key name to simulate (e.g., Enter, Tab, ArrowUp), supports key combinations (e.g., Control+Enter)."
            }
        },
        required=["key"]
    )
    async def browser_press_key(
        self,
        key: str
    ) -> ToolResult:
        """Simulate key press in the current browser page
        
        Args:
            key: Key name to simulate (e.g., Enter, Tab, ArrowUp), supports key combinations (e.g., Control+Enter)
            
        Returns:
            Key press result
        """
        return await self.browser.press_key(key)
    
    @tool(
        name="browser_select_option",
        description="Select specified option from dropdown list element in the current browser page. Use when selecting dropdown menu options.",
        parameters={
            "index": {
                "type": "integer",
                "description": "Index number of the dropdown list element"
            },
            "option": {
                "type": "integer",
                "description": "Option number to select, starting from 0."
            }
        },
        required=["index", "option"]
    )
    async def browser_select_option(
        self,
        index: int,
        option: int
    ) -> ToolResult:
        """Select specified option from dropdown list element in the current browser page
        
        Args:
            index: Index number of the dropdown list element
            option: Option number to select, starting from 0
            
        Returns:
            Selection result
        """
        return await self.browser.select_option(index, option)
    
    @tool(
        name="browser_scroll_up",
        description="Scroll up the current browser page. Use when viewing content above or returning to page top.",
        parameters={
            "to_top": {
                "type": "boolean",
                "description": "(Optional) Whether to scroll directly to page top instead of one viewport up."
            }
        },
        required=[]
    )
    async def browser_scroll_up(
        self,
        to_top: Optional[bool] = None
    ) -> ToolResult:
        """Scroll up the current browser page
        
        Args:
            to_top: (Optional) Whether to scroll directly to page top instead of one viewport up
            
        Returns:
            Scroll result
        """
        return await self.browser.scroll_up(to_top)
    
    @tool(
        name="browser_scroll_down",
        description="Scroll down the current browser page. Use when viewing content below or jumping to page bottom.",
        parameters={
            "to_bottom": {
                "type": "boolean",
                "description": "(Optional) Whether to scroll directly to page bottom instead of one viewport down."
            }
        },
        required=[]
    )
    async def browser_scroll_down(
        self,
        to_bottom: Optional[bool] = None
    ) -> ToolResult:
        """Scroll down the current browser page
        
        Args:
            to_bottom: (Optional) Whether to scroll directly to page bottom instead of one viewport down
            
        Returns:
            Scroll result
        """
        return await self.browser.scroll_down(to_bottom)
    
    @tool(
        name="browser_console_exec",
        description="Execute JavaScript code in browser console. Use when custom scripts need to be executed.",
        parameters={
            "javascript": {
                "type": "string",
                "description": "JavaScript code to execute. Note that the runtime environment is browser console."
            }
        },
        required=["javascript"]
    )
    async def browser_console_exec(
        self,
        javascript: str
    ) -> ToolResult:
        """Execute JavaScript code in browser console
        
        Args:
            javascript: JavaScript code to execute, note that the runtime environment is browser console
            
        Returns:
            Execution result
        """
        return await self.browser.console_exec(javascript)
    
    @tool(
        name="browser_console_view",
        description="View browser console output. Use when checking JavaScript logs or debugging page errors.",
        parameters={
            "max_lines": {
                "type": "integer",
                "description": "(Optional) Maximum number of log lines to return."
            }
        },
        required=[]
    )
    async def browser_console_view(
        self,
        max_lines: Optional[int] = None
    ) -> ToolResult:
        """View browser console output
        
        Args:
            max_lines: (Optional) Maximum number of log lines to return
            
        Returns:
            Console output
        """
        return await self.browser.console_view(max_lines) 


================================================
FILE: backend/app/domain/services/tools/file.py
================================================
from typing import Optional, Dict, Any
from app.domain.external.sandbox import Sandbox
from app.domain.services.tools.base import tool, BaseTool
from app.domain.models.tool_result import ToolResult

class FileTool(BaseTool):
    """File tool class, providing file operation functions"""

    name: str = "file"
    
    def __init__(self, sandbox: Sandbox):
        """Initialize file tool class
        
        Args:
            sandbox: Sandbox service
        """
        super().__init__()
        self.sandbox = sandbox
        
    @tool(
        name="file_read",
        description="Read file content. Use for checking file contents, analyzing logs, or reading configuration files.",
        parameters={
            "file": {
                "type": "string",
                "description": "Absolute path of the file to read"
            },
            "start_line": {
                "type": "integer",
                "description": "(Optional) Starting line to read from, 0-based"
            },
            "end_line": {
                "type": "integer",
                "description": "(Optional) Ending line number (exclusive)"
            },
            "sudo": {
                "type": "boolean",
                "description": "(Optional) Whether to use sudo privileges"
            }
        },
        required=["file"]
    )
    async def file_read(
        self,
        file: str,
        start_line: Optional[int] = None,
        end_line: Optional[int] = None,
        sudo: Optional[bool] = False
    ) -> ToolResult:
        """Read file content
        
        Args:
            file: Absolute path of the file to read
            start_line: (Optional) Starting line, 0-based
            end_line: (Optional) Ending line (exclusive)
            sudo: (Optional) Whether to use sudo privileges
            
        Returns:
            File content
        """
        # Directly call sandbox's file_read method
        return await self.sandbox.file_read(
            file=file,
            start_line=start_line,
            end_line=end_line,
            sudo=sudo
        )
    
    @tool(
        name="file_write",
        description="Overwrite or append content to a file. Use for creating new files, appending content, or modifying existing files.",
        parameters={
            "file": {
                "type": "string",
                "description": "Absolute path of the file to write to"
            },
            "content": {
                "type": "string",
                "description": "Text content to write"
            },
            "append": {
                "type": "boolean",
                "description": "(Optional) Whether to use append mode"
            },
            "leading_newline": {
                "type": "boolean",
                "description": "(Optional) Whether to add a leading newline"
            },
            "trailing_newline": {
                "type": "boolean",
                "description": "(Optional) Whether to add a trailing newline"
            },
            "sudo": {
                "type": "boolean",
                "description": "(Optional) Whether to use sudo privileges"
            }
        },
        required=["file", "content"]
    )
    async def file_write(
        self,
        file: str,
        content: str,
        append: Optional[bool] = False,
        leading_newline: Optional[bool] = False,
        trailing_newline: Optional[bool] = False,
        sudo: Optional[bool] = False
    ) -> ToolResult:
        """Write content to file
        
        Args:
            file: Absolute path of the file to write to
            content: Text content to write
            append: (Optional) Whether to use append mode
            leading_newline: (Optional) Whether to add a leading newline
            trailing_newline: (Optional) Whether to add a trailing newline
            sudo: (Optional) Whether to use sudo privileges
            
        Returns:
            Write result
        """
        # Prepare content
        final_content = content
        if leading_newline:
            final_content = "\n" + final_content
        if trailing_newline:
            final_content = final_content + "\n"
            
        # Directly call sandbox's file_write method, pass all parameters
        return await self.sandbox.file_write(
            file=file, 
            content=final_content,
            append=append,
            leading_newline=False,  # Already handled in final_content
            trailing_newline=False,  # Already handled in final_content
            sudo=sudo
        )
    
    @tool(
        name="file_str_replace",
        description="Replace specified string in a file. Use for updating specific content in files or fixing errors in code.",
        parameters={
            "file": {
                "type": "string",
                "description": "Absolute path of the file to perform replacement on"
            },
            "old_str": {
                "type": "string",
                "description": "Original string to be replaced"
            },
            "new_str": {
                "type": "string",
                "description": "New string to replace with"
            },
            "sudo": {
                "type": "boolean",
                "description": "(Optional) Whether to use sudo privileges"
            }
        },
        required=["file", "old_str", "new_str"]
    )
    async def file_str_replace(
        self,
        file: str,
        old_str: str,
        new_str: str,
        sudo: Optional[bool] = False
    ) -> ToolResult:
        """Replace specified string in file
        
        Args:
            file: Absolute path of the file to perform replacement on
            old_str: Original string to be replaced
            new_str: New string to replace with
            sudo: (Optional) Whether to use sudo privileges
            
        Returns:
            Replacement result
        """
        # Directly call sandbox's file_replace method
        return await self.sandbox.file_replace(
            file=file,
            old_str=old_str,
            new_str=new_str,
            sudo=sudo
        )
    
    @tool(
        name="file_find_in_content",
        description="Search for matching text within file content. Use for finding specific content or patterns in files.",
        parameters={
            "file": {
                "type": "string",
                "description": "Absolute path of the file to search within"
            },
            "regex": {
                "type": "string",
                "description": "Regular expression pattern to match"
            },
            "sudo": {
                "type": "boolean",
                "description": "(Optional) Whether to use sudo privileges"
            }
        },
        required=["file", "regex"]
    )
    async def file_find_in_content(
        self,
        file: str,
        regex: str,
        sudo: Optional[bool] = False
    ) -> ToolResult:
        """Search for matching text in file content
        
        Args:
            file: Absolute path of the file to search
            regex: Regular expression pattern for matching
            sudo: (Optional) Whether to use sudo privileges
            
        Returns:
            Search results
        """
        # Directly call sandbox's file_search method
        return await self.sandbox.file_search(
            file=file,
            regex=regex,
            sudo=sudo
        )
    
    @tool(
        name="file_find_by_name",
        description="Find files by name pattern in specified directory. Use for locating files with specific naming patterns.",
        parameters={
            "path": {
                "type": "string",
                "description": "Absolute path of directory to search"
            },
            "glob": {
                "type": "string",
                "description": "Filename pattern using glob syntax wildcards"
            }
        },
        required=["path", "glob"]
    )
    async def file_find_by_name(
        self,
        path: str,
        glob: str
    ) -> ToolResult:
        """Find files by name pattern in specified directory
        
        Args:
            path: Absolute path of directory to search
            glob: Filename pattern using glob syntax wildcards
            
        Returns:
            Search results
        """
        # Directly call sandbox's file_find method
        return await self.sandbox.file_find(
            path=path,
            glob_pattern=glob
        ) 


================================================
FILE: backend/app/domain/services/tools/mcp.py
================================================
import os
import logging
from typing import Dict, Any, List, Optional
from contextlib import AsyncExitStack

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from mcp.client.sse import sse_client
from mcp.client.streamable_http import streamablehttp_client
from mcp.types import Tool as MCPTool

from app.domain.services.tools.base import BaseTool, tool
from app.domain.models.tool_result import ToolResult
from app.domain.models.mcp_config import MCPConfig, MCPServerConfig

logger = logging.getLogger(__name__)


class MCPClientManager:
    """MCP 客户端管理器"""
    
    def __init__(self, config: Optional[MCPConfig] = None):
        self._clients: Dict[str, ClientSession] = {}
        self._exit_stack = AsyncExitStack()
        self._tools_cache: Dict[str, List[MCPTool]] = {}
        self._initialized = False
        self._config = config
    
    async def initialize(self):
        """初始化 MCP 客户端管理器"""
        if self._initialized:
            return
        
        try:
            logger.info(f"从配置加载了 {len(self._config.mcpServers)} 个 MCP 服务器配置")
            
            # 连接到所有启用的服务器
            await self._connect_servers()
            
            self._initialized = True
            logger.info("MCP 客户端管理器初始化成功")
            
        except Exception as e:
            logger.error(f"MCP 客户端管理器初始化失败: {e}")
            raise

    
    async def _connect_servers(self):
        """连接到所有启用的 MCP 服务器"""
        for server_name, server_config in self._config.mcpServers.items():
            if not server_config.enabled:
                continue
                
            try:
                await self._connect_server(server_name, server_config)
            except Exception as e:
                logger.error(f"连接到 MCP 服务器 {server_name} 失败: {e}")
                # 继续连接其他服务器
                continue
    
    async def _connect_server(self, server_name: str, server_config: MCPServerConfig):
        """连接到单个 MCP 服务器"""
        try:
            transport_type = server_config.transport
            
            if transport_type == 'stdio':
                await self._connect_stdio_server(server_name, server_config)
            elif transport_type == 'http' or transport_type == 'sse':
                await self._connect_http_server(server_name, server_config)
            elif transport_type == 'streamable-http':
                await self._connect_streamable_http_server(server_name, server_config)
            else:
                logger.error(f"不支持的传输类型: {transport_type}")
                
        except Exception as e:
            logger.error(f"连接 MCP 服务器 {server_name} 失败: {e}")
            raise
    
    async def _connect_stdio_server(self, server_name: str, server_config: MCPServerConfig):
        """连接到 stdio MCP 服务器"""
        command = server_config.command
        args = server_config.args or []
        env = server_config.env or {}
        
        if not command:
            raise ValueError(f"服务器 {server_name} 缺少 command 配置")
        

        # 创建服务器参数（路径处理已在配置提供者中完成）
        server_params = StdioServerParameters(
            command=command,
            args=args,
            env={**os.environ, **env}
        )
        
        try:
            # 建立连接
            stdio_transport = await self._exit_stack.enter_async_context(
                stdio_client(server_params)
            )
            read_stream, write_stream = stdio_transport
            
            # 创建会话
            session = await self._exit_stack.enter_async_context(
                ClientSession(read_stream, write_stream)
            )
            
            # 初始化会话
            await session.initialize()
            
            # 缓存客户端
            self._clients[server_name] = session
            
            # 获取并缓存工具列表
            await self._cache_server_tools(server_name, session)
            
            logger.info(f"成功连接到 stdio MCP 服务器: {server_name}")
            
        except Exception as e:
            logger.error(f"连接到 stdio MCP 服务器 {server_name} 失败: {e}")
            raise
    
    async def _connect_http_server(self, server_name: str, server_config: MCPServerConfig):
        """连接到 HTTP MCP 服务器"""
        url = server_config.url
        if not url:
            raise ValueError(f"服务器 {server_name} 缺少 url 配置")
        
        try:
            # 建立 SSE 连接
            sse_transport = await self._exit_stack.enter_async_context(
                sse_client(url)
            )
            read_stream, write_stream = sse_transport
            
            # 创建会话
            session = await self._exit_stack.enter_async_context(
                ClientSession(read_stream, write_stream)
            )
            
            # 初始化会话
            await session.initialize()
            
            # 缓存客户端
            self._clients[server_name] = session
            
            # 获取并缓存工具列表
            await self._cache_server_tools(server_name, session)
            
            logger.info(f"成功连接到 HTTP MCP 服务器: {server_name}")
            
        except Exception as e:
            logger.error(f"连接到 HTTP MCP 服务器 {server_name} 失败: {e}")
            raise
    
    async def _connect_streamable_http_server(self, server_name: str, server_config: MCPServerConfig):
        """连接到 streamable-http MCP 服务器
        
        配置选项：
        - url: 服务器 URL (必需)
        - headers: 自定义 HTTP 头 (可选)
        """
        url = server_config.url
        if not url:
            raise ValueError(f"服务器 {server_name} 缺少 url 配置")
        
        # 获取可选配置
        headers = server_config.headers or {}
        
        try:
            # 准备连接参数
            client_params = {"url": url}
            
            # 添加自定义 headers
            if headers:
                client_params["headers"] = headers
            
            # 建立 streamable-http 连接
            streamable_transport = await self._exit_stack.enter_async_context(
                streamablehttp_client(**client_params)
            )
            
            # 解包返回的流和可选的第三个参数
            if len(streamable_transport) == 3:
                read_stream, write_stream, _ = streamable_transport
            else:
                read_stream, write_stream = streamable_transport
            
            # 创建 MCP 会话
            session = await self._exit_stack.enter_async_context(
                ClientSession(read_stream, write_stream)
            )
            
            # 初始化会话
            await session.initialize()
            
            # 缓存客户端
            self._clients[server_name] = session
            
            # 获取并缓存工具列表
            await self._cache_server_tools(server_name, session)
            
            logger.info(f"成功连接到 streamable-http MCP 服务器: {server_name} ({url})")
            
        except Exception as e:
            logger.error(f"连接到 streamable-http MCP 服务器 {server_name} 失败: {e}")
            raise
    
    async def _cache_server_tools(self, server_name: str, session: ClientSession):
        """缓存服务器工具列表"""
        try:
            tools_response = await session.list_tools()
            tools = tools_response.tools if tools_response else []
            self._tools_cache[server_name] = tools
            logger.info(f"服务器 {server_name} 提供 {len(tools)} 个工具")
            
        except Exception as e:
            logger.error(f"获取服务器 {server_name} 工具列表失败: {e}")
            self._tools_cache[server_name] = []
    
    async def get_all_tools(self) -> List[Dict[str, Any]]:
        """获取所有 MCP 工具"""
        all_tools = []
        
        for server_name, tools in self._tools_cache.items():
            for tool in tools:
                # 生成工具名称，避免重复的 mcp_ 前缀
                if server_name.startswith('mcp_'):
                    tool_name = f"{server_name}_{tool.name}"
                else:
                    tool_name = f"mcp_{server_name}_{tool.name}"
                
                # 转换为标准工具格式
                tool_schema = {
                    "type": "function",
                    "function": {
                        "name": tool_name,
                        "description": f"[{server_name}] {tool.description or tool.name}",
                        "parameters": tool.inputSchema
                    }
                }
                all_tools.append(tool_schema)
        
        return all_tools
    
    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> ToolResult:
        """调用 MCP 工具"""
        try:
            # 解析工具名称
            server_name = None
            original_tool_name = None
            
            # 查找匹配的服务器名称
            for srv_name in self._config.mcpServers.keys():
                expected_prefix = srv_name if srv_name.startswith('mcp_') else f"mcp_{srv_name}"
                if tool_name.startswith(f"{expected_prefix}_"):
                    server_name = srv_name
                    original_tool_name = tool_name[len(expected_prefix) + 1:]
                    break
            
            if not server_name or not original_tool_name:
                raise ValueError(f"无法解析 MCP 工具名称: {tool_name}")
            
            # 获取客户端会话
            session = self._clients.get(server_name)
            if not session:
                return ToolResult(
                    success=False,
                    message=f"MCP 服务器 {server_name} 未连接"
                )
            
            # 调用工具
            result = await session.call_tool(original_tool_name, arguments)
            
            # 处理结果
            if result:
                content = []
                if hasattr(result, 'content') and result.content:
                    for item in result.content:
                        if hasattr(item, 'text'):
                            content.append(item.text)
                        else:
                            content.append(str(item))
                
                return ToolResult(
                    success=True,
                    data='\n'.join(content) if content else "工具执行成功"
                )
            else:
                return ToolResult(
                    success=True,
                    data="工具执行成功"
                )
                
        except Exception as e:
            logger.error(f"调用 MCP 工具 {tool_name} 失败: {e}")
            return ToolResult(
                success=False,
                message=f"调用 MCP 工具失败: {str(e)}"
            )

    async def cleanup(self):
        """清理资源"""
        try:
            await self._exit_stack.aclose()
            self._clients.clear()
            self._tools_cache.clear()
            self._initialized = False
            logger.info("MCP 客户端管理器已清理")
            
        except Exception as e:
            logger.error(f"清理 MCP 客户端管理器失败: {e}")


class MCPTool(BaseTool):
    """MCP 工具类"""
    
    name = "mcp"
    
    def __init__(self):
        super().__init__()
        self._initialized = False
        self._tools = []
    
    async def initialized(self, config: Optional[MCPConfig] = None):
        """确保管理器已初始化"""
        if not self._initialized:
            self.manager = MCPClientManager(config)
            await self.manager.initialize()
            self._tools = await self.manager.get_all_tools()
            self._initialized = True

    def get_tools(self) -> List[Dict[str, Any]]:
        """获取同步工具定义（基础工具）"""
        return self._tools

    def has_function(self, function_name: str) -> bool:
        """检查指定函数是否存在（包括动态 MCP 工具）"""
        # 检查是否是 MCP 工具
        for tool in self._tools:
            if tool['function']['name'] == function_name:
                return True
        return False
    
    async def invoke_function(self, function_name: str, **kwargs) -> ToolResult:
        """调用工具函数"""
        return await self.manager.call_tool(function_name, kwargs)
    
    async def cleanup(self):
        """清理资源"""
        if self.manager:
            await self.manager.cleanup() 



================================================
FILE: backend/app/domain/services/tools/message.py
================================================
from typing import List, Optional, Union
from app.domain.services.tools.base import tool, BaseTool
from app.domain.models.tool_result import ToolResult

class MessageTool(BaseTool):
    """Message tool class, providing message sending functions for user interaction"""

    name: str = "message"
    
    def __init__(self):
        """Initialize message tool class"""
        super().__init__()
        
    @tool(
        name="message_notify_user",
        description="Send a message to user without requiring a response. Use for acknowledging receipt of messages, providing progress updates, reporting task completion, or explaining changes in approach.",
        parameters={
            "text": {
                "type": "string",
                "description": "Message text to display to user"
            }
        },
        required=["text"]
    )
    async def message_notify_user(
        self,
        text: str
    ) -> ToolResult:
        """Send notification message to user, no response needed
        
        Args:
            text: Message text to display to user
            
        Returns:
            Message sending result
        """
            
        # Return success result, actual UI display logic implemented by caller
        return ToolResult(success=True, data="Continue")
    
    @tool(
        name="message_ask_user",
        description="Ask user a question and wait for response. Use for requesting clarification, asking for confirmation, or gathering additional information.",
        parameters={
            "text": {
                "type": "string",
                "description": "Question text to present to user"
            },
            "attachments": {
                "anyOf": [
                    {"type": "string"},
                    {"items": {"type": "string"}, "type": "array"}
                ],
                "description": "(Optional) List of question-related files or reference materials"
            },
            "suggest_user_takeover": {
                "type": "string",
                "enum": ["none", "browser"],
                "description": "(Optional) Suggested operation for user takeover"
            }
        },
        required=["text"]
    )
    async def message_ask_user(
        self,
        text: str,
        attachments: Optional[Union[str, List[str]]] = None,
        suggest_user_takeover: Optional[str] = None
    ) -> ToolResult:
        """Ask user a question and wait for response
        
        Args:
            text: Question text to present to user
            attachments: List of question-related files or reference materials
            suggest_user_takeover: Suggested operation for user takeover
            
        Returns:
            Question asking result with user response
        """
            
        # Return success result, actual UI interaction logic implemented by caller
        return ToolResult(success=True)


================================================
FILE: backend/app/domain/services/tools/plan.py
================================================
[Empty file]


================================================
FILE: backend/app/domain/services/tools/search.py
================================================
from typing import Optional
from app.domain.external.search import SearchEngine
from app.domain.services.tools.base import tool, BaseTool
from app.domain.models.tool_result import ToolResult

class SearchTool(BaseTool):
    """Search tool class, providing search engine interaction functions"""

    name: str = "search"
    
    def __init__(self, search_engine: SearchEngine):
        """Initialize search tool class
        
        Args:
            search_engine: Search engine service
        """
        super().__init__()
        self.search_engine = search_engine
    
    @tool(
        name="info_search_web",
        description="Search web pages using search engine. Use for obtaining latest information or finding references.",
        parameters={
            "query": {
                "type": "string",
                "description": "Search query in Google search style, using 3-5 keywords."
            },
            "date_range": {
                "type": "string",
                "enum": ["all", "past_hour", "past_day", "past_week", "past_month", "past_year"],
                "description": "(Optional) Time range filter for search results."
            }
        },
        required=["query"]
    )
    async def info_search_web(
        self,
        query: str,
        date_range: Optional[str] = None
    ) -> ToolResult:
        """Search webpages using search engine
        
        Args:
            query: Search query, Google search style, using 3-5 keywords
            date_range: (Optional) Time range filter for search results
            
        Returns:
            Search results
        """
        return await self.search_engine.search(query, date_range) 


================================================
FILE: backend/app/domain/services/tools/shell.py
================================================
from typing import Optional
from app.domain.external.sandbox import Sandbox
from app.domain.services.tools.base import tool, BaseTool
from app.domain.models.tool_result import ToolResult

class ShellTool(BaseTool):
    """Shell tool class, providing Shell interaction related functions"""

    name: str = "shell"
    
    def __init__(self, sandbox: Sandbox):
        """Initialize Shell tool class
        
        Args:
            sandbox: Sandbox service
        """
        super().__init__()
        self.sandbox = sandbox
        
    @tool(
        name="shell_exec",
        description="Execute commands in a specified shell session. Use for running code, installing packages, or managing files.",
        parameters={
            "id": {
                "type": "string",
                "description": "Unique identifier of the target shell session"
            },
            "exec_dir": {
                "type": "string",
                "description": "Working directory for command execution (must use absolute path)"
            },
            "command": {
                "type": "string",
                "description": "Shell command to execute"
            }
        },
        required=["id", "exec_dir", "command"]
    )
    async def shell_exec(
        self,
        id: str,
        exec_dir: str,
        command: str
    ) -> ToolResult:
        """Execute Shell command
        
        Args:
            id: Unique identifier of the target Shell session
            exec_dir: Working directory for command execution (must use absolute path)
            command: Shell command to execute
            
        Returns:
            Command execution result
        """
        return await self.sandbox.exec_command(id, exec_dir, command)
    
    @tool(
        name="shell_view",
        description="View the content of a specified shell session. Use for checking command execution results or monitoring output.",
        parameters={
            "id": {
                "type": "string",
                "description": "Unique identifier of the target shell session"
            }
        },
        required=["id"]
    )
    async def shell_view(self, id: str) -> ToolResult:
        """View Shell session content
        
        Args:
            id: Unique identifier of the target Shell session
            
        Returns:
            Shell session content
        """
        return await self.sandbox.view_shell(id)
    
    @tool(
        name="shell_wait",
        description="Wait for the running process in a specified shell session to return. Use after running commands that require longer runtime.",
        parameters={
            "id": {
                "type": "string",
                "description": "Unique identifier of the target shell session"
            },
            "seconds": {
                "type": "integer",
                "description": "Wait duration in seconds"
            }
        },
        required=["id"]
    )
    async def shell_wait(
        self,
        id: str,
        seconds: Optional[int] = None
    ) -> ToolResult:
        """Wait for the running process in Shell session to return
        
        Args:
            id: Unique identifier of the target Shell session
            seconds: Wait time (seconds)
            
        Returns:
            Wait result
        """
        return await self.sandbox.wait_for_process(id, seconds)
    
    @tool(
        name="shell_write_to_process",
        description="Write input to a running process in a specified shell session. Use for responding to interactive command prompts.",
        parameters={
            "id": {
                "type": "string",
                "description": "Unique identifier of the target shell session"
            },
            "input": {
                "type": "string",
                "description": "Input content to write to the process"
            },
            "press_enter": {
                "type": "boolean",
                "description": "Whether to press Enter key after input"
            }
        },
        required=["id", "input", "press_enter"]
    )
    async def shell_write_to_process(
        self,
        id: str,
        input: str,
        press_enter: bool
    ) -> ToolResult:
        """Write input to the running process in Shell session
        
        Args:
            id: Unique identifier of the target Shell session
            input: Input content to write to the process
            press_enter: Whether to press Enter key after input
            
        Returns:
            Write result
        """
        return await self.sandbox.write_to_process(id, input, press_enter)
    
    @tool(
        name="shell_kill_process",
        description="Terminate a running process in a specified shell session. Use for stopping long-running processes or handling frozen commands.",
        parameters={
            "id": {
                "type": "string",
                "description": "Unique identifier of the target shell session"
            }
        },
        required=["id"]
    )
    async def shell_kill_process(self, id: str) -> ToolResult:
        """Terminate the running process in Shell session
        
        Args:
            id: Unique identifier of the target Shell session
            
        Returns:
            Termination result
        """
        return await self.sandbox.kill_process(id)



================================================
FILE: backend/app/domain/utils/json_parser.py
================================================
from typing import Protocol, Optional, Any, Union, Dict, List

class JsonParser(Protocol):
    """Json parser interface"""
    
    async def parse(self, text: str, default_value: Optional[Any] = None) -> Union[Dict, List, Any]:
        """
        Parse LLM output string to JSON using multiple strategies.
        Falls back to LLM parsing if local strategies fail.
        
        Args:
            text: The raw string output from LLM
            default_value: Default value to return if parsing fails
            
        Returns:
            Parsed JSON object (dict, list, or other JSON-serializable type)
            
        Raises:
            ValueError: If all parsing strategies fail and no default value provided
        """



================================================
FILE: backend/app/infrastructure/__init__.py
================================================
[Empty file]


================================================
FILE: backend/app/infrastructure/logging.py
================================================
import logging
import sys
from app.core.config import get_settings

def setup_logging():
    """
    Configure the application logging system
    
    Sets up log levels, formatters, and handlers for both console and file output.
    Ensures proper log rotation to prevent log files from growing too large.
    """
    # Get configuration
    settings = get_settings()
    
    # Get root logger
    root_logger = logging.getLogger()
    
    # Set root log level
    log_level = getattr(logging, settings.log_level)
    root_logger.setLevel(log_level)
    
    # Create formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Create console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(log_level)
    
    # Add handlers to root logger
    root_logger.addHandler(console_handler)

    # Disable verbose logging for pymongo
    logging.getLogger("pymongo").setLevel(logging.WARNING)
    logging.getLogger("websockets").setLevel(logging.WARNING)
    logging.getLogger("sse_starlette.sse").setLevel(logging.INFO)
    
    # Log initialization complete
    root_logger.info("Logging system initialized - Console and file logging active") 


================================================
FILE: backend/app/infrastructure/external/__init__.py
================================================




================================================
FILE: backend/app/infrastructure/external/browser/playwright_browser.py
================================================
from typing import Dict, Any, Optional, List
from playwright.async_api import async_playwright, Browser, Page
import asyncio
from markdownify import markdownify
from app.infrastructure.external.llm.openai_llm import OpenAILLM
from app.core.config import get_settings
from app.domain.models.tool_result import ToolResult
import logging

# Set up logger for this module
logger = logging.getLogger(__name__)

class PlaywrightBrowser:
    """Playwright client that provides specific implementation of browser operations"""
    
    def __init__(self, cdp_url: str):
        self.browser: Optional[Browser] = None
        self.page: Optional[Page] = None
        self.playwright = None
        self.llm = OpenAILLM()
        self.settings = get_settings()
        self.cdp_url = cdp_url
        
    async def initialize(self):
        """Initialize and ensure resources are available"""
        # Add retry logic
        max_retries = 5
        retry_delay = 1  # Initial wait 1 second
        for attempt in range(max_retries):
            try:
                self.playwright = await async_playwright().start()
                # Connect to existing Chrome instance
                self.browser = await self.playwright.chromium.connect_over_cdp(self.cdp_url)
                # Get all contexts
                contexts = self.browser.contexts
                if contexts and len(contexts[0].pages) == 1:
                    # Check if it's the initial page (by URL)
                    page = contexts[0].pages[0]
                    page_url = await page.evaluate("window.location.href")
                    if (
                        page_url == "about:blank" or 
                        page_url == "chrome://newtab/" or 
                        page_url == "chrome://new-tab-page/" or 
                        not page_url
                    ):
                        # Only use it when it's the initial page and only one tab
                        self.page = page
                    else:
                        # Not the initial page, create a new page
                        self.page = await contexts[0].new_page()
                else:
                    # Create a new page in other cases
                    context = contexts[0] if contexts else await self.browser.new_context()
                    self.page = await context.new_page()
                return True
            except Exception as e:
                # Clean up failed resources
                await self.cleanup()
                
                # Return error if maximum retry count is reached
                if attempt == max_retries - 1:
                    logger.error(f"Initialization failed (retried {max_retries} times): {e}")
                    return False
                
                # Otherwise increase waiting time (exponential backoff strategy)
                retry_delay = min(retry_delay * 2, 10)  # Maximum wait 10 seconds
                logger.warning(f"Initialization failed, will retry in {retry_delay} seconds: {e}")
                await asyncio.sleep(retry_delay)

    async def cleanup(self):
        """Clean up Playwright resources, first close all tabs, then close the browser"""
        try:
            # If browser exists, first close all tabs
            if self.browser:
                # Get all contexts
                contexts = self.browser.contexts
                if contexts:
                    for context in contexts:
                        # Get all pages in the context
                        pages = context.pages
                        # Close all pages
                        for page in pages:
                            # Avoid closing self.page multiple times
                            if page != self.page or (self.page and not self.page.is_closed()):
                                await page.close()
            
            # Ensure the current page is closed (if it exists and is not closed)
            if self.page and not self.page.is_closed():
                await self.page.close()
                
            # Close the browser
            if self.browser:
                await self.browser.close()
                
            # Stop playwright
            if self.playwright:
                await self.playwright.stop()
                
        except Exception as e:
            logger.error(f"Error occurred when cleaning up resources: {e}")
        finally:
            # Reset references
            self.page = None
            self.browser = None
            self.playwright = None
    
    async def _ensure_browser(self):
        """Ensure the browser is started"""
        if not self.browser or not self.page:
            if not await self.initialize():
                raise Exception("Unable to initialize browser resources")
    
    async def _ensure_page(self):
        """Ensure the page is created and update to the current active tab (rightmost tab)"""
        await self._ensure_browser()
        if not self.page:
            self.page = await self.browser.new_page()
        else:
            # Get all contexts
            contexts = self.browser.contexts
            if contexts:
                # Get all pages in the current context
                current_context = contexts[0]
                pages = current_context.pages
                
                if pages:
                    # Get the rightmost tab (usually the most recently opened page)
                    rightmost_page = pages[-1]
                    
                    # Update if the current page is not the rightmost tab
                    if self.page != rightmost_page:
                        # Update to the rightmost tab
                        self.page = rightmost_page
    
    async def wait_for_page_load(self, timeout: int = 15) -> bool:
        """Wait for the page to finish loading, waiting up to the specified timeout
        
        Args:
            timeout: Maximum wait time (seconds), default is 15 seconds
            
        Returns:
            bool: Whether successfully waited for the page to load completely
        """
        await self._ensure_page()
        
        start_time = asyncio.get_event_loop().time()
        check_interval = 5  # Check every 5 seconds
        
        while asyncio.get_event_loop().time() - start_time < timeout:
            # Check if the page has completely loaded
            is_loaded = await self.page.evaluate("""() => {
                return document.readyState === 'complete';
            }""")
            
            if is_loaded:
                return True
                
            # Wait for a while before checking again
            await asyncio.sleep(check_interval)
        
        # Timeout, page loading not completed
        return False
    
    async def _extract_content(self) -> Dict[str, Any]:
        """Extract content from the current page"""

        # Execute JavaScript to get elements in the viewport    
        visible_content = await self.page.evaluate("""() => {
            const visibleElements = [];
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            
            // Get all potentially relevant elements
            const elements = document.querySelectorAll('body *');
            
            for (const element of elements) {
                // Check if the element is in the viewport and visible
                const rect = element.getBoundingClientRect();
                
                // Element must have some dimensions
                if (rect.width === 0 || rect.height === 0) continue;
                
                // Element must be within the viewport
                if (
                    rect.bottom < 0 || 
                    rect.top > viewportHeight ||
                    rect.right < 0 || 
                    rect.left > viewportWidth
                ) continue;
                
                // Check if the element is visible (not hidden by CSS)
                const style = window.getComputedStyle(element);
                if (
                    style.display === 'none' || 
                    style.visibility === 'hidden' || 
                    style.opacity === '0'
                ) continue;
                
                // If it's a text node or meaningful element, add it to the results
                if (
                    element.innerText || 
                    element.tagName === 'IMG' || 
                    element.tagName === 'INPUT' || 
                    element.tagName === 'BUTTON'
                ) {
                    visibleElements.push(element.outerHTML);
                }
            }
            
            // Build HTML containing these visible elements
            return '<div>' + visibleElements.join('') + '</div>';
        }""")

        
        # Convert to Markdown
        markdown_content = markdownify(visible_content)

        max_content_length = min(50000, len(markdown_content))
        response = await self.llm.ask([{
            "role": "system",
            "content": "You are a professional web page information extraction assistant. Please extract all information from the current page content and convert it to Markdown format."
        },
        {
            "role": "user",
            "content": markdown_content[:max_content_length]
        }
        ])
        
        return response.get("content", "")
    
    async def view_page(self) -> ToolResult:
        """View visible elements within the current page's viewport and convert to Markdown format"""
        await self._ensure_page()
        
        # Wait for the page to load completely, maximum wait 15 seconds
        await self.wait_for_page_load()
        
        # First update the interactive elements cache
        interactive_elements = await self._extract_interactive_elements()
        
        return ToolResult(
            success=True,
            data={
                "interactive_elements": interactive_elements,
                "content": await self._extract_content(),
            }
        )
    
    async def _extract_interactive_elements(self) -> List[str]:
        """Return a list of visible interactive elements on the page, formatted as index:<tag>text</tag>"""
        await self._ensure_page()
        
        # Clear the current page's cache to ensure we always get the latest list of elements
        self.page.interactive_elements_cache = []
        
        # Execute JavaScript to get interactive elements in the viewport
        interactive_elements = await self.page.evaluate("""() => {
            const interactiveElements = [];
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            
            // Get all potentially relevant interactive elements
            const elements = document.querySelectorAll('button, a, input, textarea, select, [role="button"], [tabindex]:not([tabindex="-1"])');
            
            let validElementIndex = 0; // For generating consecutive indices
            
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                // Check if the element is in the viewport and visible
                const rect = element.getBoundingClientRect();
                
                // Element must have some dimensions
                if (rect.width === 0 || rect.height === 0) continue;
                
                // Element must be within the viewport
                if (
                    rect.bottom < 0 || 
                    rect.top > viewportHeight ||
                    rect.right < 0 || 
                    rect.left > viewportWidth
                ) continue;
                
                // Check if the element is visible (not hidden by CSS)
                const style = window.getComputedStyle(element);
                if (
                    style.display === 'none' || 
                    style.visibility === 'hidden' || 
                    style.opacity === '0'
                ) continue;
                
                
                // Get element type and text
                let tagName = element.tagName.toLowerCase();
                let text = '';
                
                if (element.value && ['input', 'textarea', 'select'].includes(tagName)) {
                    text = element.value;
                    
                    // Add label and placeholder information for input elements
                    if (tagName === 'input') {
                        // Get associated label text
                        let labelText = '';
                        if (element.id) {
                            const label = document.querySelector(`label[for="${element.id}"]`);
                            if (label) {
                                labelText = label.innerText.trim();
                            }
                        }
                        
                        // Look for parent or sibling label
                        if (!labelText) {
                            const parentLabel = element.closest('label');
                            if (parentLabel) {
                                labelText = parentLabel.innerText.trim().replace(element.value, '').trim();
                            }
                        }
                        
                        // Add label information
                        if (labelText) {
                            text = `[Label: ${labelText}] ${text}`;
                        }
                        
                        // Add placeholder information
                        if (element.placeholder) {
                            text = `${text} [Placeholder: ${element.placeholder}]`;
                        }
                    }
                } else if (element.innerText) {
                    text = element.innerText.trim().replace(/\\s+/g, ' ');
                } else if (element.alt) { // For image buttons
                    text = element.alt;
                } else if (element.title) { // For elements with title
                    text = element.title;
                } else if (element.placeholder) { // For placeholder text
                    text = `[Placeholder: ${element.placeholder}]`;
                } else if (element.type) { // For input type
                    text = `[${element.type}]`;
                    
                    // Add label and placeholder information for text-less input elements
                    if (tagName === 'input') {
                        // Get associated label text
                        let labelText = '';
                        if (element.id) {
                            const label = document.querySelector(`label[for="${element.id}"]`);
                            if (label) {
                                labelText = label.innerText.trim();
                            }
                        }
                        
                        // Look for parent or sibling label
                        if (!labelText) {
                            const parentLabel = element.closest('label');
                            if (parentLabel) {
                                labelText = parentLabel.innerText.trim();
                            }
                        }
                        
                        // Add label information
                        if (labelText) {
                            text = `[Label: ${labelText}] ${text}`;
                        }
                        
                        // Add placeholder information
                        if (element.placeholder) {
                            text = `${text} [Placeholder: ${element.placeholder}]`;
                        }
                    }
                } else {
                    text = '[No text]';
                }
                
                // Maximum limit on text length to keep it clear
                if (text.length > 100) {
                    text = text.substring(0, 97) + '...';
                }
                
                // Only add data-manus-id attribute to elements that meet the conditions
                element.setAttribute('data-manus-id', `manus-element-${validElementIndex}`);
                                                        
                // Build selector - using only data-manus-id
                const selector = `[data-manus-id="manus-element-${validElementIndex}"]`;
                
                // Add element information to the array
                interactiveElements.push({
                    index: validElementIndex,  // Use consecutive index
                    tag: tagName,
                    text: text,
                    selector: selector
                });
                
                validElementIndex++; // Increment valid element counter
            }
            
            return interactiveElements;
        }""")
        
        # Update cache
        self.page.interactive_elements_cache = interactive_elements
        
        # Format element information in specified format
        formatted_elements = []
        for el in interactive_elements:
            formatted_elements.append(f"{el['index']}:<{el['tag']}>{el['text']}</{el['tag']}>")
        
        return formatted_elements
    
    async def navigate(self, url: str, timeout: Optional[int] = 15000) -> ToolResult:
        """Navigate to the specified URL
        
        Args:
            url: URL to navigate to
            timeout: Navigation timeout (milliseconds), default is 60 seconds
        """
        await self._ensure_page()
        try:
            # Clear cache as the page is about to change
            self.page.interactive_elements_cache = []
            try:
                await self.page.goto(url, timeout=timeout)
            except Exception as e:
                logger.warning(f"Failed to navigate to {url}: {str(e)}")
            return ToolResult(
                success=True,
                data={
                    "interactive_elements": await self._extract_interactive_elements(),
                }
            )
        except Exception as e:
            return ToolResult(success=False, message=f"Failed to navigate to {url}: {str(e)}")
    
    async def restart(self, url: str) -> ToolResult:
        """Restart the browser and navigate to the specified URL"""
        await self.cleanup()
        return await self.navigate(url)

    
    async def _get_element_by_index(self, index: int) -> Optional[Any]:
        """Get element by index using data-manus-id selector
        
        Args:
            index: Element index
            
        Returns:
            The found element, or None if not found
        """
        # Check if there are cached elements
        if not hasattr(self.page, 'interactive_elements_cache') or not self.page.interactive_elements_cache or index >= len(self.page.interactive_elements_cache):
            return None
        
        # Use data-manus-id selector
        selector = f'[data-manus-id="manus-element-{index}"]'
        return await self.page.query_selector(selector)
    
    async def click(
        self,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Click an element"""
        await self._ensure_page()
        if coordinate_x is not None and coordinate_y is not None:
            await self.page.mouse.click(coordinate_x, coordinate_y)
        elif index is not None:
            try:
                element = await self._get_element_by_index(index)
                if not element:
                    return ToolResult(success=False, message=f"Cannot find interactive element with index {index}")
                
                # Check if the element is visible
                is_visible = await self.page.evaluate("""(element) => {
                    if (!element) return false;
                    const rect = element.getBoundingClientRect();
                    const style = window.getComputedStyle(element);
                    return !(
                        rect.width === 0 || 
                        rect.height === 0 || 
                        style.display === 'none' || 
                        style.visibility === 'hidden' || 
                        style.opacity === '0'
                    );
                }""", element)
                
                if not is_visible:
                    # Try to scroll to the element position
                    await self.page.evaluate("""(element) => {
                        if (element) {
                            element.scrollIntoView({behavior: 'smooth', block: 'center'});
                        }
                    }""", element)
                    # Wait for the element to become visible
                    await asyncio.sleep(1)
                
                # Try to click the element
                await element.click(timeout=5000)
            except Exception as e:
                return ToolResult(success=False, message=f"Failed to click element: {str(e)}")
        return ToolResult(success=True)
    
    async def input(
        self,
        text: str,
        press_enter: bool,
        index: Optional[int] = None,
        coordinate_x: Optional[float] = None,
        coordinate_y: Optional[float] = None
    ) -> ToolResult:
        """Input text"""
        await self._ensure_page()
        if coordinate_x is not None and coordinate_y is not None:
            await self.page.mouse.click(coordinate_x, coordinate_y)
            await self.page.keyboard.type(text)
        elif index is not None:
            try:
                element = await self._get_element_by_index(index)
                if not element:
                    return ToolResult(success=False, message=f"Cannot find interactive element with index {index}")
                
                # Try to use fill() method, but catch possible errors
                try:
                    await element.fill("")
                    await element.type(text)
                except Exception as e:
                    # If fill() fails, use type() method directly
                    await element.click()
                    await self.page.keyboard.type(text)
            except Exception as e:
                return ToolResult(success=False, message=f"Failed to input text: {str(e)}")
        
        if press_enter:
            await self.page.keyboard.press("Enter")
        return ToolResult(success=True)
    
    async def move_mouse(
        self,
        coordinate_x: float,
        coordinate_y: float
    ) -> ToolResult:
        """Move the mouse"""
        await self._ensure_page()
        await self.page.mouse.move(coordinate_x, coordinate_y)
        return ToolResult(success=True)
    
    async def press_key(self, key: str) -> ToolResult:
        """Simulate key press"""
        await self._ensure_page()
        await self.page.keyboard.press(key)
        return ToolResult(success=True)
    
    async def select_option(
        self,
        index: int,
        option: int
    ) -> ToolResult:
        """Select dropdown option"""
        await self._ensure_page()
        try:
            element = await self._get_element_by_index(index)
            if not element:
                return ToolResult(success=False, message=f"Cannot find selector element with index {index}")
            
            # Try to select the option
            await element.select_option(index=option)
            return ToolResult(success=True)
        except Exception as e:
            return ToolResult(success=False, message=f"Failed to select option: {str(e)}")
    
    async def scroll_up(
        self,
        to_top: Optional[bool] = None
    ) -> ToolResult:
        """Scroll up"""
        await self._ensure_page()
        if to_top:
            await self.page.evaluate("window.scrollTo(0, 0)")
        else:
            await self.page.evaluate("window.scrollBy(0, -window.innerHeight)")
        return ToolResult(success=True)
    
    async def scroll_down(
        self,
        to_bottom: Optional[bool] = None
    ) -> ToolResult:
        """Scroll down"""
        await self._ensure_page()
        if to_bottom:
            await self.page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
        else:
            await self.page.evaluate("window.scrollBy(0, window.innerHeight)")
        return ToolResult(success=True)
    
    async def screenshot(
        self,
        full_page: Optional[bool] = False
    ) -> bytes:
        """Take a screenshot of the current page
        
        Args:
            full_page: Whether to capture the full page or just the viewport
            
        Returns:
            bytes: PNG screenshot data
        """
        await self._ensure_page()
        
        # Configure screenshot options
        screenshot_options = {
            "full_page": full_page,
            "type": "png"
        }
        
        # Return bytes data directly
        return await self.page.screenshot(**screenshot_options)
    
    async def console_exec(self, javascript: str) -> ToolResult:
        """Execute JavaScript code"""
        await self._ensure_page()
        result = await self.page.evaluate(javascript)
        return ToolResult(success=True, data={"result": result})
    
    async def console_view(self, max_lines: Optional[int] = None) -> ToolResult:
        """View console output"""
        await self._ensure_page()
        logs = await self.page.evaluate("""() => {
            return window.console.logs || [];
        }""")
        if max_lines is not None:
            logs = logs[-max_lines:]
        return ToolResult(success=True, data={"logs": logs})



================================================
FILE: backend/app/infrastructure/external/cache/__init__.py
================================================
from app.infrastructure.external.cache.redis_cache import RedisCache
from functools import lru_cache

@lru_cache()
def get_cache():
    """Get cache implementation"""
    return RedisCache()

__all__ = ['get_cache', 'RedisCache']



================================================
FILE: backend/app/infrastructure/external/cache/redis_cache.py
================================================
import json
import logging
from typing import Optional, Any
from app.domain.external.cache import Cache
from app.infrastructure.storage.redis import get_redis

logger = logging.getLogger(__name__)


class RedisCache:
    """Redis implementation of Cache interface"""
    
    def __init__(self):
        self.redis_client = get_redis()
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """Store a value with optional TTL"""
        try:
            await self.redis_client.initialize()
            
            # Serialize value to JSON
            serialized_value = json.dumps(value)
            
            if ttl is not None:
                # Set with TTL
                result = await self.redis_client.client.setex(key, ttl, serialized_value)
            else:
                # Set without TTL
                result = await self.redis_client.client.set(key, serialized_value)
            
            return result is not None
            
        except Exception as e:
            logger.error(f"Failed to set cache key {key}: {str(e)}")
            return False
    
    async def get(self, key: str) -> Optional[Any]:
        """Retrieve a value from cache"""
        try:
            await self.redis_client.initialize()
            
            value = await self.redis_client.client.get(key)
            if value is None:
                return None
            
            # Deserialize from JSON
            return json.loads(value)
            
        except json.JSONDecodeError:
            logger.error(f"Failed to deserialize cache value for key {key}")
            # Delete corrupted data
            await self.delete(key)
            return None
        except Exception as e:
            logger.error(f"Failed to get cache key {key}: {str(e)}")
            return None
    
    async def delete(self, key: str) -> bool:
        """Delete a value from cache"""
        try:
            await self.redis_client.initialize()
            
            result = await self.redis_client.client.delete(key)
            return result > 0
            
        except Exception as e:
            logger.error(f"Failed to delete cache key {key}: {str(e)}")
            return False
    
    async def exists(self, key: str) -> bool:
        """Check if a key exists in cache"""
        try:
            await self.redis_client.initialize()
            
            result = await self.redis_client.client.exists(key)
            return result > 0
            
        except Exception as e:
            logger.error(f"Failed to check existence of cache key {key}: {str(e)}")
            return False
    
    async def get_ttl(self, key: str) -> Optional[int]:
        """Get the remaining TTL of a key"""
        try:
            await self.redis_client.initialize()
            
            ttl = await self.redis_client.client.ttl(key)
            
            # Redis returns -1 if key exists but has no expiration
            # Redis returns -2 if key doesn't exist
            if ttl == -2:
                return None  # Key doesn't exist
            elif ttl == -1:
                return None  # Key exists but has no expiration
            else:
                return ttl  # TTL in seconds
                
        except Exception as e:
            logger.error(f"Failed to get TTL for cache key {key}: {str(e)}")
            return None
    
    async def keys(self, pattern: str) -> list[str]:
        """Get all keys matching a pattern"""
        try:
            await self.redis_client.initialize()
            
            keys = await self.redis_client.client.keys(pattern)
            return keys if keys else []
            
        except Exception as e:
            logger.error(f"Failed to get keys with pattern {pattern}: {str(e)}")
            return []
    
    async def clear_pattern(self, pattern: str) -> int:
        """Clear all keys matching a pattern"""
        try:
            await self.redis_client.initialize()
            
            keys = await self.keys(pattern)
            if not keys:
                return 0
            
            result = await self.redis_client.client.delete(*keys)
            return result
            
        except Exception as e:
            logger.error(f"Failed to clear keys with pattern {pattern}: {str(e)}")
            return 0



================================================
FILE: backend/app/infrastructure/external/file/__init__.py
================================================
"""文件存储基础设施模块"""

from .gridfsfile import GridFSFileStorage

__all__ = ["GridFSFileStorage"] 


================================================
FILE: backend/app/infrastructure/external/file/gridfsfile.py
================================================
import logging
import io
from typing import BinaryIO, Optional, Dict, Any, Tuple
from datetime import datetime
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorGridFSBucket

from app.domain.external.file import FileStorage
from app.domain.models.file import FileInfo
from app.infrastructure.storage.mongodb import MongoDB
from app.core.config import get_settings
from functools import lru_cache

logger = logging.getLogger(__name__)


class GridFSFileStorage(FileStorage):
    """MongoDB GridFS-based file storage implementation"""
    
    def __init__(self, mongodb: MongoDB, bucket_name: str = "fs"):
        """
        Initialize GridFS file storage
        
        Args:
            mongodb: MongoDB connection instance
            bucket_name: GridFS bucket name, default is 'fs'
        """
        self.mongodb = mongodb
        self.bucket_name = bucket_name
        self.settings = get_settings()
    
    def _get_gridfs_bucket(self) -> AsyncIOMotorGridFSBucket:
        """Get async GridFS Bucket instance"""
        if not self.mongodb.client:
            raise RuntimeError("MongoDB client not initialized")
        
        # Use database name from configuration
        database = self.mongodb.client[self.settings.mongodb_database]
        return AsyncIOMotorGridFSBucket(database, bucket_name=self.bucket_name)
    
    def _get_files_collection(self):
        """Get files collection for querying file metadata"""
        if not self.mongodb.client:
            raise RuntimeError("MongoDB client not initialized")
        
        database = self.mongodb.client[self.settings.mongodb_database]
        return database[f"{self.bucket_name}.files"]
    
    def _create_file_info(self, file_info: Dict[str, Any], file_id: str) -> FileInfo:
        """Create FileInfo object from GridFS file metadata"""
        metadata = file_info.get('metadata', {})
        return FileInfo(
            file_id=str(file_info['_id']),
            filename=file_info.get('filename', f"file_{file_id}"),
            content_type=metadata.get('contentType'),
            size=file_info.get('length', 0),
            upload_date=file_info.get('uploadDate', datetime.utcnow()),
            metadata=metadata,
            user_id=metadata.get('user_id', '')  # Get user_id from metadata
        )
    
    async def upload_file(
        self,
        file_data: BinaryIO,
        filename: str,
        user_id: str,
        content_type: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> FileInfo:
        """Upload file to GridFS"""
        try:
            bucket = self._get_gridfs_bucket()
            
            # Prepare metadata
            file_metadata = {
                'filename': filename,
                'uploadDate': datetime.utcnow(),
                'user_id': user_id,  # Store user_id in metadata
                **(metadata or {})
            }
            
            if content_type:
                file_metadata['contentType'] = content_type
            
            # Upload directly from file stream to avoid loading entire file into memory
            file_id = await bucket.upload_from_stream(
                filename,
                file_data,
                metadata=file_metadata
            )
            
            # Get file size (can be retrieved from GridFS if needed)
            files_collection = self._get_files_collection()
            file_info = await files_collection.find_one({"_id": file_id})
            file_size = file_info.get('length', 0) if file_info else 0
            
            logger.info(f"File uploaded successfully: {filename} (ID: {file_id}) for user {user_id}")
            
            return FileInfo(
                file_id=str(file_id),
                filename=filename,
                size=file_size,
                content_type=content_type,
                upload_date=file_metadata['uploadDate'],
                metadata=file_metadata,
                user_id=user_id
            )
            
        except Exception as e:
            logger.error(f"Failed to upload file {filename} for user {user_id}: {str(e)}")
            raise
    
    async def download_file(self, file_id: str, user_id: Optional[str] = None) -> Tuple[BinaryIO, FileInfo]:
        """Download file by file ID"""
        try:
            bucket = self._get_gridfs_bucket()
            files_collection = self._get_files_collection()
            
            # Convert ObjectId
            try:
                obj_id = ObjectId(file_id)
            except Exception:
                raise ValueError(f"Invalid file ID format: {file_id}")
            
            # Get file information and check user ownership
            file_info = await files_collection.find_one({"_id": obj_id})
            if not file_info:
                raise FileNotFoundError(f"File not found with ID: {file_id}")
            
            # Check if file belongs to the user (skip check if user_id is None)
            if user_id is not None:
                file_user_id = file_info.get('metadata', {}).get('user_id')
                if file_user_id != user_id:
                    raise PermissionError(f"Access denied: file {file_id} does not belong to user {user_id}")
            stream = io.BytesIO()
            await bucket.download_to_stream(obj_id, stream)
            stream.seek(0)
            return stream, self._create_file_info(file_info, file_id)
            
        except FileNotFoundError:
            raise
        except (FileNotFoundError, PermissionError):
            raise
        except Exception as e:
            logger.error(f"Failed to download file {file_id} for user {user_id}: {str(e)}")
            raise
    
    async def delete_file(self, file_id: str, user_id: str) -> bool:
        """Delete file"""
        try:
            bucket = self._get_gridfs_bucket()
            files_collection = self._get_files_collection()
            
            # Convert ObjectId
            try:
                obj_id = ObjectId(file_id)
            except Exception:
                raise ValueError(f"Invalid file ID format: {file_id}")
            
            # Check if file exists and belongs to user
            file_info = await files_collection.find_one({"_id": obj_id})
            if not file_info:
                return False
            
            # Check if file belongs to the user
            file_user_id = file_info.get('metadata', {}).get('user_id')
            if file_user_id != user_id:
                logger.warning(f"Delete access denied: file {file_id} does not belong to user {user_id}")
                return False
            
            # Delete file
            await bucket.delete(obj_id)
            logger.info(f"File deleted successfully: {file_id} by user {user_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to delete file {file_id} for user {user_id}: {str(e)}")
            return False
    
    async def get_file_info(self, file_id: str, user_id: str) -> Optional[FileInfo]:
        """Get file information"""
        try:
            files_collection = self._get_files_collection()
            
            # Convert ObjectId
            try:
                obj_id = ObjectId(file_id)
            except Exception:
                raise ValueError(f"Invalid file ID format: {file_id}")
            
            # Get file information and check user ownership
            file_info = await files_collection.find_one({"_id": obj_id})
            if not file_info:
                return None
            
            # Check if file belongs to the user
            file_user_id = file_info.get('metadata', {}).get('user_id')
            if file_user_id != user_id:
                logger.warning(f"Access denied: file {file_id} does not belong to user {user_id}")
                return None
            
            return self._create_file_info(file_info, file_id)
            
        except Exception as e:
            logger.error(f"Failed to get file info {file_id} for user {user_id}: {str(e)}")
            return None

@lru_cache()
def get_file_storage() -> FileStorage:
    """Get file storage instance"""
    from app.infrastructure.storage.mongodb import get_mongodb
    return GridFSFileStorage(mongodb=get_mongodb())



================================================
FILE: backend/app/infrastructure/external/llm/openai_llm.py
================================================
from typing import List, Dict, Any, Optional
from openai import AsyncOpenAI
from app.domain.external.llm import LLM
from app.core.config import get_settings
import logging


logger = logging.getLogger(__name__)

class OpenAILLM(LLM):
    def __init__(self):
        settings = get_settings()
        self.client = AsyncOpenAI(
            api_key=settings.api_key,
            base_url=settings.api_base
        )
        
        self._model_name = settings.model_name
        self._temperature = settings.temperature
        self._max_tokens = settings.max_tokens
        logger.info(f"Initialized OpenAI LLM with model: {self._model_name}")
    
    @property
    def model_name(self) -> str:
        return self._model_name
    
    @property
    def temperature(self) -> float:
        return self._temperature
    
    @property
    def max_tokens(self) -> int:
        return self._max_tokens
    
    async def ask(self, messages: List[Dict[str, str]], 
                tools: Optional[List[Dict[str, Any]]] = None,
                response_format: Optional[Dict[str, Any]] = None,
                tool_choice: Optional[str] = None) -> Dict[str, Any]:
        """Send chat request to OpenAI API"""
        response = None
        try:
            if tools:
                logger.debug(f"Sending request to OpenAI with tools, model: {self._model_name}")
                response = await self.client.chat.completions.create(
                    model=self._model_name,
                    temperature=self._temperature,
                    max_tokens=self._max_tokens,
                    messages=messages,
                    tools=tools,
                    response_format=response_format,
                    tool_choice=tool_choice,
                    parallel_tool_calls=False
                )
            else:
                logger.debug(f"Sending request to OpenAI without tools, model: {self._model_name}")
                response = await self.client.chat.completions.create(
                    model=self._model_name,
                    temperature=self._temperature,
                    max_tokens=self._max_tokens,
                    messages=messages,
                    response_format=response_format,
                    parallel_tool_calls=False
                )
            logger.debug(f"Response from OpenAI: {response.model_dump()}")
            return response.choices[0].message.model_dump()
        except Exception as e:
            logger.error(f"Error calling OpenAI API: {str(e)}")
            raise


================================================
FILE: backend/app/infrastructure/external/message_queue/redis_stream_queue.py
================================================
import json
import uuid
import asyncio
from typing import Any, AsyncGenerator, Optional, Tuple
import logging
from app.infrastructure.storage.redis import get_redis
from app.domain.external.message_queue import MessageQueue

logger = logging.getLogger(__name__)

class RedisStreamQueue(MessageQueue):
    """Redis Stream implementation of message queue"""
    
    def __init__(self, stream_name: str):
        self._stream_name = stream_name
        self._redis = get_redis()
        self._lock_expire_seconds = 10  # Lock expiration time
    
    async def _acquire_lock(self, lock_key: str, timeout_seconds: int = 5) -> Optional[str]:
        """Acquire distributed lock
        
        Args:
            lock_key: Lock key name
            timeout_seconds: Timeout in seconds for acquiring lock
            
        Returns:
            str: Lock value if acquired successfully, None otherwise
        """
        lock_value = str(uuid.uuid4())
        end_time = timeout_seconds
        
        while end_time > 0:
            # Use SET with NX and EX for atomic lock acquisition
            result = await self._redis.client.set(
                lock_key,
                lock_value,
                nx=True,  # Only set if key doesn't exist
                ex=self._lock_expire_seconds  # Set expiration time
            )
            
            if result:
                return lock_value
            
            # Wait a bit before retrying
            await asyncio.sleep(0.1)
            end_time -= 0.1
        
        return None
    
    async def _release_lock(self, lock_key: str, lock_value: str) -> bool:
        """Release distributed lock
        
        Args:
            lock_key: Lock key name
            lock_value: Lock value for verification
            
        Returns:
            bool: True if lock released successfully, False otherwise
        """
        # Lua script for atomic lock release
        release_script = """
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
        """
        
        try:
            script = self._redis.client.register_script(release_script)
            result = await script(keys=[lock_key], args=[lock_value])
            return result == 1
        except Exception:
            return False
    
    async def put(self, message: Any) -> str:
        """Add a message to the stream
        
        Args:
            message: Message to be sent
            
        Returns:
            str: Message ID
        """
        logger.debug(f"Putting message into stream ({self._stream_name}): {message}")
        message_id = await self._redis.client.xadd(self._stream_name, {"data": message})
        return message_id
    
    async def get(self, start_id: str = "0", block_ms: Optional[int] = None) -> Tuple[str, Any]:
        """Get a message from the stream
        
        Args:
            start_id: Message ID to start reading from, defaults to "0" meaning from the earliest message
            block_ms: Block time in milliseconds, defaults to None meaning no blocking
            
        Returns:
            Tuple[str, Any]: (Message ID, Message content), returns (None, None) if no message
        """
        logger.debug(f"Getting message from stream ({self._stream_name}): {start_id}")
        # Handle None start_id by using "0" (read from beginning)
        if start_id is None:
            start_id = "0"
            
        # Read new messages
        messages = await self._redis.client.xread(
            {self._stream_name: start_id},
            count=1,
            block=block_ms
        )
        
        if not messages:
            return None, None
            
        # Get message ID and data
        stream_messages = messages[0][1]
        if not stream_messages:
            return None, None
            
        message_id, message_data = stream_messages[0]
        
        try:
            # Try both bytes and string keys for compatibility
            return message_id, message_data.get("data")
        except (KeyError, json.JSONDecodeError):
            return None, None
    
    async def get_range(self, start_id: str = "-", end_id: str = "+", count: int = 100) -> AsyncGenerator[Tuple[str, Any], None]:
        """Get messages within a specified range
        
        Args:
            start_id: Start ID, defaults to "-" meaning the earliest message
            end_id: End ID, defaults to "+" meaning the latest message
            count: Maximum number of messages to return
            
        Yields:
            Tuple[str, Any]: (Message ID, Message content)
        """
        messages = await self._redis.client.xrange(self._stream_name, start_id, end_id, count=count)
        
        if not messages:
            return
            
        for message_id, message_data in messages:
            try:
                # Try both bytes and string keys for compatibility
                data = message_data.get("data")
                yield message_id, data
            except (KeyError, json.JSONDecodeError):
                continue
    
    async def get_latest_id(self) -> str:
        """Get the latest message ID
        
        Returns:
            str: Latest message ID, returns "0" if no messages
        """
        messages = await self._redis.client.xrevrange(self._stream_name, "+", "-", count=1)
        if not messages:
            return "0"
        return messages[0][0]
    
    async def clear(self) -> None:
        """Clear all messages from the stream"""
        await self._redis.client.xtrim(self._stream_name, 0)
    
    async def is_empty(self) -> bool:
        """Check if the stream is empty"""
        return await self.size() == 0
    
    async def size(self) -> int:
        """Get the number of messages in the stream"""
        info = await self._redis.client.xlen(self._stream_name)
        return info

    async def delete_message(self, message_id: str) -> bool:
        """Delete a specific message from the stream
        
        Args:
            message_id: ID of the message to delete
            
        Returns:
            bool: True if message was deleted successfully, False otherwise
        """
        try:
            await self._redis.client.xdel(self._stream_name, message_id)
            return True
        except Exception:
            return False

    async def pop(self) -> Tuple[str, Any]:
        """Get and remove the first message from the stream using distributed lock
        
        Returns:
            Tuple[str, Any]: (Message ID, Message content), returns (None, None) if stream is empty
        """
        logger.debug(f"Popping message from stream ({self._stream_name})")
        lock_key = f"lock:{self._stream_name}:pop"
        
        # Acquire distributed lock
        lock_value = await self._acquire_lock(lock_key)
        if not lock_value:
            return None, None
        
        try:
            # Get the first message from stream
            messages = await self._redis.client.xrange(self._stream_name, "-", "+", count=1)
            
            if not messages:
                return None, None
            
            message_id, message_data = messages[0]
            
            # Delete the message from stream
            await self._redis.client.xdel(self._stream_name, message_id)
            
            try:
                # Try both bytes and string keys for compatibility
                return message_id, message_data.get("data")
            except (KeyError, json.JSONDecodeError):
                logger.exception(f"Error parsing message from stream ({self._stream_name}): {message_data}")
                return None, None
                
        finally:
            # Always release the lock
            await self._release_lock(lock_key, lock_value)



================================================
FILE: backend/app/infrastructure/external/sandbox/docker_sandbox.py
================================================
from typing import Dict, Any, Optional, List, BinaryIO
import uuid
import httpx
import docker
import socket
import logging
import asyncio
import io
from async_lru import alru_cache
from app.core.config import get_settings
from app.domain.models.tool_result import ToolResult
from app.domain.external.sandbox import Sandbox
from app.infrastructure.external.browser.playwright_browser import PlaywrightBrowser
from app.domain.external.browser import Browser
from app.domain.external.llm import LLM

logger = logging.getLogger(__name__)

class DockerSandbox(Sandbox):
    def __init__(self, ip: str = None, container_name: str = None):
        """Initialize Docker sandbox and API interaction client"""
        self.client = httpx.AsyncClient(timeout=600)
        self.ip = ip
        self.base_url = f"http://{self.ip}:8080"
        self._vnc_url = f"ws://{self.ip}:5901"
        self._cdp_url = f"http://{self.ip}:9222"
        self._container_name = container_name
    
    @property
    def id(self) -> str:
        """Sandbox ID"""
        if not self._container_name:
            return "dev-sandbox"
        return self._container_name
    
    
    @property
    def cdp_url(self) -> str:
        return self._cdp_url

    @property
    def vnc_url(self) -> str:
        return self._vnc_url

    @staticmethod
    def _get_container_ip(container) -> str:
        """Get container IP address from network settings
        
        Args:
            container: Docker container instance
            
        Returns:
            Container IP address
        """
        # Get container network settings
        network_settings = container.attrs['NetworkSettings']
        ip_address = network_settings['IPAddress']
        
        # If default network has no IP, try to get IP from other networks
        if not ip_address and 'Networks' in network_settings:
            networks = network_settings['Networks']
            # Try to get IP from first available network
            for network_name, network_config in networks.items():
                if 'IPAddress' in network_config and network_config['IPAddress']:
                    ip_address = network_config['IPAddress']
                    break
        
        return ip_address

    @staticmethod
    def _create_task() -> 'DockerSandbox':
        """Create a new Docker sandbox (static method)
        
        Args:
            image: Docker image name
            name_prefix: Container name prefix
            
        Returns:
            DockerSandbox instance
        """
        # Use configured default values
        settings = get_settings()

        image = settings.sandbox_image
        name_prefix = settings.sandbox_name_prefix
        container_name = f"{name_prefix}-{str(uuid.uuid4())[:8]}"
        
        try:
            # Create Docker client
            docker_client = docker.from_env()

            # Prepare container configuration
            container_config = {
                "image": image,
                "name": container_name,
                "detach": True,
                "remove": True,
                "environment": {
                    "SERVICE_TIMEOUT_MINUTES": settings.sandbox_ttl_minutes,
                    "CHROME_ARGS": settings.sandbox_chrome_args,
                    "HTTPS_PROXY": settings.sandbox_https_proxy,
                    "HTTP_PROXY": settings.sandbox_http_proxy,
                    "NO_PROXY": settings.sandbox_no_proxy
                }
            }
            
            # Add network to container config if configured
            if settings.sandbox_network:
                container_config["network"] = settings.sandbox_network
            
            # Create container
            container = docker_client.containers.run(**container_config)
            
            # Get container IP address
            container.reload()  # Refresh container info
            ip_address = DockerSandbox._get_container_ip(container)
            
            # Create and return DockerSandbox instance
            return DockerSandbox(
                ip=ip_address,
                container_name=container_name
            )
            
        except Exception as e:
            raise Exception(f"Failed to create Docker sandbox: {str(e)}")

    async def ensure_sandbox(self) -> None:
        """Ensure sandbox is ready by checking that all services are RUNNING"""
        max_retries = 30  # Maximum number of retries
        retry_interval = 2  # Seconds between retries
        
        for attempt in range(max_retries):
            try:
                response = await self.client.get(f"{self.base_url}/api/v1/supervisor/status")
                response.raise_for_status()
                
                # Parse response as ToolResult
                tool_result = ToolResult(**response.json())
                
                if not tool_result.success:
                    logger.warning(f"Supervisor status check failed: {tool_result.message}")
                    await asyncio.sleep(retry_interval)
                    continue
                
                services = tool_result.data or []
                if not services:
                    logger.warning("No services found in supervisor status")
                    await asyncio.sleep(retry_interval)
                    continue
                
                # Check if all services are RUNNING
                all_running = True
                non_running_services = []
                
                for service in services:
                    service_name = service.get("name", "unknown")
                    state_name = service.get("statename", "")
                    
                    if state_name != "RUNNING":
                        all_running = False
                        non_running_services.append(f"{service_name}({state_name})")
                
                if all_running:
                    logger.info(f"All {len(services)} services are RUNNING - sandbox is ready")
                    return  # Success - all services are running
                else:
                    logger.info(f"Waiting for services to start... Non-running: {', '.join(non_running_services)} (attempt {attempt + 1}/{max_retries})")
                    await asyncio.sleep(retry_interval)
                    
            except Exception as e:
                logger.warning(f"Failed to check supervisor status (attempt {attempt + 1}/{max_retries}): {str(e)}")
                await asyncio.sleep(retry_interval)
        
        # If we reach here, we've exhausted all retries
        error_message = f"Sandbox services failed to start after {max_retries} attempts ({max_retries * retry_interval} seconds)"
        logger.error(error_message)
        # TODO: find a way to handle this
        #raise Exception(error_message)

    async def exec_command(self, session_id: str, exec_dir: str, command: str) -> ToolResult:
        response = await self.client.post(
            f"{self.base_url}/api/v1/shell/exec",
            json={
                "id": session_id,
                "exec_dir": exec_dir,
                "command": command
            }
        )
        return ToolResult(**response.json())

    async def view_shell(self, session_id: str, console: bool = False) -> ToolResult:
        response = await self.client.post(
            f"{self.base_url}/api/v1/shell/view",
            json={
                "id": session_id,
                "console": console
            }
        )
        return ToolResult(**response.json())

    async def wait_for_process(self, session_id: str, seconds: Optional[int] = None) -> ToolResult:
        response = await self.client.post(
            f"{self.base_url}/api/v1/shell/wait",
            json={
                "id": session_id,
                "seconds": seconds
            }
        )
        return ToolResult(**response.json())

    async def write_to_process(self, session_id: str, input_text: str, press_enter: bool = True) -> ToolResult:
        response = await self.client.post(
            f"{self.base_url}/api/v1/shell/write",
            json={
                "id": session_id,
                "input": input_text,
                "press_enter": press_enter
            }
        )
        return ToolResult(**response.json())

    async def kill_process(self, session_id: str) -> ToolResult:
        response = await self.client.post(
            f"{self.base_url}/api/v1/shell/kill",
            json={"id": session_id}
        )
        return ToolResult(**response.json())

    async def file_write(self, file: str, content: str, append: bool = False, 
                        leading_newline: bool = False, trailing_newline: bool = False, 
                        sudo: bool = False) -> ToolResult:
        """Write content to file
        
        Args:
            file: File path
            content: Content to write
            append: Whether to append content
            leading_newline: Whether to add newline before content
            trailing_newline: Whether to add newline after content
            sudo: Whether to use sudo privileges
            
        Returns:
            Result of write operation
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/write",
            json={
                "file": file,
                "content": content,
                "append": append,
                "leading_newline": leading_newline,
                "trailing_newline": trailing_newline,
                "sudo": sudo
            }
        )
        return ToolResult(**response.json())

    async def file_read(self, file: str, start_line: int = None, 
                        end_line: int = None, sudo: bool = False) -> ToolResult:
        """Read file content
        
        Args:
            file: File path
            start_line: Start line number
            end_line: End line number
            sudo: Whether to use sudo privileges
            
        Returns:
            File content
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/read",
            json={
                "file": file,
                "start_line": start_line,
                "end_line": end_line,
                "sudo": sudo
            }
        )
        return ToolResult(**response.json())
        
    async def file_exists(self, path: str) -> ToolResult:
        """Check if file exists
        
        Args:
            path: File path
            
        Returns:
            Whether file exists
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/exists",
            json={"path": path}
        )
        return ToolResult(**response.json())
        
    async def file_delete(self, path: str) -> ToolResult:
        """Delete file
        
        Args:
            path: File path
            
        Returns:
            Result of delete operation
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/delete",
            json={"path": path}
        )
        return ToolResult(**response.json())
        
    async def file_list(self, path: str) -> ToolResult:
        """List directory contents
        
        Args:
            path: Directory path
            
        Returns:
            List of directory contents
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/list",
            json={"path": path}
        )
        return ToolResult(**response.json())

    async def file_replace(self, file: str, old_str: str, new_str: str, sudo: bool = False) -> ToolResult:
        """Replace string in file
        
        Args:
            file: File path
            old_str: String to replace
            new_str: String to replace with
            sudo: Whether to use sudo privileges
            
        Returns:
            Result of replace operation
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/replace",
            json={
                "file": file,
                "old_str": old_str,
                "new_str": new_str,
                "sudo": sudo
            }
        )
        return ToolResult(**response.json())

    async def file_search(self, file: str, regex: str, sudo: bool = False) -> ToolResult:
        """Search in file content
        
        Args:
            file: File path
            regex: Regular expression
            sudo: Whether to use sudo privileges
            
        Returns:
            Search results
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/search",
            json={
                "file": file,
                "regex": regex,
                "sudo": sudo
            }
        )
        return ToolResult(**response.json())

    async def file_find(self, path: str, glob_pattern: str) -> ToolResult:
        """Find files by name pattern
        
        Args:
            path: Search directory path
            glob_pattern: Glob match pattern
            
        Returns:
            List of found files
        """
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/find",
            json={
                "path": path,
                "glob": glob_pattern
            }
        )
        return ToolResult(**response.json())

    async def file_upload(self, file_data: BinaryIO, path: str, filename: str = None) -> ToolResult:
        """Upload file to sandbox
        
        Args:
            file_data: File content as binary stream
            path: Target file path in sandbox
            filename: Original filename (optional)
            
        Returns:
            Upload operation result
        """
        # Prepare form data for upload
        files = {"file": (filename or "upload", file_data, "application/octet-stream")}
        data = {"path": path}
        
        response = await self.client.post(
            f"{self.base_url}/api/v1/file/upload",
            files=files,
            data=data
        )
        return ToolResult(**response.json())

    async def file_download(self, path: str) -> BinaryIO:
        """Download file from sandbox
        
        Args:
            path: File path in sandbox
            
        Returns:
            File content as binary stream
        """
        response = await self.client.get(
            f"{self.base_url}/api/v1/file/download",
            params={"path": path}
        )
        response.raise_for_status()
        
        # Return the response content as a BinaryIO stream
        # TODO: change to real stream
        return io.BytesIO(response.content)
    
    @staticmethod
    @alru_cache(maxsize=128, typed=True)
    async def _resolve_hostname_to_ip(hostname: str) -> str:
        """Resolve hostname to IP address
        
        Args:
            hostname: Hostname to resolve
            
        Returns:
            Resolved IP address, or None if resolution fails
            
        Note:
            This method is cached using LRU cache with a maximum size of 128 entries.
            The cache helps reduce repeated DNS lookups for the same hostname.
        """
        try:
            # First check if hostname is already in IP address format
            try:
                socket.inet_pton(socket.AF_INET, hostname)
                # If successfully parsed, it's an IPv4 address format, return directly
                return hostname
            except OSError:
                # Not a valid IP address format, proceed with DNS resolution
                pass
                
            # Use socket.getaddrinfo for DNS resolution
            addr_info = socket.getaddrinfo(hostname, None, family=socket.AF_INET)
            # Return the first IPv4 address found
            if addr_info and len(addr_info) > 0:
                return addr_info[0][4][0]  # Return sockaddr[0] from (family, type, proto, canonname, sockaddr), which is the IP address
            return None
        except Exception as e:
            # Log error and return None on failure
            logger.error(f"Failed to resolve hostname {hostname}: {str(e)}")
            return None
    
    async def destroy(self) -> bool:
        """Destroy Docker sandbox"""
        try:
            if self.client:
                await self.client.aclose()
            if self.container_name:
                docker_client = docker.from_env()
                docker_client.containers.get(self.container_name).remove(force=True)
            return True
        except Exception as e:
            logger.error(f"Failed to destroy Docker sandbox: {str(e)}")
            return False
    
    async def get_browser(self) -> Browser:
        """Get browser instance
        
        Args:
            llm: LLM instance used for browser automation
            
        Returns:
            Browser: Returns a configured PlaywrightBrowser instance
                    connected using the sandbox's CDP URL
        """
        return PlaywrightBrowser(self.cdp_url)

    @staticmethod
    @alru_cache(maxsize=128, typed=True)
    async def _resolve_hostname_to_ip(hostname: str) -> str:
        """Resolve hostname to IP address
        
        Args:
            hostname: Hostname to resolve
            
        Returns:
            Resolved IP address, or None if resolution fails
            
        Note:
            This method is cached using LRU cache with a maximum size of 128 entries.
            The cache helps reduce repeated DNS lookups for the same hostname.
        """
        try:
            # First check if hostname is already in IP address format
            try:
                socket.inet_pton(socket.AF_INET, hostname)
                # If successfully parsed, it's an IPv4 address format, return directly
                return hostname
            except OSError:
                # Not a valid IP address format, proceed with DNS resolution
                pass
                
            # Use socket.getaddrinfo for DNS resolution
            addr_info = socket.getaddrinfo(hostname, None, family=socket.AF_INET)
            # Return the first IPv4 address found
            if addr_info and len(addr_info) > 0:
                return addr_info[0][4][0]  # Return sockaddr[0] from (family, type, proto, canonname, sockaddr), which is the IP address
            return None
        except Exception as e:
            # Log error and return None on failure
            logger.error(f"Failed to resolve hostname {hostname}: {str(e)}")
            return None

    @classmethod
    async def create(cls) -> Sandbox:
        """Create a new sandbox instance
        
        Returns:
            New sandbox instance
        """
        settings = get_settings()

        if settings.sandbox_address:
            # Chrome CDP needs IP address
            ip = await cls._resolve_hostname_to_ip(settings.sandbox_address)
            return DockerSandbox(ip=ip)
    
        return await asyncio.to_thread(DockerSandbox._create_task)
    
    @classmethod
    @alru_cache(maxsize=128, typed=True)
    async def get(cls, id: str) -> Sandbox:
        """Get sandbox by ID
        
        Args:
            id: Sandbox ID
            
        Returns:
            Sandbox instance
        """
        settings = get_settings()
        if settings.sandbox_address:
            ip = await cls._resolve_hostname_to_ip(settings.sandbox_address)
            return DockerSandbox(ip=ip, container_name=id)

        docker_client = docker.from_env()
        container = docker_client.containers.get(id)
        container.reload()
        
        ip_address = cls._get_container_ip(container)
        logger.info(f"IP address: {ip_address}")
        return DockerSandbox(ip=ip_address, container_name=id)



================================================
FILE: backend/app/infrastructure/external/search/__init__.py
================================================
from functools import lru_cache
from typing import Optional
import logging

from app.domain.external.search import SearchEngine
from app.core.config import get_settings

logger = logging.getLogger(__name__)

@lru_cache()
def get_search_engine() -> Optional[SearchEngine]:
    """Get search engine instance based on configuration"""
    from app.infrastructure.external.search.google_search import GoogleSearchEngine
    from app.infrastructure.external.search.baidu_search import BaiduSearchEngine
    from app.infrastructure.external.search.bing_search import BingSearchEngine
    
    settings = get_settings()
    if settings.search_provider == "google":
        if settings.google_search_api_key and settings.google_search_engine_id:
            logger.info("Initializing Google Search Engine")
            return GoogleSearchEngine(
                api_key=settings.google_search_api_key,
                cx=settings.google_search_engine_id
            )
        else:
            logger.warning("Google Search Engine not initialized: missing API key or engine ID")
    elif settings.search_provider == "baidu":
        logger.info("Initializing Baidu Search Engine")
        return BaiduSearchEngine()
    elif settings.search_provider == "bing":
        logger.info("Initializing Bing Search Engine")
        return BingSearchEngine()
    else:
        logger.warning(f"Unknown search provider: {settings.search_provider}")
    
    return None 


================================================
FILE: backend/app/infrastructure/external/search/baidu_search.py
================================================
from typing import Optional
import logging
import httpx
import re
from urllib.parse import quote
from bs4 import BeautifulSoup
from app.domain.models.tool_result import ToolResult
from app.domain.models.search import SearchResults, SearchResultItem
from app.domain.external.search import SearchEngine

logger = logging.getLogger(__name__)

class BaiduSearchEngine(SearchEngine):
    """Baidu web search engine implementation using web scraping"""
    
    def __init__(self):
        """Initialize Baidu search engine"""
        self.base_url = "https://www.baidu.com/s"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36',
        }
        # Initialize cookies with the provided cookie string
        self.cookies = httpx.Cookies()
        
    async def search(
        self, 
        query: str, 
        date_range: Optional[str] = None
    ) -> ToolResult[SearchResults]:
        """Search web pages using Baidu web search
        
        Args:
            query: Search query, using 3-5 keywords
            date_range: (Optional) Time range filter for search results
            
        Returns:
            Search results
        """
        params = {
            "wd": query,
            #"pn": "0",  # Page number (0 for first page)
            #"rn": "10",  # Number of results per page
        }
        
        # Add time range filter
        if date_range and date_range != "all":
            # Convert date_range to time range parameters supported by Baidu
            date_mapping = {
                "past_day": "1",
                "past_week": "2", 
                "past_month": "3",
                "past_year": "4"
            }
            if date_range in date_mapping:
                params["gpc"] = f"stf={date_mapping[date_range]}"
        
        try:
            async with httpx.AsyncClient(headers=self.headers, cookies=self.cookies, timeout=30.0) as client:
                response = await client.get(self.base_url, params=params)
                response.raise_for_status()
                
                # Update cookies with response cookies in memory
                self.cookies.update(response.cookies)
                
                # Parse HTML content
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Extract search results
                search_results = []
                
                # Try different selectors for Baidu search results
                result_divs = soup.find_all('div', class_='result') or \
                             soup.find_all('div', class_='result-op') or \
                             soup.find_all('div', class_='c-container') or \
                             soup.find_all('div', attrs={'mu': True}) or \
                             soup.find_all('div', attrs={'data-log': True})
                
                for div in result_divs:
                    try:
                        # Extract title - try multiple approaches
                        title = ""
                        link = ""
                        
                        # Method 1: Standard h3 > a structure
                        title_tag = div.find('h3')
                        if title_tag:
                            title_a = title_tag.find('a')
                            if title_a:
                                title = title_a.get_text(strip=True)
                                link = title_a.get('href', '')
                        
                        # Method 2: Try direct a tag with title-like classes
                        if not title:
                            title_links = div.find_all('a', class_=re.compile(r'title|link'))
                            for a in title_links:
                                if a.get_text(strip=True):
                                    title = a.get_text(strip=True)
                                    link = a.get('href', '')
                                    break
                        
                        # Method 3: Try any a tag with substantial text
                        if not title:
                            all_links = div.find_all('a')
                            for a in all_links:
                                text = a.get_text(strip=True)
                                if len(text) > 10 and not text.startswith('http'):
                                    title = text
                                    link = a.get('href', '')
                                    break
                        
                        if not title:
                            continue
                        
                        # Extract snippet - try multiple approaches
                        snippet = ""
                        
                        # Method 1: Look for abstract/content classes
                        snippet_divs = div.find_all(['div', 'span'], class_=re.compile(r'abstract|content|desc'))
                        if snippet_divs:
                            snippet = snippet_divs[0].get_text(strip=True)
                        
                        # Method 2: Look for common text containers
                        if not snippet:
                            text_containers = div.find_all(['div', 'span', 'p'], class_=re.compile(r'c-span|c-abstract'))
                            for container in text_containers:
                                text = container.get_text(strip=True)
                                if len(text) > 20:
                                    snippet = text
                                    break
                        
                        # Method 3: Get any substantial text from the div
                        if not snippet:
                            all_text = div.get_text(strip=True)
                            # Extract first sentence-like text
                            sentences = re.split(r'[。！？\n]', all_text)
                            for sentence in sentences:
                                if len(sentence.strip()) > 20:
                                    snippet = sentence.strip()
                                    break
                        
                        # Clean up the link if it's a Baidu redirect
                        if link.startswith('/link?url='):
                            url_match = re.search(r'url=([^&]+)', link)
                            if url_match:
                                link = url_match.group(1)
                        elif link.startswith('/'):
                            link = 'https://www.baidu.com' + link
                        
                        if title and link:
                            search_results.append(SearchResultItem(
                                title=title,
                                link=link,
                                snippet=snippet
                            ))
                    except Exception as e:
                        logger.warning(f"Failed to parse search result: {e}")
                        continue
                
                # Extract total results count
                total_results = 0
                results_nums = soup.find_all(string=re.compile(r'百度为您找到相关结果约'))
                if results_nums:
                    match = re.search(r'约([\d,]+)个结果', results_nums[0])
                    if match:
                        try:
                            total_results = int(match.group(1).replace(',', ''))
                        except ValueError:
                            total_results = 0
                
                # Build return result
                results = SearchResults(
                    query=query,
                    date_range=date_range,
                    total_results=total_results,
                    results=search_results
                )
                
                return ToolResult(success=True, data=results)
                
        except Exception as e:
            logger.error(f"Baidu Search failed: {e}")
            error_results = SearchResults(
                query=query,
                date_range=date_range,
                total_results=0,
                results=[]
            )
            
            return ToolResult(
                success=False,
                message=f"Baidu Search failed: {e}",
                data=error_results
            )


# Simple test
if __name__ == "__main__":
    import asyncio
    
    async def test():
        search_engine = BaiduSearchEngine()
        result = await search_engine.search("Python 编程")
        
        if result.success:
            print(f"Search successful! Found {len(result.data.results)} results")
            for i, item in enumerate(result.data.results[:3]):
                print(f"{i+1}. {item.title}")
                print(f"   {item.link}")
                print()
        else:
            print(f"Search failed: {result.message}")
    
    asyncio.run(test())


================================================
FILE: backend/app/infrastructure/external/search/bing_search.py
================================================
from typing import Optional
import logging
import httpx
import re
from urllib.parse import quote
from bs4 import BeautifulSoup
from app.domain.models.tool_result import ToolResult
from app.domain.models.search import SearchResults, SearchResultItem
from app.domain.external.search import SearchEngine

logger = logging.getLogger(__name__)

class BingSearchEngine(SearchEngine):
    """Bing web search engine implementation using web scraping"""
    
    def __init__(self):
        """Initialize Bing search engine"""
        self.base_url = "https://www.bing.com/search"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        }
        # Initialize cookies to maintain session state
        self.cookies = httpx.Cookies()
        
    async def search(
        self, 
        query: str, 
        date_range: Optional[str] = None
    ) -> ToolResult[SearchResults]:
        """Search web pages using Bing web search
        
        Args:
            query: Search query, using 3-5 keywords
            date_range: (Optional) Time range filter for search results
            
        Returns:
            Search results
        """
        params = {
            "q": query,
            "count": "20",  # Number of results per page
            "first": "1",   # Starting position (1-based)
        }
        
        # Add time range filter
        if date_range and date_range != "all":
            # Convert date_range to time range parameters supported by Bing
            date_mapping = {
                "past_hour": "interval%3d%22Hour%22",
                "past_day": "interval%3d%22Day%22", 
                "past_week": "interval%3d%22Week%22",
                "past_month": "interval%3d%22Month%22",
                "past_year": "interval%3d%22Year%22"
            }
            if date_range in date_mapping:
                params["filters"] = date_mapping[date_range]
        
        try:
            async with httpx.AsyncClient(headers=self.headers, cookies=self.cookies, timeout=30.0, follow_redirects=True) as client:
                response = await client.get(self.base_url, params=params)
                response.raise_for_status()
                
                # Update cookies with response cookies in memory
                self.cookies.update(response.cookies)
                
                # Parse HTML content
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Extract search results
                search_results = []
                
                # Bing search results are in li elements with class 'b_algo'
                result_items = soup.find_all('li', class_='b_algo')
                
                for item in result_items:
                    try:
                        # Extract title and link
                        title = ""
                        link = ""
                        
                        # Title is usually in h2 > a
                        title_tag = item.find('h2')
                        if title_tag:
                            title_a = title_tag.find('a')
                            if title_a:
                                title = title_a.get_text(strip=True)
                                link = title_a.get('href', '')
                        
                        # If not found, try other structures
                        if not title:
                            title_links = item.find_all('a')
                            for a in title_links:
                                text = a.get_text(strip=True)
                                if len(text) > 10 and not text.startswith('http'):
                                    title = text
                                    link = a.get('href', '')
                                    break
                        
                        if not title:
                            continue
                        
                        # Extract snippet
                        snippet = ""
                        
                        # Look for description in p tag with class 'b_lineclamp*' or 'b_descript'
                        snippet_tags = item.find_all(['p', 'div'], class_=re.compile(r'b_lineclamp|b_descript|b_caption'))
                        if snippet_tags:
                            snippet = snippet_tags[0].get_text(strip=True)
                        
                        # If not found, look for any p tag with substantial text
                        if not snippet:
                            all_p_tags = item.find_all('p')
                            for p in all_p_tags:
                                text = p.get_text(strip=True)
                                if len(text) > 20:
                                    snippet = text
                                    break
                        
                        # If still not found, get any substantial text from the item
                        if not snippet:
                            all_text = item.get_text(strip=True)
                            # Extract first sentence-like text that's not the title
                            sentences = re.split(r'[.!?\n]', all_text)
                            for sentence in sentences:
                                clean_sentence = sentence.strip()
                                if len(clean_sentence) > 20 and clean_sentence != title:
                                    snippet = clean_sentence
                                    break
                        
                        # Clean up link if needed
                        if link and not link.startswith('http'):
                            if link.startswith('//'):
                                link = 'https:' + link
                            elif link.startswith('/'):
                                link = 'https://www.bing.com' + link
                        
                        if title and link:
                            search_results.append(SearchResultItem(
                                title=title,
                                link=link,
                                snippet=snippet
                            ))
                    except Exception as e:
                        logger.warning(f"Failed to parse Bing search result: {e}")
                        continue
                
                # Extract total results count
                total_results = 0
                # Bing shows result count in various places, try to find it
                result_stats = soup.find_all(string=re.compile(r'\d+[,\d]*\s*results?'))
                if result_stats:
                    for stat in result_stats:
                        match = re.search(r'([\d,]+)\s*results?', stat)
                        if match:
                            try:
                                total_results = int(match.group(1).replace(',', ''))
                                break
                            except ValueError:
                                continue
                
                # Also try looking in the search results count area
                if total_results == 0:
                    count_elements = soup.find_all(['span', 'div'], class_=re.compile(r'sb_count|b_focusTextMedium'))
                    for elem in count_elements:
                        text = elem.get_text()
                        match = re.search(r'([\d,]+)\s*results?', text)
                        if match:
                            try:
                                total_results = int(match.group(1).replace(',', ''))
                                break
                            except ValueError:
                                continue
                
                # Build return result
                results = SearchResults(
                    query=query,
                    date_range=date_range,
                    total_results=total_results,
                    results=search_results
                )
                
                return ToolResult(success=True, data=results)
                
        except Exception as e:
            logger.error(f"Bing Search failed: {e}")
            error_results = SearchResults(
                query=query,
                date_range=date_range,
                total_results=0,
                results=[]
            )
            
            return ToolResult(
                success=False,
                message=f"Bing Search failed: {e}",
                data=error_results
            )


# Simple test
if __name__ == "__main__":
    import asyncio
    
    async def test():
        search_engine = BingSearchEngine()
        result = await search_engine.search("Python programming")
        
        if result.success:
            print(f"Search successful! Found {len(result.data.results)} results")
            for i, item in enumerate(result.data.results[:3]):
                print(f"{i+1}. {item.title}")
                print(f"   {item.link}")
                print(f"   {item.snippet}")
                print()
        else:
            print(f"Search failed: {result.message}")
    
    asyncio.run(test())



================================================
FILE: backend/app/infrastructure/external/search/google_search.py
================================================
from typing import Optional
import logging
import httpx
from app.domain.models.tool_result import ToolResult
from app.domain.models.search import SearchResults, SearchResultItem
from app.domain.external.search import SearchEngine

logger = logging.getLogger(__name__)

class GoogleSearchEngine(SearchEngine):
    """Google API based search engine implementation"""
    
    def __init__(self, api_key: str, cx: str):
        """Initialize Google search engine
        
        Args:
            api_key: Google Custom Search API key
            cx: Google Search Engine ID
        """
        self.api_key = api_key
        self.cx = cx
        self.base_url = "https://www.googleapis.com/customsearch/v1"
        
    async def search(
        self, 
        query: str, 
        date_range: Optional[str] = None
    ) -> ToolResult[SearchResults]:
        """Search web pages using Google API
        
        Args:
            query: Search query, Google search style, use 3-5 keywords
            date_range: (Optional) Time range filter for search results
            
        Returns:
            Search results
        """
        params = {
            "key": self.api_key,
            "cx": self.cx,
            "q": query
        }
        
        # Add time range filter
        if date_range and date_range != "all":
            # Convert date_range to time range parameters supported by Google API
            # For example: via dateRestrict parameter (d[number]: day, w[number]: week, m[number]: month, y[number]: year)
            date_mapping = {
                "past_hour": "d1",
                "past_day": "d1", 
                "past_week": "w1",
                "past_month": "m1",
                "past_year": "y1"
            }
            if date_range in date_mapping:
                params["dateRestrict"] = date_mapping[date_range]
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(self.base_url, params=params)
                response.raise_for_status()
                data = response.json()
                
                # Process search results
                search_results = []
                if "items" in data:
                    for item in data["items"]:
                        search_results.append(SearchResultItem(
                            title=item.get("title", ""),
                            link=item.get("link", ""),
                            snippet=item.get("snippet", "")
                        ))
                
                # Build return result
                search_info_data = data.get("searchInformation", {})
                
                # Convert total_results to int
                total_results_str = search_info_data.get("totalResults", "0")
                try:
                    total_results = int(total_results_str)
                except (ValueError, TypeError):
                    total_results = 0
                
                results = SearchResults(
                    query=query,
                    date_range=date_range,
                    total_results=total_results,
                    results=search_results
                )
                
                return ToolResult(success=True, data=results)
                
        except Exception as e:
            logger.error(f"Google Search API call failed: {e}")
            error_results = SearchResults(
                query=query,
                date_range=date_range,
                total_results=0,
                results=[]
            )
            
            return ToolResult(
                success=False,
                message=f"Google Search API call failed: {e}",
                data=error_results
            )



================================================
FILE: backend/app/infrastructure/external/task/redis_task.py
================================================
import asyncio
import uuid
import logging
from typing import Optional, Dict

from app.domain.external.task import Task, TaskRunner
from app.infrastructure.external.message_queue.redis_stream_queue import RedisStreamQueue, MessageQueue

logger = logging.getLogger(__name__)


class RedisStreamTask(Task):
    """Redis Stream-based task implementation following the Task protocol."""
    
    _task_registry: Dict[str, 'RedisStreamTask'] = {}
    
    def __init__(self, runner: TaskRunner):
        """Initialize Redis Stream task with a task runner.
        
        Args:
            runner: The TaskRunner instance that will execute this task
        """
        self._runner = runner
        self._id = str(uuid.uuid4())
        self._execution_task: Optional[asyncio.Task] = None
        
        # Create input/output streams based on task ID
        input_stream_name = f"task:input:{self._id}"
        output_stream_name = f"task:output:{self._id}"
        self._input_stream = RedisStreamQueue(input_stream_name)
        self._output_stream = RedisStreamQueue(output_stream_name)
        
        # Register task instance
        RedisStreamTask._task_registry[self._id] = self
        
    @property
    def id(self) -> str:
        """Task ID."""
        return self._id
    
    @property
    def done(self) -> bool:
        """Check if the task is done.

        Returns:
            bool: True if the task is done, False otherwise
        """
        if self._execution_task is None:
            return True
        return self._execution_task.done()
    
    async def run(self) -> None:
        """Run the task using the provided TaskRunner."""
        if self.done:
            self._execution_task = asyncio.create_task(self._execute_task())
            logger.info(f"Task {self._id} execution started")
    
    def cancel(self) -> bool:
        """Cancel the task.

        Returns:
            bool: True if the task is cancelled, False otherwise
        """
        if not self.done:
            self._execution_task.cancel()
            logger.info(f"Task {self._id} cancelled")
            self._cleanup_registry()
            return True
        
        self._cleanup_registry()
        return False
    
    @property
    def input_stream(self) -> MessageQueue:
        """Input stream."""
        return self._input_stream
    
    @property
    def output_stream(self) -> MessageQueue:
        """Output stream."""
        return self._output_stream
    
    def _on_task_done(self) -> None:
        """Called when the task is done."""
        self._task_done = True
        if self._runner:
            asyncio.create_task(self._runner.on_done(self))
        self._cleanup_registry()
    
    def _cleanup_registry(self) -> None:
        """Remove this task from the registry."""
        if self._id in RedisStreamTask._task_registry:
            del RedisStreamTask._task_registry[self._id]
            logger.info(f"Task {self._id} removed from registry")
    
    async def _execute_task(self):
        """Execute the task using the TaskRunner."""
        try:
            await self._runner.run(self)
        except asyncio.CancelledError:
            logger.info(f"Task {self._id} execution cancelled")
        except Exception as e:
            logger.error(f"Task {self._id} execution failed: {str(e)}")
        finally:
            self._on_task_done()
    
    @classmethod
    def get(cls, task_id: str) -> Optional['RedisStreamTask']:
        """Get a task by its ID.

        Returns:
            Optional[RedisStreamTask]: Task instance if found, None otherwise
        """
        return cls._task_registry.get(task_id)
    
    @classmethod
    def create(cls, runner: TaskRunner) -> "RedisStreamTask":
        """Create a new task instance with the specified TaskRunner.

        Args:
            runner: The TaskRunner that will execute this task

        Returns:
            RedisStreamTask: New task instance
        """
        return cls(runner)

    @classmethod
    async def destroy(cls) -> None:
        """Destroy all task instances."""
        for task_id in cls._task_registry:
            task = cls._task_registry[task_id]
            task.cancel()
            if task._runner:
                await task._runner.destroy()
        cls._task_registry.clear()
    
    def __repr__(self) -> str:
        """String representation of the task."""
        return f"RedisStreamTask(id={self._id}, done={self.done})"


================================================
FILE: backend/app/infrastructure/models/documents.py
================================================
from typing import Dict, Optional, List, Type, TypeVar, Generic, get_args, Self
from datetime import datetime, timezone, UTC
from beanie import Document
from pydantic import BaseModel
from app.domain.models.agent import Agent
from app.domain.models.memory import Memory
from app.domain.models.event import AgentEvent
from app.domain.models.session import Session, SessionStatus
from app.domain.models.file import FileInfo
from app.domain.models.user import User, UserRole
from pymongo import IndexModel, ASCENDING

T = TypeVar('T', bound=BaseModel)

class BaseDocument(Document, Generic[T]):
    def __init_subclass__(cls, id_field="id", domain_model_class: Type[T] = None, **kwargs):
        super().__init_subclass__(**kwargs)
        cls._ID_FIELD = id_field
        cls._DOMAIN_MODEL_CLASS = domain_model_class
    
    def update_from_domain(self, domain_obj: T) -> None:
        """Update the document from domain model"""
        data = domain_obj.model_dump(exclude={'id', 'created_at'})
        data[self._ID_FIELD] = domain_obj.id
        if hasattr(self, 'updated_at'):
            data['updated_at'] = datetime.now(UTC)
        
        for field, value in data.items():
            setattr(self, field, value)
    
    def to_domain(self) -> T:
        """Convert MongoDB document to domain model"""
        # Convert to dict and map agent_id to id field
        data = self.model_dump(exclude={'id'})
        data['id'] = data.pop(self._ID_FIELD)
        return self._DOMAIN_MODEL_CLASS.model_validate(data)
    
    @classmethod
    def from_domain(cls, domain_obj: T) -> Self:
        """Create a new MongoDB agent from domain"""
        # Convert to dict and map id to agent_id field
        data = domain_obj.model_dump()
        data[cls._ID_FIELD] = data.pop('id')
        return cls.model_validate(data)

class UserDocument(BaseDocument[User], id_field="user_id", domain_model_class=User):
    """MongoDB document for User"""
    user_id: str
    fullname: str
    email: str  # Now required field for login
    password_hash: Optional[str] = None
    role: UserRole = UserRole.USER
    is_active: bool = True
    created_at: datetime = datetime.now(timezone.utc)
    updated_at: datetime = datetime.now(timezone.utc)
    last_login_at: Optional[datetime] = None

    class Settings:
        name = "users"
        indexes = [
            "user_id",
            "fullname",  # Keep fullname index but not unique
            IndexModel([("email", ASCENDING)], unique=True),  # Email as unique index
        ]

class AgentDocument(BaseDocument[Agent], id_field="agent_id", domain_model_class=Agent):
    """MongoDB document for Agent"""
    agent_id: str
    model_name: str
    temperature: float
    max_tokens: int
    memories: Dict[str, Memory] = {}
    created_at: datetime = datetime.now(timezone.utc)
    updated_at: datetime = datetime.now(timezone.utc)

    class Settings:
        name = "agents"
        indexes = [
            "agent_id",
        ]


class SessionDocument(BaseDocument[Session], id_field="session_id", domain_model_class=Session):
    """MongoDB model for Session"""
    session_id: str
    user_id: str  # User ID that owns this session
    sandbox_id: Optional[str] = None
    agent_id: str
    task_id: Optional[str] = None
    title: Optional[str] = None
    unread_message_count: int = 0
    latest_message: Optional[str] = None
    latest_message_at: Optional[datetime] = None
    created_at: datetime = datetime.now(timezone.utc)
    updated_at: datetime = datetime.now(timezone.utc)
    events: List[AgentEvent]
    status: SessionStatus
    files: List[FileInfo] = []
    class Settings:
        name = "sessions"
        indexes = [
            "session_id",
            "user_id",  # Add index for user_id for efficient queries
        ]


================================================
FILE: backend/app/infrastructure/repositories/file_mcp_repository.py
================================================
import os
import logging
from app.domain.repositories.mcp_repository import MCPRepository
from app.domain.models.mcp_config import MCPConfig
from app.core.config import get_settings

logger = logging.getLogger(__name__)

class FileMCPRepository(MCPRepository):
    """Repository for MCP config stored in a file"""
    
    async def get_mcp_config(self) -> MCPConfig:
        """Get the MCP config from the file"""
        file_path = get_settings().mcp_config_path
        if not os.path.exists(file_path):
            return MCPConfig(mcpServers={})
        try:
            with open(file_path, "r") as file:
                return MCPConfig.model_validate_json(file.read())
        except Exception as e:
            logger.exception(f"Error reading MCP config file: {e}")
        
        return MCPConfig(mcpServers={})


================================================
FILE: backend/app/infrastructure/repositories/mongo_agent_repository.py
================================================
from typing import Optional, List
from datetime import datetime, UTC
from app.domain.models.agent import Agent
from app.domain.models.memory import Memory
from app.domain.repositories.agent_repository import AgentRepository
from app.infrastructure.models.documents import AgentDocument
import logging


logger = logging.getLogger(__name__)

class MongoAgentRepository(AgentRepository):
    """MongoDB implementation of AgentRepository"""

    async def save(self, agent: Agent) -> None:
        """Save or update an agent"""
        mongo_agent = await AgentDocument.find_one(
            AgentDocument.agent_id == agent.id
        )
        
        if not mongo_agent:
            mongo_agent = AgentDocument.from_domain(agent)
            await mongo_agent.save()
            return
        
        # Update fields from agent domain model
        mongo_agent.update_from_domain(agent)
        await mongo_agent.save()

    async def find_by_id(self, agent_id: str) -> Optional[Agent]:
        """Find an agent by its ID"""
        mongo_agent = await AgentDocument.find_one(
            AgentDocument.agent_id == agent_id
        )
        return mongo_agent.to_domain() if mongo_agent else None

    async def add_memory(self, agent_id: str,
                          name: str,
                          memory: Memory) -> None:
        """Add or update a memory for an agent"""
        result = await AgentDocument.find_one(
            AgentDocument.agent_id == agent_id
        ).update(
            {"$set": {f"memories.{name}": memory, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Agent {agent_id} not found")

    async def get_memory(self, agent_id: str, name: str) -> Memory:
        """Get memory by name from agent, create if not exists"""
        mongo_agent = await AgentDocument.find_one(
            AgentDocument.agent_id == agent_id
        )
        if not mongo_agent:
            raise ValueError(f"Agent {agent_id} not found")
        return mongo_agent.memories.get(name, Memory(messages=[]))
    
    async def save_memory(self, agent_id: str, name: str, memory: Memory) -> None:
        """Update the messages of a memory"""
        result = await AgentDocument.find_one(
            AgentDocument.agent_id == agent_id
        ).update(
            {"$set": {f"memories.{name}": memory, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Agent {agent_id} not found")



================================================
FILE: backend/app/infrastructure/repositories/mongo_session_repository.py
================================================
from typing import Optional, List
from datetime import datetime, UTC
from app.domain.models.session import Session, SessionStatus
from app.domain.models.file import FileInfo
from app.domain.repositories.session_repository import SessionRepository
from app.domain.models.event import BaseEvent
from app.infrastructure.models.documents import SessionDocument
import logging

logger = logging.getLogger(__name__)

class MongoSessionRepository(SessionRepository):
    """MongoDB implementation of SessionRepository"""
    
    async def save(self, session: Session) -> None:
        """Save or update a session"""
        mongo_session = await SessionDocument.find_one(
            SessionDocument.session_id == session.id
        )
        
        if not mongo_session:
            mongo_session = SessionDocument.from_domain(session)
            await mongo_session.save()
            return
        
        # Update fields from session domain model
        mongo_session.update_from_domain(session)
        await mongo_session.save()


    async def find_by_id(self, session_id: str) -> Optional[Session]:
        """Find a session by its ID"""
        mongo_session = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        )
        return mongo_session.to_domain() if mongo_session else None
    
    async def find_by_user_id(self, user_id: str) -> List[Session]:
        """Find all sessions for a specific user"""
        mongo_sessions = await SessionDocument.find(
            SessionDocument.user_id == user_id
        ).sort("-latest_message_at").to_list()
        return [mongo_session.to_domain() for mongo_session in mongo_sessions]
    
    async def find_by_id_and_user_id(self, session_id: str, user_id: str) -> Optional[Session]:
        """Find a session by ID and user ID (for authorization)"""
        mongo_session = await SessionDocument.find_one(
            SessionDocument.session_id == session_id,
            SessionDocument.user_id == user_id
        )
        return mongo_session.to_domain() if mongo_session else None
    
    async def update_title(self, session_id: str, title: str) -> None:
        """Update the title of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$set": {"title": title, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def update_latest_message(self, session_id: str, message: str, timestamp: datetime) -> None:
        """Update the latest message of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$set": {"latest_message": message, "latest_message_at": timestamp, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def add_event(self, session_id: str, event: BaseEvent) -> None:
        """Add an event to a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$push": {"events": event.model_dump()}, "$set": {"updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")
    
    async def add_file(self, session_id: str, file_info: FileInfo) -> None:
        """Add a file to a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$push": {"files": file_info.model_dump()}, "$set": {"updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")
    
    async def remove_file(self, session_id: str, file_id: str) -> None:
        """Remove a file from a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$pull": {"files": {"file_id": file_id}}, "$set": {"updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def get_file_by_path(self, session_id: str, file_path: str) -> Optional[FileInfo]:
        """Get file by path from a session"""
        mongo_session = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        )
        if not mongo_session:
            raise ValueError(f"Session {session_id} not found")
        
        # Search for file with matching path
        for file_info in mongo_session.files:
            if file_info.file_path == file_path:
                return file_info
        return None

    async def delete(self, session_id: str) -> None:
        """Delete a session"""
        mongo_session = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        )
        if mongo_session:
            await mongo_session.delete()

    async def get_all(self) -> List[Session]:
        """Get all sessions"""
        mongo_sessions = await SessionDocument.find().sort("-latest_message_at").to_list()
        return [mongo_session.to_domain() for mongo_session in mongo_sessions]
    
    async def update_status(self, session_id: str, status: SessionStatus) -> None:
        """Update the status of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$set": {"status": status, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def update_unread_message_count(self, session_id: str, count: int) -> None:
        """Update the unread message count of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$set": {"unread_message_count": count, "updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def increment_unread_message_count(self, session_id: str) -> None:
        """Atomically increment the unread message count of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$inc": {"unread_message_count": 1}, "$set": {"updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")

    async def decrement_unread_message_count(self, session_id: str) -> None:
        """Atomically decrement the unread message count of a session"""
        result = await SessionDocument.find_one(
            SessionDocument.session_id == session_id
        ).update(
            {"$inc": {"unread_message_count": -1}, "$set": {"updated_at": datetime.now(UTC)}}
        )
        if not result:
            raise ValueError(f"Session {session_id} not found")




================================================
FILE: backend/app/infrastructure/repositories/user_repository.py
================================================
from typing import List, Optional
from beanie import WriteRules
from app.domain.models.user import User
from app.domain.repositories.user_repository import UserRepository
from app.infrastructure.models.documents import UserDocument
import logging

logger = logging.getLogger(__name__)


class MongoUserRepository(UserRepository):
    """MongoDB implementation of UserRepository"""
    
    async def create_user(self, user: User) -> User:
        """Create a new user"""
        logger.info(f"Creating user: {user.fullname}")
        
        # Convert domain model to document
        user_doc = UserDocument.from_domain(user)
        
        # Save to database
        await user_doc.create()
        
        # Convert back to domain model
        result = user_doc.to_domain()
        logger.info(f"User created successfully: {result.id}")
        return result
    
    async def get_user_by_id(self, user_id: str) -> Optional[User]:
        """Get user by ID"""
        logger.debug(f"Getting user by ID: {user_id}")
        
        user_doc = await UserDocument.find_one(UserDocument.user_id == user_id)
        if not user_doc:
            logger.debug(f"User not found: {user_id}")
            return None
        
        return user_doc.to_domain()
    
    async def get_user_by_fullname(self, fullname: str) -> Optional[User]:
        """Get user by fullname"""
        logger.debug(f"Getting user by fullname: {fullname}")
        
        user_doc = await UserDocument.find_one(UserDocument.fullname == fullname)
        if not user_doc:
            logger.debug(f"User not found: {fullname}")
            return None
        
        return user_doc.to_domain()
    
    async def get_user_by_email(self, email: str) -> Optional[User]:
        """Get user by email"""
        logger.debug(f"Getting user by email: {email}")
        
        user_doc = await UserDocument.find_one(UserDocument.email == email.lower())
        if not user_doc:
            logger.debug(f"User not found: {email}")
            return None
        
        return user_doc.to_domain()
    
    async def update_user(self, user: User) -> User:
        """Update user information"""
        logger.info(f"Updating user: {user.id}")
        
        # Find existing document
        user_doc = await UserDocument.find_one(UserDocument.user_id == user.id)
        if not user_doc:
            raise ValueError(f"User not found: {user.id}")
        
        # Update document from domain model
        user_doc.update_from_domain(user)
        
        # Save to database
        await user_doc.save()
        
        # Convert back to domain model
        result = user_doc.to_domain()
        logger.info(f"User updated successfully: {result.id}")
        return result
    
    async def delete_user(self, user_id: str) -> bool:
        """Delete user by ID"""
        logger.info(f"Deleting user: {user_id}")
        
        user_doc = await UserDocument.find_one(UserDocument.user_id == user_id)
        if not user_doc:
            logger.warning(f"User not found for deletion: {user_id}")
            return False
        
        await user_doc.delete()
        logger.info(f"User deleted successfully: {user_id}")
        return True
    
    async def list_users(self, limit: int = 100, offset: int = 0) -> List[User]:
        """List users with pagination"""
        logger.debug(f"Listing users: limit={limit}, offset={offset}")
        
        user_docs = await UserDocument.find().skip(offset).limit(limit).to_list()
        
        users = [doc.to_domain() for doc in user_docs]
        logger.debug(f"Found {len(users)} users")
        return users
    
    async def fullname_exists(self, fullname: str) -> bool:
        """Check if fullname exists"""
        logger.debug(f"Checking if fullname exists: {fullname}")
        
        user_doc = await UserDocument.find_one(UserDocument.fullname == fullname)
        exists = user_doc is not None
        logger.debug(f"Fullname exists: {exists}")
        return exists
    
    async def email_exists(self, email: str) -> bool:
        """Check if email exists"""
        logger.debug(f"Checking if email exists: {email}")
        
        user_doc = await UserDocument.find_one(UserDocument.email == email.lower())
        exists = user_doc is not None
        logger.debug(f"Email exists: {exists}")
        return exists 


================================================
FILE: backend/app/infrastructure/storage/mongodb.py
================================================
from motor.motor_asyncio import AsyncIOMotorClient
from pymongo.errors import ConnectionFailure
from typing import Optional
import logging
from app.core.config import get_settings
from functools import lru_cache

logger = logging.getLogger(__name__)

class MongoDB:
    def __init__(self):
        self._client: Optional[AsyncIOMotorClient] = None
        self._settings = get_settings()
    
    async def initialize(self) -> None:
        """Initialize MongoDB connection and Beanie ODM."""
        if self._client is not None:
            return
            
        try:
            # Connect to MongoDB
            if self._settings.mongodb_username and self._settings.mongodb_password:
                # Use authenticated connection if username and password are configured
                self._client = AsyncIOMotorClient(
                    self._settings.mongodb_uri,
                    username=self._settings.mongodb_username,
                    password=self._settings.mongodb_password,
                )
            else:
                # Use unauthenticated connection if no credentials are provided
                self._client = AsyncIOMotorClient(
                    self._settings.mongodb_uri,
                )
            # Verify the connection
            await self._client.admin.command('ping')
            logger.info("Successfully connected to MongoDB")
        except ConnectionFailure as e:
            logger.error(f"Failed to connect to MongoDB: {str(e)}")
            raise
        except Exception as e:
            logger.error(f"Failed to initialize Beanie: {str(e)}")
            raise
    
    async def shutdown(self) -> None:
        """Shutdown MongoDB connection."""
        if self._client is not None:
            self._client.close()
            self._client = None
            logger.info("Disconnected from MongoDB")
                # Clear cache for this module
        get_mongodb.cache_clear()
    
    @property
    def client(self) -> AsyncIOMotorClient:
        """Return initialized MongoDB client"""
        if self._client is None:
            raise RuntimeError("MongoDB client not initialized. Call initialize() first.")
        return self._client


@lru_cache()
def get_mongodb() -> MongoDB:
    """Get the MongoDB instance."""
    return MongoDB()




================================================
FILE: backend/app/infrastructure/storage/redis.py
================================================
from redis.asyncio import Redis
import logging
from app.core.config import get_settings

logger = logging.getLogger(__name__)

class RedisClient:
    def __init__(self):
        self._client: Redis | None = None
        self._settings = get_settings()
    
    async def initialize(self) -> None:
        """Initialize Redis connection."""
        if self._client is not None:
            return
            
        try:
            # Connect to Redis
            self._client = Redis(
                host=self._settings.redis_host,
                port=self._settings.redis_port,
                db=self._settings.redis_db,
                password=self._settings.redis_password,
                decode_responses=True
            )
            # Verify the connection
            await self._client.ping()
            logger.info("Successfully connected to Redis")
        except Exception as e:
            logger.error(f"Failed to connect to Redis: {str(e)}")
            raise
    
    async def shutdown(self) -> None:
        """Shutdown Redis connection."""
        if self._client is not None:
            await self._client.close()
            self._client = None
            logger.info("Disconnected from Redis")
                # Clear cache for this module
        get_redis.cache_clear()
    
    @property
    def client(self) -> Redis:
        """Return initialized Redis client"""
        if self._client is None:
            raise RuntimeError("Redis client not initialized. Call initialize() first.")
        return self._client

from functools import lru_cache

@lru_cache()
def get_redis() -> RedisClient:
    """Get the Redis client instance."""
    return RedisClient() 


================================================
FILE: backend/app/infrastructure/utils/llm_json_parser.py
================================================
import json
import re
from typing import Any, Dict, List, Optional, Union
from enum import Enum
import logging

from app.domain.utils.json_parser import JsonParser
from app.infrastructure.external.llm.openai_llm import OpenAILLM


logger = logging.getLogger(__name__)

class ParseStrategy(Enum):
    """JSON parsing strategy enumeration"""
    DIRECT = "direct"
    MARKDOWN_BLOCK = "markdown_block"
    REGEX_EXTRACT = "regex_extract"
    CLEANUP_AND_PARSE = "cleanup_and_parse"
    LLM_EXTRACT_AND_FIX = "llm_extract_and_fix"


class LLMJsonParser(JsonParser):
    """
    A robust parser for converting LLM string output to JSON.
    Handles various formats including markdown code blocks, malformed JSON, etc.
    Inherits from domain JsonParser interface and uses LLM when needed.
    """
    
    def __init__(self):
        self.llm = OpenAILLM()
        self.strategies = [
            self._try_direct_parse,
            self._try_markdown_block_parse,
            #self._try_regex_extract,
            self._try_cleanup_and_parse,
            self._try_llm_extract_and_fix,
        ]
    
    async def parse(self, text: str, default_value: Optional[Any] = None) -> Union[Dict, List, Any]:
        """
        Parse LLM output string to JSON using multiple strategies.
        Falls back to LLM parsing if local strategies fail.
        
        Args:
            text: The raw string output from LLM
            default_value: Default value to return if parsing fails
            
        Returns:
            Parsed JSON object (dict, list, or other JSON-serializable type)
            
        Raises:
            ValueError: If all parsing strategies fail and no default value provided
        """

        logger.info(f"Parsing text: {text}")
        if not text or not text.strip():
            if default_value is not None:
                return default_value
            raise ValueError("Empty input string")
        
        cleaned_output = text.strip()
        
        # Try each parsing strategy
        for strategy in self.strategies:
            try:
                result = await strategy(cleaned_output)
                if result is not None:
                    logger.info(f"Successfully parsed using strategy: {strategy.__name__}")
                    return result
            except Exception as e:
                logger.warning(f"Strategy {strategy.__name__} failed: {str(e)}")
                continue
        
        # If all strategies fail
        if default_value is not None:
            logger.warning("All parsing strategies failed, returning default value")
            return default_value
        
        raise ValueError(f"Failed to parse JSON from LLM output: {text[:1000]}...")
    
    async def _try_direct_parse(self, text: str) -> Optional[Any]:
        """Try to parse the text directly as JSON"""
        return json.loads(text)
    
    async def _try_markdown_block_parse(self, text: str) -> Optional[Any]:
        """Extract and parse JSON from markdown code blocks"""
        # Pattern to match JSON in markdown code blocks
        patterns = [
            r'```json\s*\n(.*?)\n```',
            r'```\s*\n(.*?)\n```',
            r'`([^`]*)`',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, text, re.DOTALL | re.IGNORECASE)
            for match in matches:
                try:
                    return json.loads(match.strip())
                except json.JSONDecodeError:
                    continue
        
        return None
    
    async def _try_regex_extract(self, text: str) -> Optional[Any]:
        """Extract JSON using regex patterns"""
        # Look for JSON object patterns
        json_patterns = [
            r'\{.*\}',  # Object
            r'\[.*\]',  # Array
        ]
        
        for pattern in json_patterns:
            matches = re.findall(pattern, text, re.DOTALL)
            for match in matches:
                try:
                    return json.loads(match)
                except json.JSONDecodeError:
                    continue
        
        return None
    
    async def _try_cleanup_and_parse(self, text: str) -> Optional[Any]:
        """Clean up common formatting issues and try parsing"""
        # Remove common prefixes/suffixes
        prefixes = ["json:", "result:", "output:", "response:"]
        suffixes = [".", "..."]
        
        cleaned = text
        
        # Remove prefixes
        for prefix in prefixes:
            if cleaned.lower().startswith(prefix.lower()):
                cleaned = cleaned[len(prefix):].strip()
        
        # Remove suffixes
        for suffix in suffixes:
            if cleaned.endswith(suffix):
                cleaned = cleaned[:-len(suffix)].strip()
        
        # Fix common JSON formatting issues
        cleaned = self._fix_json_formatting(cleaned)
        
        try:
            return json.loads(cleaned)
        except json.JSONDecodeError:
            return None
    
    async def _try_llm_extract_and_fix(self, text: str) -> Optional[Any]:
        """Use LLM to extract and fix JSON from the text"""
        try:
            # Run async LLM call in event loop
            result = await self._llm_extract_and_fix_async(text)
            return result
        except Exception as e:
            logger.warning(f"LLM extract and fix failed: {str(e)}")
            return None
    
    async def _llm_extract_and_fix_async(self, text: str) -> Optional[Any]:
        """Async method to use LLM for JSON extraction and fixing"""
        prompt = f"""Please extract and fix the JSON from the following text. Return only valid JSON without any explanation or markdown formatting.

Input text:
{text}

Requirements:
1. Extract any JSON-like content from the text
2. Fix common JSON formatting issues (missing quotes, trailing commas, etc.)
3. Return only the valid JSON, no additional text
4. If multiple JSON objects exist, return the most complete one
5. If no valid JSON can be extracted or fixed, return null

JSON:"""

        messages = [
            {
                "role": "user",
                "content": prompt
            }
        ]
        
        try:
            response = await self.llm.ask(
                messages=messages,
                response_format={"type": "json_object"}
            )
            
            content = response.get("content", "").strip()
            if content and content != "null":
                return json.loads(content)
            return None
            
        except Exception as e:
            logger.warning(f"LLM JSON extraction failed: {str(e)}")
            return None
    
    def _fix_json_formatting(self, text: str) -> str:
        """Fix common JSON formatting issues"""
        # Replace single quotes with double quotes (but not inside strings)
        # This is a simplified approach - might need more sophisticated handling
        text = re.sub(r"(?<!\\)'([^']*?)(?<!\\)'", r'"\1"', text)
        
        # Fix trailing commas
        text = re.sub(r',(\s*[}\]])', r'\1', text)
        
        # Fix missing quotes around keys
        text = re.sub(r'(\w+):', r'"\1":', text)
        
        # Fix unescaped double quotes in string values
        # This handles cases like: "key": "value with " unescaped quotes"
        def fix_unescaped_quotes_in_values(match):
            key_part = match.group(1)  # "key": "
            value_content = match.group(2)  # value content that may contain unescaped quotes
            
            # Escape any unescaped double quotes in the value content
            # Use negative lookbehind to avoid escaping already escaped quotes
            escaped_content = re.sub(r'(?<!\\)"', r'\\"', value_content)
            
            return f'{key_part}{escaped_content}"'
        
        # Pattern to match: "key": "value content with potential " unescaped quotes"
        # Captures everything from key to the final quote of the value
        text = re.sub(r'("[\w\s\-_]+"\s*:\s*")(.*?)"(?=\s*[,}\]])', fix_unescaped_quotes_in_values, text)
        
        # Fix unescaped double quotes in array string values
        # This handles cases like: ["item with " quotes", "another item"]
        def fix_unescaped_quotes_in_array_values(match):
            quote_and_content = match.group(1)  # " + content that may contain unescaped quotes
            value_content = quote_and_content[1:]  # remove the leading quote
            
            # Escape any unescaped double quotes in the value content
            escaped_content = re.sub(r'(?<!\\)"', r'\\"', value_content)
            
            return f'"{escaped_content}"'
        
        # Pattern to match string values in arrays: "content with potential " quotes"
        # Look for quotes that are preceded by [ or , (with optional whitespace) and followed by , or ] (with optional whitespace)
        text = re.sub(r'(?<=[\[,]\s*)(".*?)"(?=\s*[,\]])', fix_unescaped_quotes_in_array_values, text)
        
        return text



================================================
FILE: backend/app/interfaces/dependencies.py
================================================
from typing import Optional
import logging
from functools import lru_cache
from fastapi import Request
from app.infrastructure.external.file.gridfsfile import get_file_storage
from app.infrastructure.external.search import get_search_engine
from app.domain.models.user import User
from app.application.errors.exceptions import UnauthorizedError

# Import all required services
from app.application.services.agent_service import AgentService
from app.application.services.file_service import FileService
from app.application.services.auth_service import AuthService
from app.application.services.token_service import TokenService
from app.application.services.email_service import EmailService
from app.infrastructure.external.cache import get_cache

# Import all required dependencies for agent service
from app.infrastructure.external.llm.openai_llm import OpenAILLM
from app.infrastructure.external.sandbox.docker_sandbox import DockerSandbox
from app.infrastructure.external.task.redis_task import RedisStreamTask
from app.infrastructure.utils.llm_json_parser import LLMJsonParser
from app.infrastructure.repositories.mongo_agent_repository import MongoAgentRepository
from app.infrastructure.repositories.mongo_session_repository import MongoSessionRepository
from app.infrastructure.repositories.file_mcp_repository import FileMCPRepository
from app.infrastructure.repositories.user_repository import MongoUserRepository


# Configure logging
logger = logging.getLogger(__name__)

@lru_cache()
def get_agent_service() -> AgentService:
    """
    Get agent service instance with all required dependencies
    
    This function creates and returns an AgentService instance with all
    necessary dependencies. Uses lru_cache for singleton pattern.
    """
    logger.info("Creating AgentService instance")
    
    # Create all dependencies
    llm = OpenAILLM()
    agent_repository = MongoAgentRepository()
    session_repository = MongoSessionRepository()
    sandbox_cls = DockerSandbox
    task_cls = RedisStreamTask
    json_parser = LLMJsonParser()
    file_storage = get_file_storage()
    search_engine = get_search_engine()
    mcp_repository = FileMCPRepository()
    
    # Create AgentService instance
    return AgentService(
        llm=llm,
        agent_repository=agent_repository,
        session_repository=session_repository,
        sandbox_cls=sandbox_cls,
        task_cls=task_cls,
        json_parser=json_parser,
        file_storage=file_storage,
        search_engine=search_engine,
        mcp_repository=mcp_repository,
    )


@lru_cache()
def get_file_service() -> FileService:
    """
    Get file service instance with required dependencies
    
    This function creates and returns a FileService instance with
    the necessary file storage dependency.
    """
    logger.info("Creating FileService instance")
    
    # Get file storage dependency
    file_storage = get_file_storage()
    
    return FileService(
        file_storage=file_storage,
    )


@lru_cache()
def get_auth_service() -> AuthService:
    """
    Get authentication service instance with required dependencies
    
    This function creates and returns an AuthService instance with
    the necessary user repository dependency.
    """
    logger.info("Creating AuthService instance")
    
    # Get user repository dependency
    user_repository = MongoUserRepository()
    
    return AuthService(
        user_repository=user_repository,
        token_service=get_token_service(),
    )


@lru_cache()
def get_token_service() -> TokenService:
    """Get token service instance"""
    logger.info("Creating TokenService instance")
    return TokenService()


@lru_cache()
def get_email_service() -> EmailService:
    """Get email service instance"""
    logger.info("Creating EmailService instance")
    cache = get_cache()
    return EmailService(cache=cache)


def get_current_user(request: Request) -> User:
    """
    Get current authenticated user from request state
    
    This function extracts the current user from the request state
    that was set by the authentication middleware.
    """
    if not hasattr(request.state, 'user'):
        raise UnauthorizedError("Authentication required")
    
    user = request.state.user
    if not user:
        raise UnauthorizedError("Invalid user session")
    
    return user

def get_optional_current_user(request: Request) -> Optional[User]:
    """
    Get current authenticated user from request state, return None if not authenticated
    
    This function extracts the current user from the request state
    that was set by the authentication middleware. Returns None if no user.
    """
    if not hasattr(request.state, 'user'):
        return None
    
    return request.state.user


================================================
FILE: backend/app/interfaces/api/auth_routes.py
================================================
from fastapi import APIRouter, Depends, Request
import logging

from app.application.services.auth_service import AuthService
from app.application.services.token_service import TokenService
from app.application.services.file_service import FileService
from app.application.services.agent_service import AgentService
from app.application.services.email_service import EmailService
from app.application.errors.exceptions import (
    UnauthorizedError, NotFoundError, BadRequestError
)
from app.interfaces.dependencies import get_auth_service, get_current_user, get_file_service, get_agent_service, get_token_service, get_email_service
from app.interfaces.schemas.base import APIResponse
from app.interfaces.schemas.auth import (
    LoginRequest, RegisterRequest, ChangePasswordRequest, ChangeFullnameRequest, RefreshTokenRequest,
    SendVerificationCodeRequest, ResetPasswordRequest,
    LoginResponse, RegisterResponse, AuthStatusResponse, RefreshTokenResponse,
    UserResponse
)
from app.core.config import get_settings
from app.domain.models.user import User

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth", tags=["auth"])



@router.post("/login", response_model=APIResponse[LoginResponse])
async def login(
    request: LoginRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[LoginResponse]:
    """User login endpoint"""
    # Authenticate user and get tokens
    auth_result = await auth_service.login_with_tokens(request.email, request.password)
    
    # Return success response with tokens
    return APIResponse.success(LoginResponse(
        user=UserResponse.from_user(auth_result.user),
        access_token=auth_result.access_token,
        refresh_token=auth_result.refresh_token,
        token_type=auth_result.token_type
    ))


@router.post("/register", response_model=APIResponse[RegisterResponse])
async def register(
    request: RegisterRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[RegisterResponse]:
    """User registration endpoint"""
    # Register user
    user = await auth_service.register_user(
        fullname=request.fullname,
        password=request.password,
        email=request.email
    )
    
    # Generate tokens for the new user
    access_token = auth_service.token_service.create_access_token(user)
    refresh_token = auth_service.token_service.create_refresh_token(user)
    
    # Return success response with tokens
    return APIResponse.success(RegisterResponse(
        user=UserResponse.from_user(user),
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer"
    ))


@router.get("/status", response_model=APIResponse[AuthStatusResponse])
async def get_auth_status(
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[AuthStatusResponse]:
    """Get authentication status and configuration"""
    settings = get_settings()
    
    return APIResponse.success(AuthStatusResponse(
        auth_provider=settings.auth_provider
    ))


@router.post("/change-password", response_model=APIResponse[dict])
async def change_password(
    request: ChangePasswordRequest,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[dict]:
    """Change user password endpoint"""
    # Change password for current user
    await auth_service.change_password(current_user.id, request.old_password, request.new_password)
    
    return APIResponse.success({})


@router.post("/change-fullname", response_model=APIResponse[UserResponse])
async def change_fullname(
    request: ChangeFullnameRequest,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[UserResponse]:
    """Change user fullname endpoint"""
    # Change fullname for current user
    updated_user = await auth_service.change_fullname(current_user.id, request.fullname)
    
    return APIResponse.success(UserResponse.from_user(updated_user))


@router.get("/me", response_model=APIResponse[UserResponse])
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
) -> APIResponse[UserResponse]:
    """Get current user information"""
    return APIResponse.success(UserResponse.from_user(current_user))


@router.get("/user/{user_id}", response_model=APIResponse[UserResponse])
async def get_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[UserResponse]:
    """Get user information by ID (admin only)"""
    # Check if current user is admin
    if current_user.role != "admin":
        raise UnauthorizedError("Admin access required")
    
    user = await auth_service.get_user_by_id(user_id)
    
    if not user:
        raise NotFoundError("User not found")
    
    return APIResponse.success(UserResponse.from_user(user))


@router.post("/user/{user_id}/deactivate", response_model=APIResponse[dict])
async def deactivate_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[dict]:
    """Deactivate user account (admin only)"""
    # Check if current user is admin
    if current_user.role != "admin":
        raise UnauthorizedError("Admin access required")
    
    # Prevent self-deactivation
    if current_user.id == user_id:
        raise BadRequestError("Cannot deactivate your own account")
    
    await auth_service.deactivate_user(user_id)
    return APIResponse.success({})


@router.post("/user/{user_id}/activate", response_model=APIResponse[dict])
async def activate_user(
    user_id: str,
    current_user: User = Depends(get_current_user),
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[dict]:
    """Activate user account (admin only)"""
    # Check if current user is admin
    if current_user.role != "admin":
        raise UnauthorizedError("Admin access required")
    
    await auth_service.activate_user(user_id)
    return APIResponse.success({})


@router.post("/refresh", response_model=APIResponse[RefreshTokenResponse])
async def refresh_token(
    request: RefreshTokenRequest,
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[RefreshTokenResponse]:
    """Refresh access token endpoint"""
    # Refresh access token
    token_result = await auth_service.refresh_access_token(request.refresh_token)
    
    return APIResponse.success(RefreshTokenResponse(
        access_token=token_result.access_token,
        token_type=token_result.token_type
    ))


@router.post("/logout", response_model=APIResponse[dict])
async def logout(
    request: Request,
    auth_service: AuthService = Depends(get_auth_service)
) -> APIResponse[dict]:
    """User logout endpoint"""
    if get_settings().auth_provider == "none":
        raise BadRequestError("Logout is not allowed")
    # Extract token from Authorization header
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        raise UnauthorizedError("Authentication required")
    
    token = auth_header.split(" ")[1]
    
    # Revoke token
    await auth_service.logout(token)
    
    return APIResponse.success({})


@router.post("/send-verification-code", response_model=APIResponse[dict])
async def send_verification_code(
    request: SendVerificationCodeRequest,
    auth_service: AuthService = Depends(get_auth_service),
    email_service: EmailService = Depends(get_email_service)
) -> APIResponse[dict]:
    """Send verification code for password reset"""
    if get_settings().auth_provider != "password":
        raise BadRequestError("Password reset is not available")
    
    # Check if user exists with this email
    user = await auth_service.user_repository.get_user_by_email(request.email)
    if not user:
        raise NotFoundError("User not found")
    
    if not user.is_active:
        raise BadRequestError("User account is inactive")
    
    # Send verification code
    await email_service.send_verification_code(request.email)
    
    return APIResponse.success({})


@router.post("/reset-password", response_model=APIResponse[dict])
async def reset_password(
    request: ResetPasswordRequest,
    auth_service: AuthService = Depends(get_auth_service),
    email_service: EmailService = Depends(get_email_service)
) -> APIResponse[dict]:
    """Reset password with verification code"""
    if get_settings().auth_provider != "password":
        raise BadRequestError("Password reset is not available")
    
    # Verify the verification code
    if not await email_service.verify_code(request.email, request.verification_code):
        raise UnauthorizedError("Invalid or expired verification code")
    
    # Reset password
    await auth_service.reset_password(request.email, request.new_password)
    
    return APIResponse.success({})
 


================================================
FILE: backend/app/interfaces/api/file_routes.py
================================================
from fastapi import APIRouter, Depends, UploadFile, File, Query
from fastapi.responses import StreamingResponse
import logging

from app.application.services.file_service import FileService
from app.application.services.token_service import TokenService
from app.application.errors.exceptions import NotFoundError, UnauthorizedError
from app.interfaces.dependencies import get_file_service, get_current_user, get_token_service, get_optional_current_user
from app.domain.models.user import User
from app.interfaces.schemas.base import APIResponse
from app.interfaces.schemas.file import FileUploadResponse, FileInfoResponse
from app.interfaces.schemas.resource import AccessTokenRequest, SignedUrlResponse

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/files", tags=["files"])

@router.post("", response_model=APIResponse[FileUploadResponse])
async def upload_file(
    file: UploadFile = File(...),
    file_service: FileService = Depends(get_file_service),
    current_user: User = Depends(get_current_user)
) -> APIResponse[FileUploadResponse]:
    """Upload file"""
    # Upload file
    result = await file_service.upload_file(
        file_data=file.file,
        filename=file.filename,
        user_id=current_user.id,
        content_type=file.content_type
    )
    
    return APIResponse.success(FileUploadResponse(
        file_id=result.file_id,
        filename=result.filename,
        size=result.size,
        upload_date=result.upload_date.isoformat(),
        message="File uploaded successfully"
    ))

@router.get("/{file_id}")
async def download_file(
    file_id: str,
    file_service: FileService = Depends(get_file_service),
    current_user: User = Depends(get_optional_current_user)
):
    """Download file with optional access token"""
    
    # Download file (authentication is handled by middleware for non-token requests)
    try:
        file_data, file_info = await file_service.download_file(file_id, current_user.id if current_user else None)
    except FileNotFoundError:
        raise NotFoundError("File not found")
    except PermissionError:
        raise NotFoundError("File not found")  # Don't reveal if file exists but user has no access
    
    # Encode filename properly for Content-Disposition header
    # Use URL encoding for non-ASCII characters to ensure latin-1 compatibility
    import urllib.parse
    encoded_filename = urllib.parse.quote(file_info.filename, safe='')
    
    headers = {
        'Content-Disposition': f'attachment; filename*=UTF-8\'\'{encoded_filename}'
    }
    
    return StreamingResponse(
        file_data,
        media_type=file_info.content_type or 'application/octet-stream',
        headers=headers
    )

@router.delete("/{file_id}", response_model=APIResponse[None])
async def delete_file(
    file_id: str,
    file_service: FileService = Depends(get_file_service),
    current_user: User = Depends(get_current_user)
) -> APIResponse[None]:
    """Delete file"""
    success = await file_service.delete_file(file_id, current_user.id)
    if not success:
        raise NotFoundError("File not found")
    return APIResponse.success()

@router.get("/{file_id}/info", response_model=APIResponse[FileInfoResponse])
async def get_file_info(
    file_id: str,
    file_service: FileService = Depends(get_file_service),
    current_user: User = Depends(get_current_user)
) -> APIResponse[FileInfoResponse]:
    """Get file information"""
    file_info = await file_service.get_file_info(file_id, current_user.id)
    if not file_info:
        raise NotFoundError("File not found")
    
    return APIResponse.success(FileInfoResponse(
        file_id=file_info.file_id,
        filename=file_info.filename,
        content_type=file_info.content_type,
        size=file_info.size,
        upload_date=file_info.upload_date.isoformat(),
        metadata=file_info.metadata
    ))


@router.post("/{file_id}/signed-url", response_model=APIResponse[SignedUrlResponse])
async def create_file_signed_url(
    file_id: str,
    request_data: AccessTokenRequest,
    current_user: User = Depends(get_current_user),
    file_service: FileService = Depends(get_file_service),
    token_service: TokenService = Depends(get_token_service)
) -> APIResponse[SignedUrlResponse]:
    """Generate signed URL for file download
    
    This endpoint creates a signed URL that allows temporary access to download
    a specific file without requiring authentication headers.
    """
    
    # Validate expiration time (max 15 minutes)
    expire_minutes = request_data.expire_minutes
    if expire_minutes > 15:
        expire_minutes = 15
    
    # Check if file exists and user has access
    file_info = await file_service.get_file_info(file_id, current_user.id)
    if not file_info:
        raise NotFoundError("File not found")
    
    # Create signed URL for file download
    base_url = f"/api/v1/files/{file_id}"
    signed_url = token_service.create_signed_url(
        base_url=base_url,
        expire_minutes=expire_minutes
    )
    
    logger.info(f"Created signed URL for file download for user {current_user.id}, file {file_id}")
    
    return APIResponse.success(SignedUrlResponse(
        signed_url=signed_url,
        expires_in=expire_minutes * 60,
    ))



================================================
FILE: backend/app/interfaces/api/routes.py
================================================
from fastapi import APIRouter
from . import session_routes, file_routes, auth_routes

def create_api_router() -> APIRouter:
    """Create and configure the main API router"""
    api_router = APIRouter()
    
    # Include all sub-routers
    api_router.include_router(session_routes.router)
    api_router.include_router(file_routes.router)
    api_router.include_router(auth_routes.router)
    
    return api_router

# Create the main router instance
router = create_api_router() 


================================================
FILE: backend/app/interfaces/api/session_routes.py
================================================
from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect, Query
from sse_starlette.sse import EventSourceResponse
from typing import AsyncGenerator, List
from sse_starlette.event import ServerSentEvent
from datetime import datetime
import asyncio
import websockets
import logging

from app.application.services.agent_service import AgentService
from app.application.services.token_service import TokenService
from app.application.errors.exceptions import NotFoundError, UnauthorizedError
from app.interfaces.dependencies import get_agent_service, get_current_user, get_token_service
from app.interfaces.schemas.base import APIResponse
from app.interfaces.schemas.session import (
    ChatRequest, ShellViewRequest, CreateSessionResponse, GetSessionResponse,
    ListSessionItem, ListSessionResponse, ShellViewResponse
)
from app.interfaces.schemas.file import FileViewRequest, FileViewResponse
from app.interfaces.schemas.resource import AccessTokenRequest, SignedUrlResponse
from app.interfaces.schemas.event import EventMapper
from app.domain.models.file import FileInfo
from app.domain.models.user import User

logger = logging.getLogger(__name__)
SESSION_POLL_INTERVAL = 5

router = APIRouter(prefix="/sessions", tags=["sessions"])

@router.put("", response_model=APIResponse[CreateSessionResponse])
async def create_session(
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[CreateSessionResponse]:
    session = await agent_service.create_session(current_user.id)
    return APIResponse.success(
        CreateSessionResponse(
            session_id=session.id,
        )
    )

@router.get("/{session_id}", response_model=APIResponse[GetSessionResponse])
async def get_session(
    session_id: str,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[GetSessionResponse]:
    session = await agent_service.get_session(session_id, current_user.id)
    if not session:
        raise NotFoundError("Session not found")
    return APIResponse.success(GetSessionResponse(
        session_id=session.id,
        title=session.title,
        status=session.status,
        events=EventMapper.events_to_sse_events(session.events)
    ))

@router.delete("/{session_id}", response_model=APIResponse[None])
async def delete_session(
    session_id: str,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[None]:
    await agent_service.delete_session(session_id, current_user.id)
    return APIResponse.success()

@router.post("/{session_id}/stop", response_model=APIResponse[None])
async def stop_session(
    session_id: str,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[None]:
    await agent_service.stop_session(session_id, current_user.id)
    return APIResponse.success()

@router.post("/{session_id}/clear_unread_message_count", response_model=APIResponse[None])
async def clear_unread_message_count(
    session_id: str,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[None]:
    await agent_service.clear_unread_message_count(session_id, current_user.id)
    return APIResponse.success()

@router.get("", response_model=APIResponse[ListSessionResponse])
async def get_all_sessions(
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[ListSessionResponse]:
    sessions = await agent_service.get_all_sessions(current_user.id)
    session_items = [
        ListSessionItem(
            session_id=session.id,
            title=session.title,
            status=session.status,
            unread_message_count=session.unread_message_count,
            latest_message=session.latest_message,
            latest_message_at=int(session.latest_message_at.timestamp()) if session.latest_message_at else None
        ) for session in sessions
    ]
    return APIResponse.success(ListSessionResponse(sessions=session_items))

@router.post("")
async def stream_sessions(
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> EventSourceResponse:
    async def event_generator() -> AsyncGenerator[ServerSentEvent, None]:
        while True:
            sessions = await agent_service.get_all_sessions(current_user.id)
            session_items = [
                ListSessionItem(
                    session_id=session.id,
                    title=session.title,
                    status=session.status,
                    unread_message_count=session.unread_message_count,
                    latest_message=session.latest_message,
                    latest_message_at=int(session.latest_message_at.timestamp()) if session.latest_message_at else None
                ) for session in sessions
            ]
            yield ServerSentEvent(
                event="sessions",
                data=ListSessionResponse(sessions=session_items).model_dump_json()
            )
            await asyncio.sleep(SESSION_POLL_INTERVAL)
    return EventSourceResponse(event_generator())

@router.post("/{session_id}/chat")
async def chat(
    session_id: str,
    request: ChatRequest,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> EventSourceResponse:
    async def event_generator() -> AsyncGenerator[ServerSentEvent, None]:
        async for event in agent_service.chat(
            session_id=session_id,
            user_id=current_user.id,
            message=request.message,
            timestamp=datetime.fromtimestamp(request.timestamp) if request.timestamp else None,
            event_id=request.event_id,
            attachments=request.attachments
        ):
            logger.debug(f"Received event from chat: {event}")
            sse_event = EventMapper.event_to_sse_event(event)
            logger.debug(f"Received event: {sse_event}")
            if sse_event:
                yield ServerSentEvent(
                    event=sse_event.event,
                    data=sse_event.data.model_dump_json() if sse_event.data else None
                )

    return EventSourceResponse(event_generator())

@router.post("/{session_id}/shell")
async def view_shell(
    session_id: str,
    request: ShellViewRequest,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[ShellViewResponse]:
    """View shell session output
    
    If the agent does not exist or fails to get shell output, an appropriate exception will be thrown and handled by the global exception handler
    
    Args:
        session_id: Session ID
        request: Shell view request containing session ID
        
    Returns:
        APIResponse with shell output
    """
    result = await agent_service.shell_view(session_id, request.session_id, current_user.id)
    return APIResponse.success(result)

@router.post("/{session_id}/file")
async def view_file(
    session_id: str,
    request: FileViewRequest,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[FileViewResponse]:
    """View file content
    
    If the agent does not exist or fails to get file content, an appropriate exception will be thrown and handled by the global exception handler
    
    Args:
        session_id: Session ID
        request: File view request containing file path
        
    Returns:
        APIResponse with file content
    """
    result = await agent_service.file_view(session_id, request.file, current_user.id)
    return APIResponse.success(result)

@router.websocket("/{session_id}/vnc")
async def vnc_websocket(
    websocket: WebSocket,
    session_id: str,
    signature: str = Query(None),
    agent_service: AgentService = Depends(get_agent_service),
    token_service: TokenService = Depends(get_token_service)
) -> None:
    """VNC WebSocket endpoint (binary mode)
    
    Establishes a connection with the VNC WebSocket service in the sandbox environment and forwards data bidirectionally
    Supports authentication via both URL token parameter or Authorization header for backward compatibility
    
    Args:
        websocket: WebSocket connection
        session_id: Session ID
    """
    
    await websocket.accept(subprotocol="binary")
    logger.info(f"Accepted WebSocket connection for session {session_id}")

    if not signature:
        logger.error(f"Missing signature: {websocket.url}")
        await websocket.close(code=1011, reason="Missing signature")
        return
    if not token_service.verify_signed_url(str(websocket.url)):
        logger.error(f"Invalid signature: {websocket.url}")
        await websocket.close(code=1011, reason="Invalid signature")
        return
    
    try:
        # Get sandbox environment address with user validation
        sandbox_ws_url = await agent_service.get_vnc_url(session_id)

        logger.info(f"Connecting to VNC WebSocket at {sandbox_ws_url}")
    
        # Connect to sandbox WebSocket
        async with websockets.connect(sandbox_ws_url) as sandbox_ws:
            logger.info(f"Connected to VNC WebSocket at {sandbox_ws_url}")
            # Create two tasks to forward data bidirectionally
            async def forward_to_sandbox():
                try:
                    while True:
                        data = await websocket.receive_bytes()
                        await sandbox_ws.send(data)
                except WebSocketDisconnect:
                    logger.info("Web -> VNC connection closed")
                    pass
                except Exception as e:
                    logger.error(f"Error forwarding data to sandbox: {e}")
            
            async def forward_from_sandbox():
                try:
                    while True:
                        data = await sandbox_ws.recv()
                        await websocket.send_bytes(data)
                except websockets.exceptions.ConnectionClosed:
                    logger.info("VNC -> Web connection closed")
                    pass
                except Exception as e:
                    logger.error(f"Error forwarding data from sandbox: {e}")
            
            # Run two forwarding tasks concurrently
            forward_task1 = asyncio.create_task(forward_to_sandbox())
            forward_task2 = asyncio.create_task(forward_from_sandbox())
            
            # Wait for either task to complete (meaning connection has closed)
            done, pending = await asyncio.wait(
                [forward_task1, forward_task2],
                return_when=asyncio.FIRST_COMPLETED
            )

            logger.info("WebSocket connection closed")
            
            # Cancel pending tasks
            for task in pending:
                task.cancel()
    
    except ConnectionError as e:
        logger.error(f"Unable to connect to sandbox environment: {str(e)}")
        await websocket.close(code=1011, reason=f"Unable to connect to sandbox environment: {str(e)}")
    except Exception as e:
        logger.error(f"WebSocket error: {str(e)}")
        await websocket.close(code=1011, reason=f"WebSocket error: {str(e)}")

@router.get("/{session_id}/files")
async def get_session_files(
    session_id: str,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service)
) -> APIResponse[List[FileInfo]]:
    files = await agent_service.get_session_files(session_id, current_user.id)
    return APIResponse.success(files)


@router.post("/{session_id}/vnc/signed-url", response_model=APIResponse[SignedUrlResponse])
async def create_vnc_signed_url(
    session_id: str,
    request_data: AccessTokenRequest,
    current_user: User = Depends(get_current_user),
    agent_service: AgentService = Depends(get_agent_service),
    token_service: TokenService = Depends(get_token_service)
) -> APIResponse[SignedUrlResponse]:
    """Generate signed URL for VNC WebSocket access
    
    This endpoint creates a signed URL that allows temporary access to the VNC
    WebSocket for a specific session without requiring authentication headers.
    """
    
    # Validate expiration time (max 15 minutes)
    expire_minutes = request_data.expire_minutes
    if expire_minutes > 15:
        expire_minutes = 15
    
    # Check if session exists and belongs to user
    session = await agent_service.get_session(session_id, current_user.id)
    if not session:
        raise NotFoundError("Session not found")
    
    # Create signed URL for VNC WebSocket
    ws_base_url = f"/api/v1/sessions/{session_id}/vnc"
    signed_url = token_service.create_signed_url(
        base_url=ws_base_url,
        expire_minutes=expire_minutes
    )
    
    logger.info(f"Created signed URL for VNC access for user {current_user.id}, session {session_id}")
    
    return APIResponse.success(SignedUrlResponse(
        signed_url=signed_url,
        expires_in=expire_minutes * 60,
    ))


================================================
FILE: backend/app/interfaces/errors/exception_handlers.py
================================================
from fastapi import Request, FastAPI
from fastapi.responses import JSONResponse
import logging
from starlette.exceptions import HTTPException as StarletteHTTPException

from app.application.errors.exceptions import AppException
from app.interfaces.schemas.base import APIResponse

logger = logging.getLogger(__name__)


def register_exception_handlers(app: FastAPI) -> None:
    """Register all exception handlers"""
    
    @app.exception_handler(AppException)
    async def api_exception_handler(request: Request, exc: AppException) -> JSONResponse:
        """Handle custom API exceptions"""
        logger.warning(f"APIException: {exc.msg}")
        return JSONResponse(
            status_code=exc.status_code,
            content=APIResponse(
                code=exc.code,
                msg=exc.msg,
                data=None
            ).model_dump(),
        )
    
    @app.exception_handler(StarletteHTTPException)
    async def http_exception_handler(request: Request, exc: StarletteHTTPException) -> JSONResponse:
        """Handle HTTP exceptions"""
        logger.warning(f"HTTPException: {exc.detail}")
        return JSONResponse(
            status_code=exc.status_code,
            content=APIResponse(
                code=exc.status_code,
                msg=exc.detail,
                data=None
            ).model_dump(),
        )
    
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception) -> JSONResponse:
        """Handle all uncaught exceptions"""
        logger.exception(f"Unhandled exception: {str(exc)}")
        return JSONResponse(
            status_code=500,
            content=APIResponse(
                code=500,
                msg="Internal server error",
                data=None
            ).model_dump(),
        ) 


================================================
FILE: backend/app/interfaces/middleware/auth.py
================================================
from fastapi import Request, status
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Optional
import logging

from app.core.config import get_settings
from app.interfaces.dependencies import get_token_service, get_auth_service
from app.domain.models.user import User, UserRole

logger = logging.getLogger(__name__)


class AuthMiddleware(BaseHTTPMiddleware):
    """Authentication middleware for API requests"""
    
    def __init__(self, app, excluded_paths: Optional[list] = None):
        super().__init__(app)
        self.settings = get_settings()
        self.auth_service = get_auth_service()
        self.token_service = get_token_service()
        
        # Default paths that don't require authentication
        self.excluded_paths = excluded_paths or [
            "/api/v1/auth/login",
            "/api/v1/auth/register",
            "/api/v1/auth/status",
            "/api/v1/auth/refresh",
            "/api/v1/auth/send-verification-code",
            "/api/v1/auth/reset-password",
        ]
    
    async def dispatch(self, request: Request, call_next):
        """Process authentication for each request"""
        
        # Skip authentication for excluded paths
        if any(request.url.path.startswith(path) for path in self.excluded_paths):
            return await call_next(request)
        
        # Check if this is a resource access request with token parameter
        if self._is_resource_access_with_token(request):
            return await call_next(request)
        
        # Skip authentication if auth_provider is 'none'
        if self.settings.auth_provider == "none":
            # Add anonymous user to request state
            request.state.user = User(
                id="anonymous",
                fullname="anonymous",
                email="anonymous@localhost",
                role=UserRole.USER,
                is_active=True
            )
            return await call_next(request)
        
        signature = request.query_params.get("signature")
        if signature:
            if not self.token_service.verify_signed_url(signature):
                return self._unauthorized_response("Invalid signature")
        
        # Extract authentication information
        auth_header = request.headers.get("Authorization")
        if not auth_header:
            return self._unauthorized_response("Missing Authorization header")
        
        try:
            # For basic auth
            if auth_header.startswith("Basic "):
                user = await self._handle_basic_auth(auth_header)
            # For bearer token (if implemented)
            elif auth_header.startswith("Bearer "):
                user = await self._handle_bearer_auth(auth_header)
            else:
                return self._unauthorized_response("Invalid authentication scheme")
            
            if not user:
                return self._unauthorized_response("Authentication failed")
            
            if not user.is_active:
                return self._unauthorized_response("User account is inactive")
            
            # Add user to request state
            request.state.user = user
            
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return self._unauthorized_response("Authentication failed")
            
        return await call_next(request)
    
    async def _handle_basic_auth(self, auth_header: str) -> Optional[User]:
        """Handle HTTP Basic Authentication"""
        try:
            import base64
            
            # Extract credentials
            encoded_credentials = auth_header.split(" ")[1]
            decoded_credentials = base64.b64decode(encoded_credentials).decode('utf-8')
            username, password = decoded_credentials.split(":", 1)
            
            # Authenticate user
            user = await self.auth_service.authenticate_user(username, password)
            return user
            
        except Exception as e:
            logger.warning(f"Basic auth failed: {e}")
            return None
    
    async def _handle_bearer_auth(self, auth_header: str) -> Optional[User]:
        """Handle Bearer Token Authentication"""
        try:
            # Extract token
            token = auth_header.split(" ")[1]
            
            # Verify token and get user
            user = await self.auth_service.verify_token(token)
            return user
            
        except Exception as e:
            logger.warning(f"Bearer token auth failed: {e}")
            return None
    
    def _is_resource_access_with_token(self, request: Request) -> bool:
        """Check if request is resource access with valid token parameter or signed URL"""
        try:
            signature = request.query_params.get("signature")
            if signature:
                return self._verify_signed_url_access(request)
            
            return False
                
        except Exception as e:
            logger.error(f"Error checking resource access: {e}")
            return False

    def _verify_signed_url_access(self, request: Request) -> bool:
        """Verify signed URL access"""
        try:
            # Verify the signed URL directly
            full_url = str(request.url)
            is_valid = self.token_service.verify_signed_url(full_url)
            
            if is_valid:
                logger.info(f"Access authenticated via signed URL for path: {request.url.path}")
                return True
            else:
                logger.warning(f"Invalid signed URL for path: {request.url.path}")
                return False
                
        except Exception as e:
            logger.error(f"Error checking signed URL access: {e}")
            return False

    def _unauthorized_response(self, message: str) -> JSONResponse:
        """Return unauthorized response"""
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={
                "code": 401,
                "msg": message,
                "data": None
            }
        )
        


================================================
FILE: backend/app/interfaces/schemas/auth.py
================================================
from typing import Optional
from pydantic import BaseModel, field_validator
from datetime import datetime
from app.domain.models.user import UserRole


class LoginRequest(BaseModel):
    """Login request schema"""
    email: str
    password: str
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if not v or '@' not in v:
            raise ValueError("Valid email is required")
        return v.strip().lower()
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        if not v or len(v) < 6:
            raise ValueError("Password must be at least 6 characters long")
        return v


class RegisterRequest(BaseModel):
    """Register request schema"""
    fullname: str
    email: str
    password: str
    
    @field_validator('fullname')
    @classmethod
    def validate_fullname(cls, v):
        if not v or len(v.strip()) < 2:
            raise ValueError("Full name must be at least 2 characters long")
        return v.strip()
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if not v or '@' not in v:
            raise ValueError("Valid email is required")
        return v.strip().lower()
    
    @field_validator('password')
    @classmethod
    def validate_password(cls, v):
        if not v or len(v) < 6:
            raise ValueError("Password must be at least 6 characters long")
        return v


class ChangePasswordRequest(BaseModel):
    """Change password request schema"""
    old_password: str
    new_password: str
    
    @field_validator('old_password')
    @classmethod
    def validate_old_password(cls, v):
        if not v:
            raise ValueError("Old password is required")
        return v
    
    @field_validator('new_password')
    @classmethod
    def validate_new_password(cls, v):
        if not v or len(v) < 6:
            raise ValueError("New password must be at least 6 characters long")
        return v


class ChangeFullnameRequest(BaseModel):
    """Change fullname request schema"""
    fullname: str
    
    @field_validator('fullname')
    @classmethod
    def validate_fullname(cls, v):
        if not v or len(v.strip()) < 2:
            raise ValueError("Full name must be at least 2 characters long")
        return v.strip()


class RefreshTokenRequest(BaseModel):
    """Refresh token request schema"""
    refresh_token: str
    
    @field_validator('refresh_token')
    @classmethod
    def validate_refresh_token(cls, v):
        if not v:
            raise ValueError("Refresh token is required")
        return v


class SendVerificationCodeRequest(BaseModel):
    """Send verification code request schema"""
    email: str
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if not v or '@' not in v:
            raise ValueError("Valid email is required")
        return v.strip().lower()


class ResetPasswordRequest(BaseModel):
    """Reset password request schema"""
    email: str
    verification_code: str
    new_password: str
    
    @field_validator('email')
    @classmethod
    def validate_email(cls, v):
        if not v or '@' not in v:
            raise ValueError("Valid email is required")
        return v.strip().lower()
    
    @field_validator('verification_code')
    @classmethod
    def validate_verification_code(cls, v):
        if not v:
            raise ValueError("Verification code is required")
        if not v.isdigit() or len(v) != 6:
            raise ValueError("Verification code must be 6 digits")
        return v
    
    @field_validator('new_password')
    @classmethod
    def validate_new_password(cls, v):
        if not v or len(v) < 6:
            raise ValueError("New password must be at least 6 characters long")
        return v


class UserResponse(BaseModel):
    """User response schema"""
    id: str
    fullname: str
    email: str
    role: UserRole
    is_active: bool
    created_at: datetime
    updated_at: datetime
    last_login_at: Optional[datetime] = None
    
    @staticmethod
    def from_user(user) -> 'UserResponse':
        """Convert user domain model to response schema"""
        return UserResponse(
            id=user.id,
            fullname=user.fullname,
            email=user.email,
            role=user.role,
            is_active=user.is_active,
            created_at=user.created_at,
            updated_at=user.updated_at,
            last_login_at=user.last_login_at
        )


class LoginResponse(BaseModel):
    """Login response schema"""
    user: UserResponse
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class RegisterResponse(BaseModel):
    """Register response schema"""
    user: UserResponse
    access_token: str
    refresh_token: str
    token_type: str = "bearer"


class AuthStatusResponse(BaseModel):
    """Authentication status response schema"""
    auth_provider: str


class RefreshTokenResponse(BaseModel):
    """Refresh token response schema"""
    access_token: str
    token_type: str = "bearer" 


================================================
FILE: backend/app/interfaces/schemas/base.py
================================================
from typing import Any, Generic, Optional, TypeVar
from pydantic import BaseModel

T = TypeVar('T')


class APIResponse(BaseModel, Generic[T]):
    """Base API response schema"""
    code: int = 0
    msg: str = "success"
    data: Optional[T] = None 

    @staticmethod
    def success(data: Optional[T] = None, msg: str = "success") -> "APIResponse[T]":
        return APIResponse(code=0, msg=msg, data=data)

    @staticmethod
    def error(code: int, msg: str) -> "APIResponse[T]":
        return APIResponse(code=code, msg=msg, data=None)



================================================
FILE: backend/app/interfaces/schemas/event.py
================================================
from pydantic import BaseModel, Field, TypeAdapter
from typing import Any, Union, Literal, Dict, Optional, List, Self, Type
from datetime import datetime
from dataclasses import dataclass
from app.domain.models.plan import ExecutionStatus, Step
from app.domain.models.file import FileInfo
from app.domain.models.event import ToolStatus
from app.domain.models.event import (
    AgentEvent,
    ErrorEvent,
    PlanEvent,
    MessageEvent,
    TitleEvent,
    ToolEvent,
    StepEvent,
)

class BaseEventData(BaseModel):
    event_id: Optional[str]
    timestamp: datetime = Field(default_factory=lambda: datetime.now())

    class Config:
        json_encoders = {
            datetime: lambda v: int(v.timestamp())
        }

    @classmethod
    def base_event_data(cls, event: AgentEvent) -> dict:
        return {
            "event_id": event.id,
            "timestamp": int(event.timestamp.timestamp())
        }
    
    @classmethod
    def from_event(cls, event: AgentEvent) -> Self:
        return cls(
            **cls.base_event_data(event),
            **event.model_dump(exclude={"type", "id", "timestamp"})
        )

class CommonEventData(BaseEventData):
    class Config:
        json_encoders = {
            datetime: lambda v: int(v.timestamp())
        }
        extra = "allow"

class BaseSSEEvent(BaseModel):
    event: str
    data: BaseEventData

    @classmethod
    def from_event(cls, event: AgentEvent) -> Self:
        data_class: Type[BaseEventData] = cls.__annotations__.get('data', BaseEventData)
        return cls(
            event=event.type,
            data=data_class.from_event(event)
        )

class MessageEventData(BaseEventData):
    role: Literal["user", "assistant"]
    content: str
    attachments: Optional[List[FileInfo]] = None

class MessageSSEEvent(BaseSSEEvent):
    event: Literal["message"] = "message"
    data: MessageEventData

    @classmethod
    def from_event(cls, event: MessageEvent) -> Self:
        return cls(
            data=MessageEventData(
                **BaseEventData.base_event_data(event),
                role=event.role,
                content=event.message,
                attachments=event.attachments
            )
        )

class ToolEventData(BaseEventData):
    tool_call_id: str
    name: str
    status: ToolStatus
    function: str
    args: Dict[str, Any]
    content: Optional[Any] = None

class ToolSSEEvent(BaseSSEEvent):
    event: Literal["tool"] = "tool"
    data: ToolEventData

    @classmethod
    def from_event(cls, event: ToolEvent) -> Self:
        return cls(
            data=ToolEventData(
                **BaseEventData.base_event_data(event),
                tool_call_id=event.tool_call_id,
                name=event.tool_name,
                status=event.status,
                function=event.function_name,
                args=event.function_args,
                content=event.tool_content
            )
        )

class DoneSSEEvent(BaseSSEEvent):
    event: Literal["done"] = "done"

class WaitSSEEvent(BaseSSEEvent):
    event: Literal["wait"] = "wait"

class ErrorEventData(BaseEventData):
    error: str

class ErrorSSEEvent(BaseSSEEvent):
    event: Literal["error"] = "error"
    data: ErrorEventData

class StepEventData(BaseEventData):
    status: ExecutionStatus
    id: str
    description: str

class StepSSEEvent(BaseSSEEvent):
    event: Literal["step"] = "step"
    data: StepEventData

    @classmethod
    def from_event(cls, event: StepEvent) -> Self:
        return cls(
            data=StepEventData(
                **BaseEventData.base_event_data(event),
                status=event.step.status,
                id=event.step.id,
                description=event.step.description
            )
        )

class TitleEventData(BaseEventData):
    title: str

class TitleSSEEvent(BaseSSEEvent):
    event: Literal["title"] = "title"
    data: TitleEventData

class PlanEventData(BaseEventData):
    steps: List[StepEventData]

class PlanSSEEvent(BaseSSEEvent):
    event: Literal["plan"] = "plan"
    data: PlanEventData

    @classmethod
    def from_event(cls, event: PlanEvent) -> Self:
        return cls(
            data=PlanEventData(
                **BaseEventData.base_event_data(event),
                steps=[StepEventData(
                    **BaseEventData.base_event_data(event),
                    status=step.status,
                    id=step.id, 
                    description=step.description
                ) for step in event.plan.steps]
            )
        )

class CommonSSEEvent(BaseSSEEvent):
    event: str
    data: CommonEventData

AgentSSEEvent = Union[
    CommonEventData,
    PlanSSEEvent,
    MessageSSEEvent,
    TitleSSEEvent,
    ToolSSEEvent,
    StepSSEEvent,
    DoneSSEEvent,
    ErrorSSEEvent,
    WaitSSEEvent,
]

@dataclass
class EventMapping:
    """Data class to store event type mapping information"""
    sse_event_class: Type[BaseEventData]
    data_class: Type[BaseEventData]
    event_type: str

class EventMapper:
    """Map AgentEvent to SSEEvent"""
    
    _cached_mapping: Optional[Dict[str, EventMapping]] = None
    
    @staticmethod
    def _get_event_type_mapping() -> Dict[str, EventMapping]:
        """Dynamically get mapping from event type to SSE event class with caching"""
        if EventMapper._cached_mapping is not None:
            return EventMapper._cached_mapping
            
        from typing import get_args
        
        # Get all subclasses of AgentSSEEvent Union
        sse_event_classes = get_args(AgentSSEEvent)
        mapping = {}
        
        for sse_event_class in sse_event_classes:
            # Skip base class
            if sse_event_class == BaseSSEEvent:
                continue
                
            # Get event type
            if hasattr(sse_event_class, '__annotations__') and 'event' in sse_event_class.__annotations__:
                event_field = sse_event_class.__annotations__['event']
                if hasattr(event_field, '__args__') and len(event_field.__args__) > 0:
                    event_type = event_field.__args__[0]  # Get Literal value
                    
                    # Get data class from sse_event_class
                    data_class = None
                    if hasattr(sse_event_class, '__annotations__') and 'data' in sse_event_class.__annotations__:
                        data_class = sse_event_class.__annotations__['data']
                    
                    mapping[event_type] = EventMapping(
                        sse_event_class=sse_event_class,
                        data_class=data_class,
                        event_type=event_type
                    )
        
        # Cache the mapping
        EventMapper._cached_mapping = mapping
        return mapping
    
    @staticmethod
    def event_to_sse_event(event: AgentEvent) -> AgentSSEEvent:
        # Get mapping dynamically
        event_type_mapping = EventMapper._get_event_type_mapping()
        
        # Find matching SSE event class
        event_mapping = event_type_mapping.get(event.type)
        
        if event_mapping:
            # Prioritize from_event class method
            sse_event = event_mapping.sse_event_class.from_event(event)
            return sse_event
        # If no matching type found, return base event
        return CommonEventData.from_event(event)
    
    @staticmethod
    def events_to_sse_events(events: List[AgentEvent]) -> List[AgentSSEEvent]:
        """Create SSE event list from event list"""
        return list(filter(lambda x: x is not None, [
            EventMapper.event_to_sse_event(event) for event in events if event
        ]))


================================================
FILE: backend/app/interfaces/schemas/file.py
================================================
from pydantic import BaseModel
from typing import Optional, Dict, Any


class FileViewRequest(BaseModel):
    """File view request schema"""
    file: str


class FileViewResponse(BaseModel):
    """File view response schema"""
    content: str
    file: str


class FileUploadResponse(BaseModel):
    """File upload response schema"""
    file_id: str
    filename: str
    size: int
    upload_date: str
    message: str


class FileInfoResponse(BaseModel):
    """File info response schema"""
    file_id: str
    filename: str
    content_type: Optional[str]
    size: int
    upload_date: str
    metadata: Optional[Dict[str, Any]]



================================================
FILE: backend/app/interfaces/schemas/resource.py
================================================
from pydantic import BaseModel, Field


class AccessTokenRequest(BaseModel):
    """Access token request schema"""
    expire_minutes: int = Field(15, description="Token expiration time in minutes (max 15 minutes)", ge=1, le=15)


class SignedUrlResponse(BaseModel):
    """Signed URL response schema"""
    signed_url: str
    expires_in: int     # seconds



================================================
FILE: backend/app/interfaces/schemas/session.py
================================================
from pydantic import BaseModel
from typing import Optional, List
from app.interfaces.schemas.event import AgentSSEEvent
from app.domain.models.session import SessionStatus


class ChatRequest(BaseModel):
    """Chat request schema"""
    timestamp: Optional[int] = None
    message: Optional[str] = None
    attachments: Optional[List[str]] = None
    event_id: Optional[str] = None


class ShellViewRequest(BaseModel):
    """Shell view request schema"""
    session_id: str


class CreateSessionResponse(BaseModel):
    """Create session response schema"""
    session_id: str


class GetSessionResponse(BaseModel):
    """Get session response schema"""
    session_id: str
    title: Optional[str] = None
    status: SessionStatus
    events: List[AgentSSEEvent] = []


class ListSessionItem(BaseModel):
    """List session item schema"""
    session_id: str
    title: Optional[str] = None
    latest_message: Optional[str] = None
    latest_message_at: Optional[int] = None
    status: SessionStatus
    unread_message_count: int


class ListSessionResponse(BaseModel):
    """List session response schema"""
    sessions: List[ListSessionItem]


class ConsoleRecord(BaseModel):
    """Console record schema"""
    ps1: str
    command: str
    output: str


class ShellViewResponse(BaseModel):
    """Shell view response schema"""
    output: str
    session_id: str
    console: Optional[List[ConsoleRecord]] = None



================================================
FILE: backend/tests/conftest.py
================================================
"""
Pytest configuration and fixtures
"""
import sys
import os
import pytest
import tempfile
from pathlib import Path

# Add the parent directory to Python path so we can import app modules
sys.path.insert(0, str(Path(__file__).parent.parent))

import requests

# Base URL for API testing
BASE_URL = "http://localhost:8000/api/v1"

@pytest.fixture
def client():
    """Create requests session"""
    session = requests.Session()
    # Don't set default Content-Type to allow multipart/form-data for file uploads
    return session



================================================
FILE: backend/tests/requirements.txt
================================================
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-cov>=4.0.0
pytest-mock>=3.10.0
requests>=2.28.0 


================================================
FILE: backend/tests/test_api_file.py
================================================
import pytest
import tempfile
import os
import io
from unittest.mock import patch, mock_open
from conftest import BASE_URL
import logging
import requests


logger = logging.getLogger(__name__)


@pytest.fixture
def sample_file_content():
    """Create sample file content for testing"""
    return b"This is a test file content for API testing."


@pytest.fixture
def sample_text_file(sample_file_content):
    """Create a temporary text file for testing"""
    with tempfile.NamedTemporaryFile(mode='wb', suffix='.txt', delete=False) as f:
        f.write(sample_file_content)
        f.flush()
        yield f.name
    # Cleanup
    if os.path.exists(f.name):
        os.unlink(f.name)


def test_upload_file_success(client, sample_text_file):
    """Test successful file upload"""
    url = f"{BASE_URL}/files"
    
    with open(sample_text_file, 'rb') as f:
        files = {'file': ('test_file.txt', f, 'text/plain')}
        response = client.post(url, files=files)
    
    logger.info(f"Upload file response: {response.status_code} - {response.text}")
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    assert 'data' in data
    assert 'file_id' in data['data']
    assert data['data']['filename'] == 'test_file.txt'
    assert data['data']['size'] > 0
    assert 'upload_date' in data['data']


def test_upload_file_without_file(client):
    """Test upload without providing file"""
    url = f"{BASE_URL}/files"
    response = client.post(url)
    
    logger.info(f"Upload without file response: {response.status_code} - {response.text}")
    assert response.status_code == 422  # Validation error


def test_upload_empty_file(client):
    """Test upload empty file"""
    url = f"{BASE_URL}/files"
    
    # Create empty file
    empty_file = io.BytesIO(b"")
    files = {'file': ('empty.txt', empty_file, 'text/plain')}
    response = client.post(url, files=files)
    
    logger.info(f"Upload empty file response: {response.status_code} - {response.text}")
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    assert data['data']['size'] == 0


def test_get_file_info_success(client, sample_text_file):
    """Test getting file information"""
    # First upload a file
    upload_url = f"{BASE_URL}/files"
    with open(sample_text_file, 'rb') as f:
        files = {'file': ('info_test.txt', f, 'text/plain')}
        upload_response = client.post(upload_url, files=files)
    
    logger.info(f"Upload for info test response: {upload_response.status_code} - {upload_response.text}")
    file_id = upload_response.json()['data']['file_id']
    
    # Get file info
    info_url = f"{BASE_URL}/files/{file_id}/info"
    response = client.get(info_url)
    
    logger.info(f"Get file info response: {response.status_code} - {response.text}")
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    assert data['data']['file_id'] == file_id
    assert data['data']['filename'] == 'info_test.txt'
    assert data['data']['content_type'] == 'text/plain'
    assert data['data']['size'] > 0
    assert 'upload_date' in data['data']


def test_get_file_info_not_found(client):
    """Test getting info for non-existent file"""
    fake_file_id = "507f1f77bcf86cd799439011"  # Valid ObjectId format
    url = f"{BASE_URL}/files/{fake_file_id}/info"
    response = client.get(url)
    
    logger.info(f"Get file info not found response: {response.status_code} - {response.text}")
    assert response.status_code == 404


def test_download_file_success(client, sample_text_file, sample_file_content):
    """Test successful file download"""
    # First upload a file
    upload_url = f"{BASE_URL}/files"
    with open(sample_text_file, 'rb') as f:
        files = {'file': ('download_test.txt', f, 'text/plain')}
        upload_response = client.post(upload_url, files=files)
    
    logger.info(f"Upload for download test response: {upload_response.status_code} - {upload_response.text}")
    file_id = upload_response.json()['data']['file_id']
    
    # Download file
    download_url = f"{BASE_URL}/files/{file_id}"
    response = client.get(download_url)
    
    logger.info(f"Download file response: {response.status_code} - Content length: {len(response.content)}")
    assert response.status_code == 200
    assert response.content == sample_file_content
    assert 'Content-Disposition' in response.headers
    assert 'download_test.txt' in response.headers['Content-Disposition']


def test_download_file_not_found(client):
    """Test downloading non-existent file"""
    fake_file_id = "507f1f77bcf86cd799439011"  # Valid ObjectId format
    url = f"{BASE_URL}/files/{fake_file_id}"
    response = client.get(url)
    
    logger.info(f"Download file not found response: {response.status_code} - {response.text}")
    assert response.status_code == 404


def test_delete_file_success(client, sample_text_file):
    """Test successful file deletion"""
    # First upload a file
    upload_url = f"{BASE_URL}/files"
    with open(sample_text_file, 'rb') as f:
        files = {'file': ('delete_test.txt', f, 'text/plain')}
        upload_response = client.post(upload_url, files=files)
    
    file_id = upload_response.json()['data']['file_id']
    
    # Delete file
    delete_url = f"{BASE_URL}/files/{file_id}"
    response = client.delete(delete_url)
    
    logger.info(f"Delete file response: {response.status_code} - {response.text}")
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    
    # Verify file is deleted by trying to get info
    info_url = f"{BASE_URL}/files/{file_id}/info"
    info_response = client.get(info_url)
    logger.info(f"Verify deletion response: {info_response.status_code} - {info_response.text}")
    assert info_response.status_code == 404


def test_delete_file_not_found(client):
    """Test deleting non-existent file"""
    fake_file_id = "507f1f77bcf86cd799439011"  # Valid ObjectId format
    url = f"{BASE_URL}/files/{fake_file_id}"
    response = client.delete(url)
    
    logger.info(f"Delete file not found response: {response.status_code} - {response.text}")
    assert response.status_code == 404


def test_upload_large_file(client):
    """Test uploading a larger file"""
    # Create a 1MB file content
    large_content = b"A" * (1024 * 1024)  # 1MB
    
    url = f"{BASE_URL}/files"
    files = {'file': ('large_file.txt', io.BytesIO(large_content), 'text/plain')}
    response = client.post(url, files=files)
    
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    assert data['data']['size'] == 1024 * 1024


def test_upload_binary_file(client):
    """Test uploading a binary file"""
    # Create binary content
    binary_content = bytes(range(256))  # 0-255 bytes
    
    url = f"{BASE_URL}/files"
    files = {'file': ('binary_file.bin', io.BytesIO(binary_content), 'application/octet-stream')}
    response = client.post(url, files=files)
    
    assert response.status_code == 200
    data = response.json()
    assert data['code'] == 0
    assert data['data']['size'] == 256
    
    # Download and verify content
    file_id = data['data']['file_id']
    download_url = f"{BASE_URL}/files/{file_id}"
    download_response = client.get(download_url)
    
    assert download_response.status_code == 200
    assert download_response.content == binary_content




================================================
FILE: backend/tests/test_auth_routes.py
================================================
import pytest
import logging
import requests
from conftest import BASE_URL


logger = logging.getLogger(__name__)


@pytest.fixture
def test_user_data():
    """Create test user data"""
    return {
        "fullname": "Test User",
        "password": "password123",
        "email": "test@example.com"
    }


@pytest.fixture
def admin_user_data():
    """Create admin user data"""
    return {
        "fullname": "Admin User",
        "password": "admin123",
        "email": "admin@example.com"
    }


@pytest.fixture
def authenticated_user(client, test_user_data):
    """Create and authenticate a test user"""
    # First register the user
    register_url = f"{BASE_URL}/auth/register"
    register_response = client.post(register_url, json=test_user_data)
    
    if register_response.status_code == 200:
        auth_data = register_response.json()["data"]
        return {
            "user_data": test_user_data,
            "auth_data": auth_data,
            "access_token": auth_data["access_token"],
            "refresh_token": auth_data["refresh_token"]
        }
    
    logger.info(f"register_response: {register_response.status_code} - {register_response.text}")
    
    # If registration fails, try login (user might already exist)
    login_url = f"{BASE_URL}/auth/login"
    login_response = client.post(login_url, json={
        "email": test_user_data["email"],
        "password": test_user_data["password"]
    })
    
    if login_response.status_code == 200:
        auth_data = login_response.json()["data"]
        return {
            "user_data": test_user_data,
            "auth_data": auth_data,
            "access_token": auth_data["access_token"],
            "refresh_token": auth_data["refresh_token"]
        }
    
    logger.info(f"login_response: {login_response.status_code} - {login_response.text}")
    
    # If both fail, raise error
    raise Exception("Failed to authenticate test user")


@pytest.fixture
def authenticated_admin(client, admin_user_data):
    """Create and authenticate an admin user"""
    # Try to login first
    login_url = f"{BASE_URL}/auth/login"
    login_response = client.post(login_url, json={
        "email": admin_user_data["email"],
        "password": admin_user_data["password"]
    })
    
    if login_response.status_code == 200:
        auth_data = login_response.json()["data"]
        return {
            "user_data": admin_user_data,
            "auth_data": auth_data,
            "access_token": auth_data["access_token"],
            "refresh_token": auth_data["refresh_token"]
        }
    
    # If login fails, register and promote to admin (this would need API support)
    register_url = f"{BASE_URL}/auth/register"
    register_response = client.post(register_url, json=admin_user_data)
    
    if register_response.status_code == 200:
        auth_data = register_response.json()["data"]
        # Note: In a real system, you'd need a way to promote users to admin
        # This might be done through database manipulation or a separate admin API
        return {
            "user_data": admin_user_data,
            "auth_data": auth_data,
            "access_token": auth_data["access_token"],
            "refresh_token": auth_data["refresh_token"]
        }
    
    raise Exception("Failed to authenticate admin user")


class TestAuthRoutes:
    """Test class for authentication routes using end-to-end testing"""

    def test_register_success(self, client):
        """Test successful user registration"""
        import uuid
        url = f"{BASE_URL}/auth/register"
        # Use UUID to ensure unique email
        unique_suffix = str(uuid.uuid4())[:8]
        user_data = {
            "fullname": f"New User {unique_suffix}",
            "password": "password123",
            "email": f"newuser_{unique_suffix}@example.com"
        }
        
        response = client.post(url, json=user_data)
        
        logger.info(f"Register response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert data["msg"] == "success"
        assert "access_token" in data["data"]
        assert "refresh_token" in data["data"]
        assert data["data"]["user"]["fullname"] == user_data["fullname"]
        assert data["data"]["user"]["email"] == user_data["email"]
        assert data["data"]["user"]["role"] == "user"
        assert data["data"]["user"]["is_active"] is True

    def test_register_validation_error_short_fullname(self, client):
        """Test registration with short fullname"""
        url = f"{BASE_URL}/auth/register"
        user_data = {
            "fullname": "A",  # Too short
            "password": "password123",
            "email": "test@example.com"
        }
        
        response = client.post(url, json=user_data)
        
        logger.info(f"Register short fullname response: {response.status_code} - {response.text}")
        assert response.status_code == 422

    def test_register_validation_error_short_password(self, client):
        """Test registration with short password"""
        url = f"{BASE_URL}/auth/register"
        user_data = {
            "fullname": "Test User",
            "password": "123",  # Too short
            "email": "test@example.com"
        }
        
        response = client.post(url, json=user_data)
        
        logger.info(f"Register short password response: {response.status_code} - {response.text}")
        assert response.status_code == 422

    def test_register_validation_error_invalid_email(self, client):
        """Test registration with invalid email"""
        url = f"{BASE_URL}/auth/register"
        user_data = {
            "fullname": "Test User",
            "password": "password123",
            "email": "invalid-email"  # Invalid email
        }
        
        response = client.post(url, json=user_data)
        
        logger.info(f"Register invalid email response: {response.status_code} - {response.text}")
        assert response.status_code == 422

    def test_register_duplicate_email(self, client, test_user_data):
        """Test registration with duplicate email"""
        url = f"{BASE_URL}/auth/register"
        
        # First registration
        response1 = client.post(url, json=test_user_data)
        logger.info(f"First registration response: {response1.status_code} - {response1.text}")
        
        # Second registration with same email but different fullname
        duplicate_data = {
            "fullname": "Different User",
            "password": "password123",
            "email": test_user_data["email"]  # Same email
        }
        response2 = client.post(url, json=duplicate_data)
        logger.info(f"Duplicate registration response: {response2.status_code} - {response2.text}")
        
        # Second registration should fail
        assert response2.status_code in [400, 422]

    def test_login_success(self, client, authenticated_user):
        """Test successful login"""
        url = f"{BASE_URL}/auth/login"
        login_data = {
            "email": authenticated_user["user_data"]["email"],
            "password": authenticated_user["user_data"]["password"]
        }
        
        response = client.post(url, json=login_data)
        
        logger.info(f"Login response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert "access_token" in data["data"]
        assert "refresh_token" in data["data"]
        assert data["data"]["user"]["email"] == login_data["email"]
        assert data["data"]["token_type"] == "bearer"

    def test_login_invalid_credentials(self, client, authenticated_user):
        """Test login with invalid credentials"""
        url = f"{BASE_URL}/auth/login"
        login_data = {
            "email": authenticated_user["user_data"]["email"],
            "password": "wrongpassword"
        }
        
        response = client.post(url, json=login_data)
        
        logger.info(f"Login invalid credentials response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    def test_login_nonexistent_user(self, client):
        """Test login with nonexistent user"""
        url = f"{BASE_URL}/auth/login"
        login_data = {
            "email": "nonexistent@example.com",
            "password": "password123"
        }
        
        response = client.post(url, json=login_data)
        
        logger.info(f"Login nonexistent user response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    def test_get_auth_status(self, client):
        """Test get authentication status"""
        url = f"{BASE_URL}/auth/status"
        
        response = client.get(url)
        
        logger.info(f"Auth status response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert "authenticated" in data["data"]
        assert "auth_provider" in data["data"]

    def test_get_current_user_info(self, client, authenticated_user):
        """Test get current user information"""
        url = f"{BASE_URL}/auth/me"
        logger.info(f"authenticated_user: {authenticated_user}")
        headers = {"Authorization": f"Bearer {authenticated_user['access_token']}"}
        
        response = client.get(url, headers=headers)
        
        logger.info(f"Get current user response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert data["data"]["fullname"] == authenticated_user["user_data"]["fullname"]
        assert data["data"]["email"] == authenticated_user["user_data"]["email"]
        assert data["data"]["role"] == "user"

    def test_get_current_user_info_unauthorized(self, client):
        """Test get current user information without authentication"""
        url = f"{BASE_URL}/auth/me"
        
        response = client.get(url)
        
        logger.info(f"Get current user unauthorized response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    def test_get_current_user_info_invalid_token(self, client):
        """Test get current user information with invalid token"""
        url = f"{BASE_URL}/auth/me"
        headers = {"Authorization": "Bearer invalid_token"}
        
        response = client.get(url, headers=headers)
        
        logger.info(f"Get current user invalid token response: {response.status_code} - {response.text}")
        assert response.status_code == 401


    def test_refresh_token_success(self, client, authenticated_user):
        """Test successful token refresh"""
        url = f"{BASE_URL}/auth/refresh"
        refresh_data = {
            "refresh_token": authenticated_user["refresh_token"]
        }
        
        response = client.post(url, json=refresh_data)
        
        logger.info(f"Refresh token response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert "access_token" in data["data"]
        assert data["data"]["token_type"] == "bearer"

    def test_refresh_token_invalid_token(self, client):
        """Test token refresh with invalid token"""
        url = f"{BASE_URL}/auth/refresh"
        refresh_data = {
            "refresh_token": "invalid_refresh_token"
        }
        
        response = client.post(url, json=refresh_data)
        
        logger.info(f"Refresh invalid token response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    def test_logout_success(self, client, authenticated_user):
        """Test successful logout"""
        url = f"{BASE_URL}/auth/logout"
        headers = {"Authorization": f"Bearer {authenticated_user['access_token']}"}
        
        response = client.post(url, headers=headers)
        
        logger.info(f"Logout response: {response.status_code} - {response.text}")
        assert response.status_code == 200
        data = response.json()
        assert data["code"] == 0
        assert data["data"]["message"] == "Logout successful"

    def test_logout_unauthorized(self, client):
        """Test logout without authentication"""
        url = f"{BASE_URL}/auth/logout"
        
        response = client.post(url)
        
        logger.info(f"Logout unauthorized response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    def test_logout_invalid_token(self, client):
        """Test logout with invalid token"""
        url = f"{BASE_URL}/auth/logout"
        headers = {"Authorization": "Bearer invalid_token"}
        
        response = client.post(url, headers=headers)
        
        logger.info(f"Logout invalid token response: {response.status_code} - {response.text}")
        assert response.status_code == 401

    # Admin-only endpoint tests (these will need proper admin user setup)
    def test_get_user_by_id_forbidden_non_admin(self, client, authenticated_user):
        """Test get user by ID as non-admin (should be forbidden)"""
        url = f"{BASE_URL}/auth/user/some_user_id"
        headers = {"Authorization": f"Bearer {authenticated_user['access_token']}"}
        
        response = client.get(url, headers=headers)
        
        logger.info(f"Get user by ID non-admin response: {response.status_code} - {response.text}")
        assert response.status_code == 403

    def test_deactivate_user_forbidden_non_admin(self, client, authenticated_user):
        """Test user deactivation as non-admin (should be forbidden)"""
        url = f"{BASE_URL}/auth/user/some_user_id/deactivate"
        headers = {"Authorization": f"Bearer {authenticated_user['access_token']}"}
        
        response = client.post(url, headers=headers)
        
        logger.info(f"Deactivate user non-admin response: {response.status_code} - {response.text}")
        assert response.status_code == 403

    def test_activate_user_forbidden_non_admin(self, client, authenticated_user):
        """Test user activation as non-admin (should be forbidden)"""
        url = f"{BASE_URL}/auth/user/some_user_id/activate"
        headers = {"Authorization": f"Bearer {authenticated_user['access_token']}"}
        
        response = client.post(url, headers=headers)
        
        logger.info(f"Activate user non-admin response: {response.status_code} - {response.text}")
        assert response.status_code == 403

    # Integration tests combining multiple endpoints
    def test_complete_user_lifecycle(self, client):
        """Test complete user lifecycle: register -> login -> change password -> logout"""
        import uuid
        # Use UUID to ensure unique email
        unique_suffix = str(uuid.uuid4())[:8]
        user_data = {
            "fullname": f"Lifecycle User {unique_suffix}",
            "password": "password123",
            "email": f"lifecycle_{unique_suffix}@example.com"
        }
        
        # 1. Register
        register_url = f"{BASE_URL}/auth/register"
        register_response = client.post(register_url, json=user_data)
        logger.info(f"Lifecycle register response: {register_response.status_code} - {register_response.text}")
        assert register_response.status_code == 200
        
        # 2. Login
        login_url = f"{BASE_URL}/auth/login"
        login_response = client.post(login_url, json={
            "email": user_data["email"],
            "password": user_data["password"]
        })
        logger.info(f"Lifecycle login response: {login_response.status_code} - {login_response.text}")
        assert login_response.status_code == 200
        
        access_token = login_response.json()["data"]["access_token"]
        
        # 3. Change password
        change_password_url = f"{BASE_URL}/auth/change-password"
        headers = {"Authorization": f"Bearer {access_token}"}
        change_response = client.post(change_password_url, json={
            "old_password": user_data["password"],
            "new_password": "newpassword123"
        }, headers=headers)
        logger.info(f"Lifecycle change password response: {change_response.status_code} - {change_response.text}")
        assert change_response.status_code == 200
        
        # 4. Logout
        logout_url = f"{BASE_URL}/auth/logout"
        logout_response = client.post(logout_url, headers=headers)
        logger.info(f"Lifecycle logout response: {logout_response.status_code} - {logout_response.text}")
        assert logout_response.status_code == 200

    def test_token_refresh_workflow(self, client, authenticated_user):
        """Test token refresh workflow"""
        # Use refresh token to get new access token
        refresh_url = f"{BASE_URL}/auth/refresh"
        refresh_response = client.post(refresh_url, json={
            "refresh_token": authenticated_user["refresh_token"]
        })
        logger.info(f"Token refresh workflow response: {refresh_response.status_code} - {refresh_response.text}")
        assert refresh_response.status_code == 200
        
        new_access_token = refresh_response.json()["data"]["access_token"]
        
        # Use new access token to access protected endpoint
        me_url = f"{BASE_URL}/auth/me"
        headers = {"Authorization": f"Bearer {new_access_token}"}
        me_response = client.get(me_url, headers=headers)
        logger.info(f"Token refresh workflow me response: {me_response.status_code} - {me_response.text}")
        assert me_response.status_code == 200
        assert me_response.json()["data"]["email"] == authenticated_user["user_data"]["email"] 


================================================
FILE: backend/tests/test_sandbox_file.py
================================================
"""
Integration tests for sandbox file upload and download functionality
"""
import logging
import pytest
import tempfile
import os
import io

from app.infrastructure.external.sandbox.docker_sandbox import DockerSandbox
from app.domain.models.tool_result import ToolResult

logger = logging.getLogger(__name__)


@pytest.fixture
def sandbox_instance():
    """Create a DockerSandbox instance for testing"""
    # Use localhost for testing (assumes sandbox is running locally)
    return DockerSandbox(ip="127.0.0.1", container_name="test-sandbox")


@pytest.fixture
def sample_file_content():
    """Create sample file content for testing"""
    return b"This is a test file content for sandbox testing."


@pytest.fixture
def sample_binary_stream(sample_file_content):
    """Create a binary stream from sample content"""
    return io.BytesIO(sample_file_content)


@pytest.fixture
def temp_file_path():
    """Generate a temporary file path for testing"""
    return f"/tmp/test_file_{os.urandom(8).hex()}.txt"


# Upload Tests

async def test_file_upload_success(sandbox_instance, sample_binary_stream, temp_file_path):
    """Test successful file upload to sandbox"""
    result = await sandbox_instance.file_upload(
        file_data=sample_binary_stream,
        path=temp_file_path,
        filename="test_file.txt"
    )

    # Verify result
    assert isinstance(result, ToolResult)
    assert result.success is True
    assert "successfully" in result.message.lower()


async def test_file_upload_without_filename(sandbox_instance, sample_binary_stream, temp_file_path):
    """Test file upload without specifying filename"""
    result = await sandbox_instance.file_upload(
        file_data=sample_binary_stream,
        path=temp_file_path
    )

    # Verify result
    assert isinstance(result, ToolResult)
    assert result.success is True


async def test_file_upload_large_file(sandbox_instance, temp_file_path):
    """Test uploading a large file"""
    # Create large content (1MB)
    large_content = b"A" * (1024 * 1024)
    large_stream = io.BytesIO(large_content)

    result = await sandbox_instance.file_upload(
        file_data=large_stream,
        path=temp_file_path,
        filename="large_file.bin"
    )

    # Verify result
    assert isinstance(result, ToolResult)
    assert result.success is True


async def test_file_upload_empty_file(sandbox_instance, temp_file_path):
    """Test uploading an empty file"""
    empty_stream = io.BytesIO(b"")

    result = await sandbox_instance.file_upload(
        file_data=empty_stream,
        path=temp_file_path,
        filename="empty_file.txt"
    )

    # Verify result
    assert isinstance(result, ToolResult)
    assert result.success is True


# Download Tests

async def test_file_download_success(sandbox_instance, sample_binary_stream, sample_file_content, temp_file_path):
    """Test successful file download from sandbox"""
    # First upload a file
    upload_result = await sandbox_instance.file_upload(
        file_data=sample_binary_stream,
        path=temp_file_path,
        filename="download_test.txt"
    )
    logger.info(f"Upload for download test response: {upload_result.success} - {upload_result.message}")
    assert upload_result.success is True

    # Then download it
    result = await sandbox_instance.file_download(temp_file_path)

    # Verify result
    content = result.read()
    assert content == sample_file_content

    # Reset stream position and verify we can read again
    result.seek(0)
    content_again = result.read()
    assert content_again == sample_file_content


async def test_file_download_nonexistent_file(sandbox_instance):
    """Test downloading a file that does not exist"""
    nonexistent_path = f"/tmp/nonexistent_{os.urandom(8).hex()}.txt"

    # This should raise an exception or return an error
    with pytest.raises(Exception):
        await sandbox_instance.file_download(nonexistent_path)


async def test_file_download_empty_file(sandbox_instance, temp_file_path):
    """Test downloading an empty file"""
    # Upload empty file first
    empty_stream = io.BytesIO(b"")
    upload_result = await sandbox_instance.file_upload(
        file_data=empty_stream,
        path=temp_file_path,
        filename="empty.txt"
    )
    assert upload_result.success is True

    # Download the empty file
    result = await sandbox_instance.file_download(temp_file_path)

    # Verify result
    content = result.read()
    assert content == b""


async def test_file_download_large_file(sandbox_instance, temp_file_path):
    """Test downloading a large file"""
    # Create and upload large content (1MB)
    large_content = b"B" * (1024 * 1024)
    large_stream = io.BytesIO(large_content)

    upload_result = await sandbox_instance.file_upload(
        file_data=large_stream,
        path=temp_file_path,
        filename="large_download.bin"
    )
    assert upload_result.success is True

    # Download the large file
    result = await sandbox_instance.file_download(temp_file_path)

    # Verify result
    content = result.read()
    assert content == large_content
    assert len(content) == 1024 * 1024


# Integration Tests

async def test_upload_then_download_cycle(sandbox_instance, sample_file_content, temp_file_path):
    """Test uploading a file and then downloading it"""
    sample_stream = io.BytesIO(sample_file_content)

    # Upload file
    upload_result = await sandbox_instance.file_upload(
        file_data=sample_stream,
        path=temp_file_path,
        filename="cycle_test.txt"
    )

    # Verify upload success
    assert upload_result.success is True

    # Download file
    download_result = await sandbox_instance.file_download(temp_file_path)

    # Verify download result matches original content
    downloaded_content = download_result.read()
    assert downloaded_content == sample_file_content


async def test_multiple_file_operations(sandbox_instance, temp_file_path):
    """Test multiple file upload and download operations"""
    # Test data for multiple files
    files_data = [
        (b"Content of file 1", "file1.txt"),
        (b"Content of file 2", "file2.txt"),
        (b"Content of file 3", "file3.txt"),
    ]

    uploaded_paths = []

    # Upload multiple files
    for i, (content, filename) in enumerate(files_data):
        file_path = f"{temp_file_path}_{i}"
        stream = io.BytesIO(content)
        
        upload_result = await sandbox_instance.file_upload(
            file_data=stream,
            path=file_path,
            filename=filename
        )
        
        assert upload_result.success is True
        uploaded_paths.append((file_path, content))

    # Download and verify all files
    for file_path, expected_content in uploaded_paths:
        download_result = await sandbox_instance.file_download(file_path)
        downloaded_content = download_result.read()
        assert downloaded_content == expected_content


async def test_file_overwrite(sandbox_instance, temp_file_path):
    """Test overwriting an existing file"""
    # Upload initial file
    initial_content = b"Initial content"
    initial_stream = io.BytesIO(initial_content)
    
    upload_result1 = await sandbox_instance.file_upload(
        file_data=initial_stream,
        path=temp_file_path,
        filename="overwrite_test.txt"
    )
    assert upload_result1.success is True

    # Upload new content to same path
    new_content = b"New content that overwrites the old one"
    new_stream = io.BytesIO(new_content)
    
    upload_result2 = await sandbox_instance.file_upload(
        file_data=new_stream,
        path=temp_file_path,
        filename="overwrite_test.txt"
    )
    assert upload_result2.success is True

    # Download and verify new content
    download_result = await sandbox_instance.file_download(temp_file_path)
    downloaded_content = download_result.read()
    assert downloaded_content == new_content
    assert downloaded_content != initial_content 


================================================
FILE: docs/README.md
================================================
[Binary file]


================================================
FILE: docs/_navbar.md
================================================
* 🌐 语言
  * [🇨🇳 中文](/)
  * [🇺🇸 英文](/en/)


================================================
FILE: docs/_sidebar.md
================================================

 * [🤖 AI Manus 开源通用智能体](README.md)
 * [🚀 快速上手](quick_start.md)
 * [📅 开发计划](roadmap.md)
 * 🛠️ 功能使用
   * [✨ 场景演示](demo.md)
   * [🔧 MCP 配置](mcp.md)
 * [📋 配置说明](configuration.md)
 * 👨‍💻 开发指南
   * [⚙️ 系统架构](architecture.md)


================================================
FILE: docs/architecture.md
================================================
# ⚙️ 系统架构

## 整体设计

![Image](https://github.com/user-attachments/assets/69775011-1eb7-452f-adaf-cd6603a4dde5 ':size=600')

**当用户发起对话时：**

1. Web 向 Server 发送创建 Agent 请求，Server 通过`/var/run/docker.sock`创建出 Sandbox，并返回会话 ID。
2. Sandbox 是一个 Ubuntu Docker 环境，里面会启动 chrome 浏览器及 File/Shell 等工具的 API 服务。
3. Web 往会话 ID 中发送用户消息，Server 收到用户消息后，将消息发送给 PlanAct Agent 处理。
4. PlanAct Agent 处理过程中会调用相关工具完成任务。
5. Agent 处理过程中产生的所有事件通过 SSE 发回 Web。

**当用户浏览工具时：**

- 浏览器：
    1. Sandbox 的无头浏览器通过 xvfb 与 x11vnc 启动了 vnc 服务，并且通过 websockify 将 vnc 转化成 websocket。
    2. Web 的 NoVNC 组件通过 Server 的 Websocket Forward 转发到 Sandbox，实现浏览器查看。
- 其它工具：其它工具原理也是差不多。


================================================
FILE: docs/CNAME
================================================
docs.ai-manus.com


================================================
FILE: docs/configuration.md
================================================
[Binary file]


================================================
FILE: docs/demo.md
================================================
# ✨ 场景演示

## 电脑接管

> 任务: 看一下知乎热搜

[](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/takeover.mp4 ':include controls width="100%"')

## 文件处理

> 任务：转成 jpg

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/file.mp4 ':include controls width="100%"')


## MCP 工具调用

> 任务：统计一下 simpleyyt 用户的 github 仓库

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/mcp.mp4 ':include controls width="100%"')


================================================
FILE: docs/index.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>AI Manus 开源通用智能体</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="AI Manus is a general-purpose AI Agent system that supports running various tools and operations in a sandbox environment.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css">
  <link rel="icon" href="./favicon.ico" type="image/x-icon" sizes="32x32">
</head>

<body>
  <div id="app"></div>
  <script>
    window.$docsify = {
      name: '🤖 AI Manus',
      repo: 'https://github.com/simpleyyt/ai-manus',
      loadSidebar: true,
      subMaxLevel: 2,
      auto2top: true,
      loadNavbar: true,
      homepage: 'README.md',
      pagination: {
        previousText: {
          '/en/': 'PREVIOUS',
          '/': '上一章节'
        },
        nextText: {
          '/en/': 'NEXT',
          '/': '下一章节'
        },
        crossChapter: true,
        crossChapterText: true,
      },
    }
  </script>
    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
      mermaid.initialize({ startOnLoad: true });
      window.mermaid = mermaid;
    </script>
    <script src="//unpkg.com/docsify-mermaid@2.0.1/dist/docsify-mermaid.js"></script>
  <!-- Docsify v4 -->
  <script src="//cdn.jsdelivr.net/npm/docsify@4"></script>
  <script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/emoji.min.js"></script>
  <script src="//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js"></script>
</body>

</html>


================================================
FILE: docs/mcp.md
================================================
# MCP 配置

## 简介

MCP（Model Context Protocol）是一个开放的标准协议，用于在语言模型应用程序和外部数据源及工具之间提供安全的连接。在 AI Manus 中，MCP 允许 AI 助手访问和使用各种外部服务和工具，如 GitHub API、文件系统、数据库等。

## 演示

> 任务：统计一下 simpleyyt 用户的 github 仓库

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/mcp.mp4 ':include controls width="100%"')

## 配置说明

### MCP 配置文件

MCP 服务器的配置通过 `mcp.json` 文件进行管理，该文件包含了所有 MCP 服务器的配置信息。

#### 配置文件结构

```json
{
  "mcpServers": {
    "服务器名称": {
      "command": "命令",
      "args": ["参数列表"],
      "transport": "传输方式",
      "enabled": true/false,
      "description": "服务器描述",
      "env": {
        "环境变量名": "环境变量值"
      }
    }
  }
}
```

#### 当前配置示例

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "transport": "stdio",
      "enabled": true,
      "description": "GitHub API integration",
      "env": {
        "GITHUB_TOKEN": "your_github_token_here"
      }
    }
  }
}
```

### Docker Compose 配置

在 `docker-compose.yml` 中配置 MCP 服务：

```yaml
...
services:
  backend:
    image: simpleyyt/manus-backend
    volumes:
      - ./mcp.json:/etc/mcp.json  # 挂载 MCP 配置文件
      - ...
    environment:
      # MCP 配置文件路径
      - MCP_CONFIG_PATH=/etc/mcp.json
...
```

## 更多资源

- [MCP 官方文档](https://modelcontextprotocol.io/)
- [MCP 服务器列表](https://github.com/modelcontextprotocol/servers)


================================================
FILE: docs/quick_start.md
================================================
# 🚀 快速上手

## 环境准备

本项目主要依赖Docker进行开发与部署，需要安装较新版本的Docker：

 * Docker 20.10+
 * Docker Compose

模型能力要求：

 * 兼容 OpenAI 接口
 * 支持 FunctionCall
 * 支持 Json Format 输出

推荐使用 Deepseek 与 ChatGPT 模型。


## Docker 安装

### Windows & Mac 系统

按照官方要求安装 Docker Desktop ：https://docs.docker.com/desktop/

### Linux 系统

按照官方要求安装 Docker Engine：https://docs.docker.com/engine/

## 部署

使用Docker Compose进行部署，需要修改`API_BASE`与`API_KEY`环境变量：

<!-- docker-compose-example.yml -->
```yaml
services:
  frontend:
    image: simpleyyt/manus-frontend
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: simpleyyt/manus-backend
    depends_on:
      - sandbox
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    environment:
      # OpenAI API base URL
      - API_BASE=https://api.openai.com/v1
      # OpenAI API key, replace with your own
      - API_KEY=sk-xxxx
      # LLM model name
      - MODEL_NAME=gpt-4o
      # LLM temperature parameter, controls randomness
      - TEMPERATURE=0.7
      # Maximum tokens for LLM response
      - MAX_TOKENS=2000

      # MongoDB connection URI
      #- MONGODB_URI=mongodb://mongodb:27017
      # MongoDB database name
      #- MONGODB_DATABASE=manus
      # MongoDB username (optional)
      #- MONGODB_USERNAME=
      # MongoDB password (optional)
      #- MONGODB_PASSWORD=

      # Redis server hostname
      #- REDIS_HOST=redis
      # Redis server port
      #- REDIS_PORT=6379
      # Redis database number
      #- REDIS_DB=0
      # Redis password (optional)
      #- REDIS_PASSWORD=

      # Sandbox server address (optional)
      #- SANDBOX_ADDRESS=
      # Docker image used for the sandbox
      - SANDBOX_IMAGE=simpleyyt/manus-sandbox
      # Prefix for sandbox container names
      - SANDBOX_NAME_PREFIX=sandbox
      # Time-to-live for sandbox containers in minutes
      - SANDBOX_TTL_MINUTES=30
      # Docker network for sandbox containers
      - SANDBOX_NETWORK=manus-network
      # Chrome browser arguments for sandbox (optional)
      #- SANDBOX_CHROME_ARGS=
      # HTTPS proxy for sandbox (optional)
      #- SANDBOX_HTTPS_PROXY=
      # HTTP proxy for sandbox (optional)
      #- SANDBOX_HTTP_PROXY=
      # No proxy hosts for sandbox (optional)
      #- SANDBOX_NO_PROXY=
      
      # Search engine configuration
      # Options: baidu, google, bing
      - SEARCH_PROVIDER=bing

      # Google search configuration, only used when SEARCH_PROVIDER=google
      #- GOOGLE_SEARCH_API_KEY=
      #- GOOGLE_SEARCH_ENGINE_ID=

      # Auth configuration
      # Options: password, none, local
      - AUTH_PROVIDER=password

      # Password auth configuration, only used when AUTH_PROVIDER=password
      - PASSWORD_SALT=
      - PASSWORD_HASH_ROUNDS=10
      - PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

      # Local auth configuration, only used when AUTH_PROVIDER=local
      #- LOCAL_AUTH_EMAIL=admin@example.com
      #- LOCAL_AUTH_PASSWORD=admin

      # JWT configuration
      - JWT_SECRET_KEY=your-secret-key-here
      - JWT_ALGORITHM=HS256
      - JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
      - JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

      # Email configuration
      # Only used when AUTH_PROVIDER=password
      #- EMAIL_HOST=smtp.gmail.com
      #- EMAIL_PORT=587
      #- EMAIL_USERNAME=your-email@gmail.com
      #- EMAIL_PASSWORD=your-password
      #- EMAIL_FROM=your-email@gmail.com

      # MCP configuration file path
      #- MCP_CONFIG_PATH=/etc/mcp.json

      # Application log level
      - LOG_LEVEL=INFO

  sandbox:
    image: simpleyyt/manus-sandbox
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge
```
<!-- /docker-compose-example.yml -->

保存成`docker-compose.yml`文件，并运行：

```bash
docker compose up -d
```

> 注意：如果提示`sandbox-1 exited with code 0`，这是正常的，这是为了让 sandbox 镜像成功拉取到本地。

打开浏览器访问 <http://localhost:5173> 即可访问 Manus。



================================================
FILE: docs/roadmap.md
================================================
# 📅 开发计划

> 当前开发中的功能：配置

## 工具

 * [x] 支持浏览器接管
 * [x] 支持外部 MCP 工具集成
 * [ ] 支持 Deploy & Expose 工具

## 用户认证

 * [x] 支持多用户

## 部署

 * [ ] 支持 Docker Swarm 部署
 * [ ] 支持 Docker Compose 部署

## UI

 * [ ] 支持设置
 * [ ] 支持时间轴回放

## 任务会话

 * [ ] 支持分享

## 基建

 * [ ] 支持 Windows & 手机接入
 * [ ] 支持 Bing、Google、Tavily 等搜索提供商
 * [ ] 支持阿里云等文件存储提供商
 * [ ] 支持 e2b 等沙盒提供商
 * [ ] 支持 mem0 记忆提供商
 * [ ] 后台任务换成 celery 任务
 * [ ] 沙盒企业级安全建设


================================================
FILE: docs/run.sh
================================================
#! /bin/bash

docsify serve .


================================================
FILE: docs/.nojekyll
================================================
[Empty file]


================================================
FILE: docs/en/README.md
================================================
# 🤖 AI Manus Open Source General AI Agent

Project URL: <https://github.com/Simpleyyt/ai-manus>

Join our community: [QQ Group (1005477581)](https://qun.qq.com/universal-share/share?ac=1&authKey=p4X3Da5iMpR4liAenxwvhs7IValPKiCFtUevRlJouz9qSTSZsMnPJc3hzsJjgQYv&busi_data=eyJncm91cENvZGUiOiIxMDA1NDc3NTgxIiwidG9rZW4iOiJNZmUrTmQ0UzNDZDNqNDFVdjVPS1VCRkJGRWVlV0R3RFJSRVFoZDAwRjFDeUdUM0t6aUIyczlVdzRjV1BYN09IIiwidWluIjoiMzQyMjExODE1In0%3D&data=C3B-E6BlEbailV32co77iXL5vxPIhtD9y_itWLSq50hKqosO_55_isOZym2Faaq4hs9-517tUY8GSWaDwPom-A&svctype=4&tempid=h5_group_info)

---

AI Manus is a general-purpose AI Agent system that can be fully privately deployed and supports running various tools and operations in a sandbox environment.

The goal of AI Manus project is to become a fully privately deployable enterprise-level Manus application. Vertical Manus applications have many repetitive engineering tasks, and this project hopes to unify this part, allowing everyone to build vertical Manus applications like building blocks.

Each service and tool in AI Manus includes a Built-in version that can be fully privately deployed. Later, through A2A and MCP protocols, both Built-in Agents and Tools can be replaced. The underlying infrastructure can also be replaced by providing diverse provider configurations or simple development adaptations. AI Manus supports distributed multi-instance deployment from the architectural design, facilitating horizontal scaling to meet enterprise-level deployment requirements.

---

## Basic Features

[](https://github.com/user-attachments/assets/37060a09-c647-4bcb-920c-959f7fa73ebe ':include :type=video controls width="100%"')

## Core Features

 * **Deployment:** Only requires one LLM service for deployment, no dependency on other external services.
 * **Tools:** Supports Terminal, Browser, File, Web Search, message tools, with real-time viewing and takeover capabilities.
 * **Sandbox:** Each Task is allocated a separate sandbox that runs in a local Docker environment.
 * **Task Sessions:** Manages session history through Mongo/Redis, supports background tasks.
 * **Conversations:** Supports stopping and interruption, supports file upload and download.
 * **Multi-language:** Supports Chinese and English. 
 * **Authentication:** User login and authentication.


================================================
FILE: docs/en/_navbar.md
================================================
* 🌐 Language
  * [🇨🇳 中文](/)
  * [🇺🇸 English](/en/)


================================================
FILE: docs/en/_sidebar.md
================================================
 * [🤖 AI Manus Open Source General AI Agent](/en/README.md)
 * [🚀 Quick Start](/en/quick_start.md)
 * [📅 Development Roadmap](/en/roadmap.md)
 * 🛠️ Features
   * [✨ Demo Scenarios](/en/demo.md)
   * [🔧 MCP Configuration](/en/mcp.md)
* [📋 Configuration Guide](/en/configuration.md) 
* 👨‍💻 Development Guide
   * [⚙️ System Architecture](/en/architecture.md)


================================================
FILE: docs/en/architecture.md
================================================
# ⚙️ System Architecture

## Overall Design

![Image](https://github.com/user-attachments/assets/69775011-1eb7-452f-adaf-cd6603a4dde5 ':size=600')

**When a user initiates a conversation:**

1. Web sends a create Agent request to Server, Server creates Sandbox through `/var/run/docker.sock` and returns session ID.
2. Sandbox is an Ubuntu Docker environment that starts Chrome browser and API services for File/Shell and other tools.
3. Web sends user messages to the session ID, Server receives user messages and forwards them to PlanAct Agent for processing.
4. PlanAct Agent calls relevant tools to complete tasks during processing.
5. All events generated during Agent processing are sent back to Web via SSE.

**When users browse tools:**

- Browser:
    1. The headless browser in Sandbox starts VNC service through xvfb and x11vnc, and converts VNC to WebSocket through websockify.
    2. Web's NoVNC component forwards to Sandbox through Server's WebSocket Forward, enabling browser viewing.
- Other tools: Other tools work on similar principles. 


================================================
FILE: docs/en/configuration.md
================================================
# 📋 Configuration Guide

## Configuration Items

### Model Provider Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `API_KEY` | - | Yes | API key for the LLM model |
| `API_BASE` | `http://mockserver:8090/v1` | Yes | Base API address for specifying model service endpoint |

### Model Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `MODEL_NAME` | `deepseek-chat` | Yes | Name of the model to use |
| `TEMPERATURE` | `0.7` | No | Randomness level of model responses, range 0-1 |
| `MAX_TOKENS` | `2000` | No | Maximum number of tokens in model response |

### MongoDB Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `MONGODB_URI` | `mongodb://mongodb:27017` | No | MongoDB connection string |
| `MONGODB_DATABASE` | `manus` | No | Database name |
| `MONGODB_USERNAME` | - | No | MongoDB username |
| `MONGODB_PASSWORD` | - | No | MongoDB password |

> **Note**: MongoDB configuration items are currently commented out, indicating they may be optional features or not fully implemented yet.

### Redis Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `REDIS_HOST` | `redis` | No | Redis server address |
| `REDIS_PORT` | `6379` | No | Redis server port |
| `REDIS_DB` | `0` | No | Redis database number |
| `REDIS_PASSWORD` | - | No | Redis password |

> **Note**: Redis configuration items are currently commented out, indicating they may be optional features or not fully implemented yet.

### Sandbox Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `SANDBOX_ADDRESS` | - | No | Sandbox server address |
| `SANDBOX_IMAGE` | `simpleyyt/manus-sandbox` | No | Docker sandbox image name |
| `SANDBOX_NAME_PREFIX` | `sandbox` | No | Sandbox container name prefix |
| `SANDBOX_TTL_MINUTES` | `30` | No | Sandbox time-to-live in minutes |
| `SANDBOX_NETWORK` | `manus-network` | No | Docker network name |
| `SANDBOX_CHROME_ARGS` | - | No | Chrome browser startup arguments |
| `SANDBOX_HTTPS_PROXY` | - | No | HTTPS proxy settings |
| `SANDBOX_HTTP_PROXY` | - | No | HTTP proxy settings |
| `SANDBOX_NO_PROXY` | - | No | List of addresses to exclude from proxy |

### Search Engine Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `SEARCH_PROVIDER` | `baidu` | No | Search engine provider (`baidu`, `google`, or `bing`) |

#### Google Search Configuration

Used only when `SEARCH_PROVIDER=google`:

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `GOOGLE_SEARCH_API_KEY` | - | Yes | Google Search API key |
| `GOOGLE_SEARCH_ENGINE_ID` | - | Yes | Google Custom Search Engine ID |

### Authentication Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `AUTH_PROVIDER` | `password` | No | Authentication provider (`password`, `none`, or `local`) |

#### Password Authentication Configuration

Used only when `AUTH_PROVIDER=password`:

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `PASSWORD_SALT` | - | No | Password encryption salt |
| `PASSWORD_HASH_ROUNDS` | `10` | No | Password hash rounds |
| `PASSWORD_HASH_ALGORITHM` | `pbkdf2_sha256` | No | Password hash algorithm |

#### Local Authentication Configuration

Used only when `AUTH_PROVIDER=local`:

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `LOCAL_AUTH_EMAIL` | `admin@example.com` | No | Local admin email |
| `LOCAL_AUTH_PASSWORD` | `admin` | No | Local admin password |

### JWT Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `JWT_SECRET_KEY` | `your-secret-key-here` | Yes | JWT signing key (must be changed in production) |
| `JWT_ALGORITHM` | `HS256` | No | JWT signing algorithm |
| `JWT_ACCESS_TOKEN_EXPIRE_MINUTES` | `30` | No | Access token expiration time in minutes |
| `JWT_REFRESH_TOKEN_EXPIRE_DAYS` | `7` | No | Refresh token expiration time in days |

### Email Configuration

Used only when `AUTH_PROVIDER=password`:

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `EMAIL_HOST` | - | No | SMTP server address |
| `EMAIL_PORT` | `587` | No | SMTP server port |
| `EMAIL_USERNAME` | - | No | Email username |
| `EMAIL_PASSWORD` | - | No | Email password |
| `EMAIL_FROM` | - | No | Sender email address |

### MCP Configuration

| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `MCP_CONFIG_PATH` | `/etc/mcp.json` | No | MCP configuration file path |

### Log Configuration
| Configuration | Default Value | Required | Description |
|---------------|---------------|----------|-------------|
| `LOG_LEVEL` | `INFO` | No | Log level (`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`) |




================================================
FILE: docs/en/demo.md
================================================
# ✨ Demo Scenarios

## Computer Takeover

> Task: Check Zhihu trending topics

[](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/takeover.mp4 ':include controls width="100%"')

## File Processing

> Task: Convert to JPG

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/file.mp4 ':include controls width="100%"')


## MCP Tool Integration

> Task: Analyze the GitHub repositories of user simpleyyt

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/mcp.mp4 ':include controls width="100%"') 


================================================
FILE: docs/en/mcp.md
================================================
# MCP Configuration

## Introduction

MCP (Model Context Protocol) is an open standard protocol for providing secure connections between language model applications and external data sources and tools. In AI Manus, MCP allows AI assistants to access and use various external services and tools, such as GitHub API, file systems, databases, and more.

## Demo

> Task: Analyze the GitHub repositories of user simpleyyt

![](https://raw.githubusercontent.com/Simpleyyt/picgo-image/master/mcp.mp4 ':include controls width="100%"')

## Configuration Guide

### MCP Configuration File

MCP server configuration is managed through the `mcp.json` file, which contains configuration information for all MCP servers.

#### Configuration File Structure

```json
{
  "mcpServers": {
    "server_name": {
      "command": "command",
      "args": ["argument_list"],
      "transport": "transport_method",
      "enabled": true/false,
      "description": "server_description",
      "env": {
        "environment_variable_name": "environment_variable_value"
      }
    }
  }
}
```

#### Current Configuration Example

```json
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-github"
      ],
      "transport": "stdio",
      "enabled": true,
      "description": "GitHub API integration",
      "env": {
        "GITHUB_TOKEN": "your_github_token_here"
      }
    }
  }
}
```

### Docker Compose Configuration

Configure MCP service in `docker-compose.yml`:

```yaml
...
services:
  backend:
    image: simpleyyt/manus-backend
    volumes:
      - ./mcp.json:/etc/mcp.json  # Mount MCP configuration file
      - ...
    environment:
      # MCP configuration file path
      - MCP_CONFIG_PATH=/etc/mcp.json
...
```

## Additional Resources

- [MCP Official Documentation](https://modelcontextprotocol.io/)
- [MCP Server List](https://github.com/modelcontextprotocol/servers) 


================================================
FILE: docs/en/quick_start.md
================================================
# 🚀 Quick Start

## Environment Requirements

This project mainly relies on Docker for development and deployment, requiring a newer version of Docker:

 * Docker 20.10+
 * Docker Compose

Model capabilities required:

 * Compatible with OpenAI API
 * Supports Function Call
 * Supports JSON Format output

Recommended models: Deepseek and ChatGPT.

## Docker Installation

### Windows & Mac Systems

Install Docker Desktop according to official requirements: https://docs.docker.com/desktop/

### Linux Systems

Install Docker Engine according to official requirements: https://docs.docker.com/engine/

## Deployment

Deploy using Docker Compose, you need to modify the `API_BASE` and `API_KEY` environment variables:

<!-- docker-compose-example.yml -->
```yaml
services:
  frontend:
    image: simpleyyt/manus-frontend
    ports:
      - "5173:80"
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - manus-network
    environment:
      - BACKEND_URL=http://backend:8000

  backend:
    image: simpleyyt/manus-backend
    depends_on:
      - sandbox
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      #- ./mcp.json:/etc/mcp.json # Mount MCP servers directory
    networks:
      - manus-network
    environment:
      # OpenAI API base URL
      - API_BASE=https://api.openai.com/v1
      # OpenAI API key, replace with your own
      - API_KEY=sk-xxxx
      # LLM model name
      - MODEL_NAME=gpt-4o
      # LLM temperature parameter, controls randomness
      - TEMPERATURE=0.7
      # Maximum tokens for LLM response
      - MAX_TOKENS=2000

      # MongoDB connection URI
      #- MONGODB_URI=mongodb://mongodb:27017
      # MongoDB database name
      #- MONGODB_DATABASE=manus
      # MongoDB username (optional)
      #- MONGODB_USERNAME=
      # MongoDB password (optional)
      #- MONGODB_PASSWORD=

      # Redis server hostname
      #- REDIS_HOST=redis
      # Redis server port
      #- REDIS_PORT=6379
      # Redis database number
      #- REDIS_DB=0
      # Redis password (optional)
      #- REDIS_PASSWORD=

      # Sandbox server address (optional)
      #- SANDBOX_ADDRESS=
      # Docker image used for the sandbox
      - SANDBOX_IMAGE=simpleyyt/manus-sandbox
      # Prefix for sandbox container names
      - SANDBOX_NAME_PREFIX=sandbox
      # Time-to-live for sandbox containers in minutes
      - SANDBOX_TTL_MINUTES=30
      # Docker network for sandbox containers
      - SANDBOX_NETWORK=manus-network
      # Chrome browser arguments for sandbox (optional)
      #- SANDBOX_CHROME_ARGS=
      # HTTPS proxy for sandbox (optional)
      #- SANDBOX_HTTPS_PROXY=
      # HTTP proxy for sandbox (optional)
      #- SANDBOX_HTTP_PROXY=
      # No proxy hosts for sandbox (optional)
      #- SANDBOX_NO_PROXY=
      
      # Search engine configuration
      # Options: baidu, google, bing
      - SEARCH_PROVIDER=bing

      # Google search configuration, only used when SEARCH_PROVIDER=google
      #- GOOGLE_SEARCH_API_KEY=
      #- GOOGLE_SEARCH_ENGINE_ID=

      # Auth configuration
      # Options: password, none, local
      - AUTH_PROVIDER=password

      # Password auth configuration, only used when AUTH_PROVIDER=password
      - PASSWORD_SALT=
      - PASSWORD_HASH_ROUNDS=10
      - PASSWORD_HASH_ALGORITHM=pbkdf2_sha256

      # Local auth configuration, only used when AUTH_PROVIDER=local
      #- LOCAL_AUTH_EMAIL=admin@example.com
      #- LOCAL_AUTH_PASSWORD=admin

      # JWT configuration
      - JWT_SECRET_KEY=your-secret-key-here
      - JWT_ALGORITHM=HS256
      - JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
      - JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

      # Email configuration
      # Only used when AUTH_PROVIDER=password
      #- EMAIL_HOST=smtp.gmail.com
      #- EMAIL_PORT=587
      #- EMAIL_USERNAME=your-email@gmail.com
      #- EMAIL_PASSWORD=your-password
      #- EMAIL_FROM=your-email@gmail.com

      # MCP configuration file path
      #- MCP_CONFIG_PATH=/etc/mcp.json

      # Application log level
      - LOG_LEVEL=INFO

  sandbox:
    image: simpleyyt/manus-sandbox
    command: /bin/sh -c "exit 0"  # prevent sandbox from starting, ensure image is pulled
    restart: "no"
    networks:
      - manus-network

  mongodb:
    image: mongo:7.0
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped
    #ports:
    #  - "27017:27017"
    networks:
      - manus-network

  redis:
    image: redis:7.0
    restart: unless-stopped
    networks:
      - manus-network

volumes:
  mongodb_data:
    name: manus-mongodb-data

networks:
  manus-network:
    name: manus-network
    driver: bridge
```
<!-- /docker-compose-example.yml -->

Save as `docker-compose.yml` file and run:

```bash
docker compose up -d
```

> Note: If you see `sandbox-1 exited with code 0`, this is normal - it ensures the sandbox image is successfully pulled locally.

Open your browser and visit <http://localhost:5173> to access Manus. 



================================================
FILE: docs/en/roadmap.md
================================================
# 📅 Development Roadmap

> Currently under development: Settings

## Tools

 * [x] Support browser takeover
 * [x] Support external MCP tool integration
 * [ ] Support Deploy & Expose tools

## User Authentication

 * [x] Support multi-user

## Deployment

 * [ ] Support Docker Swarm deployment
 * [ ] Support Docker Compose deployment

## UI

 * [ ] Support settings
 * [ ] Support timeline playback

## Task Sessions

 * [ ] Support sharing

## Infrastructure

 * [ ] Support Windows & mobile access
 * [ ] Support Bing, Google, Tavily and other search providers
 * [ ] Support Alibaba Cloud and other file storage providers
 * [ ] Support e2b and other sandbox providers
 * [ ] Support mem0 memory providers
 * [ ] Replace background tasks with celery tasks
 * [ ] Enterprise-level security construction for sandbox 


================================================
FILE: frontend/README.md
================================================
# AI Manus Frontend

English | [中文](README_zh.md)

This is an AI chatbot application built with Vue 3 + TypeScript + Vite. This project is ported from the React version, maintaining the same functionality and interface design.

## Features

- Chat interface
- Tool panels (Search, Files, Terminal, Browser)

## Installation

Create a `.env.development` file with the following configuration:

```
# Backend address
VITE_API_URL=http://127.0.0.1:8000
```

```bash
# Install dependencies
npm install

# Run in development mode
npm run dev

# Build production version
npm run build
```

## Docker Deployment

This project supports containerized deployment using Docker:

```bash
# Build Docker image
docker build -t ai-chatbot-vue .

# Run container (map container port 80 to host port 8080)
docker run -d -p 8080:80 ai-chatbot-vue

# Access the application
# Open browser and visit http://localhost:8080
```

## Project Structure

```
src/
├── assets/          # Static resources and CSS files
├── components/      # Reusable components
│   ├── ChatInput.vue    # Chat input component
│   ├── ChatMessage.vue  # Chat message component
│   ├── Sidebar.vue      # Sidebar component
│   ├── ToolPanel.vue    # Tool panel component
│   └── ui/              # UI components
├── pages/           # Page components
│   ├── ChatPage.vue     # Chat page
│   └── HomePage.vue     # Home page
├── App.vue          # Root component
├── main.ts          # Entry file
└── index.css        # Global styles
``` 


================================================
FILE: frontend/components.json
================================================
{
    "$schema": "https://shadcn-vue.com/schema.json",
    "style": "new-york",
    "typescript": true,
    "tailwind": {
      "config": "",
      "css": "src/assets/theme.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "composables": "@/composables",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib"
    },
    "iconLibrary": "lucide"
  }


================================================
FILE: frontend/docker-entrypoint.sh
================================================
#!/bin/sh

# Replace environment variables in nginx config
envsubst '${BACKEND_URL}' < /etc/nginx/nginx.conf.template > /etc/nginx/nginx.conf

# Start nginx
nginx -g "daemon off;" 


================================================
FILE: frontend/Dockerfile
================================================
# Use Node.js as base image
FROM node:18-alpine as build-stage

# Set working directory
WORKDIR /app

# Copy package.json and package-lock.json files
COPY package*.json ./

# Install project dependencies
RUN npm ci

# Copy project files
COPY . .

# Build application - skip type checking
RUN npm run build

# Use nginx as production environment image
FROM nginx:stable-alpine as production-stage

# Copy built files to nginx
COPY --from=build-stage /app/dist /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/nginx.conf.template

# Copy entrypoint script
COPY docker-entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh

# Expose port 80
EXPOSE 80

# Start nginx with environment variable substitution
CMD ["/docker-entrypoint.sh"] 


================================================
FILE: frontend/env.d.ts
================================================
/// <reference types="vite/client" />

declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent<{}, {}, any>
  export default component
} 


================================================
FILE: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="32x32">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manus</title>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>

</html>


================================================
FILE: frontend/nginx.conf
================================================
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    server {
        listen       80;
        server_name  localhost;

        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
        }

        location /api/ {
            resolver 127.0.0.11 valid=10s;  # Docker DNS
            set $backend_url "${BACKEND_URL}";
            proxy_pass $backend_url;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket support
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 300s;
            proxy_send_timeout 300s;
        }
    }
} 


================================================
FILE: frontend/package.json
================================================
{
  "name": "vite-vue-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "type-check": "vue-tsc",
    "preview": "vite preview"
  },
  "dependencies": {
    "@microsoft/fetch-event-source": "^2.0.1",
    "@novnc/novnc": "^1.5.0",
    "@types/dompurify": "^3.2.0",
    "@vueuse/core": "^10.11.1",
    "axios": "^1.8.4",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.5",
    "framer-motion": "^10.12.16",
    "lucide-vue-next": "^0.511.0",
    "marked": "^15.0.8",
    "mitt": "^3.0.1",
    "monaco-editor": "^0.52.2",
    "reka-ui": "^2.4.1",
    "tailwind-merge": "^1.14.0",
    "tw-animate-css": "^1.3.7",
    "vue": "^3.3.4",
    "vue-i18n": "^9.14.4",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^24.0.13",
    "@vitejs/plugin-vue": "^4.2.3",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.24",
    "tailwindcss": "^3.3.2",
    "typescript": "^5.1.3",
    "vite": "^4.3.9",
    "vite-plugin-monaco-editor": "^1.1.0",
    "vue-tsc": "^1.6.5"
  }
}



================================================
FILE: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
} 


================================================
FILE: frontend/README_zh.md
================================================
[Binary file]


================================================
FILE: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  darkMode: 'class',
  plugins: [
    require('@tailwindcss/typography'),
  ],
} 


================================================
FILE: frontend/tsconfig.app.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue", "env.d.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
} 


================================================
FILE: frontend/tsconfig.json
================================================
{
  "extends": "./tsconfig.app.json"
} 


================================================
FILE: frontend/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
} 


================================================
FILE: frontend/vite.config.ts
================================================
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import monacoEditorPlugin from 'vite-plugin-monaco-editor';
import { resolve } from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    (monacoEditorPlugin as any).default({})
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  optimizeDeps: {
    exclude: ['lucide-vue-next'],
  },
  server: {
    host: true,
    port: 5173,
    ...(process.env.BACKEND_URL && {
      proxy: {
        '/api': {
          target: process.env.BACKEND_URL,
          changeOrigin: true,
          ws: true,
        },
      },
    }),
  },
}); 


================================================
FILE: frontend/.dockerignore
================================================
# 依赖目录
node_modules
npm-debug.log
yarn-debug.log
yarn-error.log

# 编辑器和IDE文件
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# 构建输出
dist
dist-ssr
coverage

# 本地环境文件
.env.local
.env.*.local

# 日志
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# 其他
.DS_Store
.git
.gitignore
README.md
**/TEST*
**/.env 


================================================
FILE: frontend/src/App.vue
================================================
<template>
  <router-view />
  <Toast />
</template>

<script setup lang="ts">
import Toast from './components/ui/Toast.vue';
</script>



================================================
FILE: frontend/src/main.ts
================================================
import { createApp } from 'vue'
import { createRouter, createWebHistory } from 'vue-router'
import App from './App.vue'
import './assets/global.css'
import './assets/theme.css'
import './utils/toast'
import i18n from './composables/useI18n'
import { getStoredToken, getCachedAuthProvider } from './api/auth'

// Import page components
import HomePage from './pages/HomePage.vue'
import ChatPage from './pages/ChatPage.vue'
import LoginPage from './pages/LoginPage.vue'
import MainLayout from './pages/MainLayout.vue'

// Create router
export const router = createRouter({
  history: createWebHistory(),
  routes: [
    { 
      path: '/chat', 
      component: MainLayout,
      meta: { requiresAuth: true },
      children: [
        { 
          path: '', 
          component: HomePage, 
          alias: ['/', '/home'],
          meta: { requiresAuth: true }
        },
        { 
          path: ':sessionId', 
          component: ChatPage,
          meta: { requiresAuth: true }
        }
      ]
    },
    { 
      path: '/login', 
      component: LoginPage
    }
  ]
})

// Global route guard
router.beforeEach(async (to, _, next) => {
  const requiresAuth = to.matched.some((record: any) => record.meta?.requiresAuth)
  const hasToken = !!getStoredToken()
  
  if (requiresAuth) {
    const authProvider = await getCachedAuthProvider()
    
    if (authProvider === 'none') {
      next()
      return
    }
    
    if (!hasToken) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
      return
    }
  }
  
  if (to.path === '/login' && hasToken) {
    next('/')
  } else {
    next()
  }
})

const app = createApp(App)

app.use(router)
app.use(i18n)
app.mount('#app') 


================================================
FILE: frontend/src/api/agent.ts
================================================
// Backend API service
import { apiClient, API_CONFIG, ApiResponse, createSSEConnection, SSECallbacks } from './client';
import { AgentSSEEvent } from '../types/event';
import { CreateSessionResponse, GetSessionResponse, ShellViewResponse, FileViewResponse, ListSessionResponse, SignedUrlResponse } from '../types/response';
import type { FileInfo } from './file';



/**
 * Create Session
 * @returns Session
 */
export async function createSession(): Promise<CreateSessionResponse> {
  const response = await apiClient.put<ApiResponse<CreateSessionResponse>>('/sessions');
  return response.data.data;
}

export async function getSession(sessionId: string): Promise<GetSessionResponse> {
  const response = await apiClient.get<ApiResponse<GetSessionResponse>>(`/sessions/${sessionId}`);
  return response.data.data;
}

export async function getSessions(): Promise<ListSessionResponse> {
  const response = await apiClient.get<ApiResponse<ListSessionResponse>>('/sessions');
  return response.data.data;
}

export async function getSessionsSSE(callbacks?: SSECallbacks<ListSessionResponse>): Promise<() => void> {
  return createSSEConnection<ListSessionResponse>(
    '/sessions',
    {
      method: 'POST'
    },
    callbacks
  );
}

export async function deleteSession(sessionId: string): Promise<void> {
  await apiClient.delete<ApiResponse<void>>(`/sessions/${sessionId}`);
}

export async function stopSession(sessionId: string): Promise<void> {
  await apiClient.post<ApiResponse<void>>(`/sessions/${sessionId}/stop`);
}

/**
 * Create VNC signed URL
 * @param sessionId Session ID to create signed URL for
 * @param expireMinutes URL expiration time in minutes (default: 15)
 * @returns Signed URL response for VNC WebSocket access
 */
export async function createVncSignedUrl(sessionId: string, expireMinutes: number = 15): Promise<SignedUrlResponse> {
  const response = await apiClient.post<ApiResponse<SignedUrlResponse>>(`/sessions/${sessionId}/vnc/signed-url`, {
    expire_minutes: expireMinutes
  });
  return response.data.data;
}

/**
 * Get VNC WebSocket URL with signed URL
 * @param sessionId Session ID
 * @param expireMinutes URL expiration time in minutes (default: 60)
 * @returns Promise resolving to signed VNC WebSocket URL string
 * 
 * @example
 * // Signed URL (no Authorization header needed, more secure)
 * const url = await getVNCUrl('session123');
 * const url = await getVNCUrl('session123', 120);
 */
export const getVNCUrl = async (
  sessionId: string, 
  expireMinutes: number = 15
): Promise<string> => {
    const signedUrlResponse = await createVncSignedUrl(sessionId, expireMinutes);
    const wsBaseUrl = API_CONFIG.host.replace(/^http/, 'ws');
    return `${wsBaseUrl}${signedUrlResponse.signed_url}`;
}

/**
 * Chat with Session (using SSE to receive streaming responses)
 * @returns A function to cancel the SSE connection
 */
export const chatWithSession = async (
  sessionId: string, 
  message: string = '',
  eventId?: string,
  attachments?: string[],
  callbacks?: SSECallbacks<AgentSSEEvent['data']>
): Promise<() => void> => {
  return createSSEConnection<AgentSSEEvent['data']>(
    `/sessions/${sessionId}/chat`,
    {
      method: 'POST',
      body: { 
        message, 
        timestamp: Math.floor(Date.now() / 1000), 
        event_id: eventId,
        attachments
      }
    },
    callbacks
  );
};

/**
 * View Shell session output
 * @param sessionId Session ID
 * @param shellSessionId Shell session ID
 * @returns Shell session output content
 */
export async function viewShellSession(sessionId: string, shellSessionId: string): Promise<ShellViewResponse> {
  const response = await apiClient.post<ApiResponse<ShellViewResponse>>(
    `/sessions/${sessionId}/shell`,
    { session_id: shellSessionId }
  );
  return response.data.data;
}

/**
 * View file content
 * @param sessionId Session ID
 * @param file File path
 * @returns File content
 */
export async function viewFile(sessionId: string, file: string): Promise<FileViewResponse> {
  const response = await apiClient.post<ApiResponse<FileViewResponse>>(
    `/sessions/${sessionId}/file`,
    { file }
  );
  return response.data.data;
}

export async function getSessionFiles(sessionId: string): Promise<FileInfo[]> {
  const response = await apiClient.get<ApiResponse<FileInfo[]>>(`/sessions/${sessionId}/files`);
  return response.data.data;
}

export async function clearUnreadMessageCount(sessionId: string): Promise<void> {
  await apiClient.post<ApiResponse<void>>(`/sessions/${sessionId}/clear_unread_message_count`);
}


================================================
FILE: frontend/src/api/auth.ts
================================================
// Authentication API service
import { apiClient, ApiResponse } from './client';

/**
 * User role type
 */
export type UserRole = 'admin' | 'user';

/**
 * User response type
 */
export interface User {
  id: string;
  fullname: string;
  email: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  last_login_at?: string;
}

/**
 * Login request type
 */
export interface LoginRequest {
  email: string;
  password: string;
}

/**
 * Register request type
 */
export interface RegisterRequest {
  fullname: string;
  email: string;
  password: string;
}

/**
 * Login response type
 */
export interface LoginResponse {
  user: User;
  access_token: string;
  refresh_token: string;
  token_type: string;
}

/**
 * Register response type
 */
export interface RegisterResponse {
  user: User;
  access_token: string;
  refresh_token: string;
  token_type: string;
}

/**
 * Change password request type
 */
export interface ChangePasswordRequest {
  old_password: string;
  new_password: string;
}

/**
 * Change fullname request type
 */
export interface ChangeFullnameRequest {
  fullname: string;
}

/**
 * Refresh token request type
 */
export interface RefreshTokenRequest {
  refresh_token: string;
}

/**
 * Refresh token response type
 */
export interface RefreshTokenResponse {
  access_token: string;
  token_type: string;
}

/**
 * Auth status response type
 */
export interface AuthStatusResponse {
  authenticated: boolean;
  user?: User;
  auth_provider: string;
}

/**
 * Resource access token request type
 */
export interface AccessTokenRequest {
  resource_type: 'file' | 'vnc';
  resource_id: string;
  expire_minutes?: number;
}

/**
 * Resource access token response type
 */
export interface AccessTokenResponse {
  access_token: string;
  resource_type: string;
  resource_id: string;
  expires_in: number;
}

/**
 * Send verification code request type
 */
export interface SendVerificationCodeRequest {
  email: string;
}

/**
 * Reset password request type
 */
export interface ResetPasswordRequest {
  email: string;
  verification_code: string;
  new_password: string;
}



/**
 * User login
 * @param request Login credentials
 * @returns Login response with user info and tokens
 */
export async function login(request: LoginRequest): Promise<LoginResponse> {
  const response = await apiClient.post<ApiResponse<LoginResponse>>('/auth/login', request);
  return response.data.data;
}

/**
 * User registration
 * @param request Registration data
 * @returns Registration response with user info and tokens
 */
export async function register(request: RegisterRequest): Promise<RegisterResponse> {
  const response = await apiClient.post<ApiResponse<RegisterResponse>>('/auth/register', request);
  return response.data.data;
}

/**
 * Get authentication status
 * @returns Current authentication status and configuration
 */
export async function getAuthStatus(): Promise<AuthStatusResponse> {
  const response = await apiClient.get<ApiResponse<AuthStatusResponse>>('/auth/status');
  return response.data.data;
}

/**
 * Change user password
 * @param request Change password data
 * @returns Success response
 */
export async function changePassword(request: ChangePasswordRequest): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>('/auth/change-password', request);
  return response.data.data;
}

/**
 * Change user fullname
 * @param request Change fullname data
 * @returns Updated user data
 */
export async function changeFullname(request: ChangeFullnameRequest): Promise<User> {
  const response = await apiClient.post<ApiResponse<User>>('/auth/change-fullname', request);
  return response.data.data;
}

/**
 * Get current user information
 * @returns Current user data
 */
export async function getCurrentUser(): Promise<User> {
  const response = await apiClient.get<ApiResponse<User>>('/auth/me');
  return response.data.data;
}

/**
 * Get user by ID (admin only)
 * @param userId User ID to fetch
 * @returns User data
 */
export async function getUser(userId: string): Promise<User> {
  const response = await apiClient.get<ApiResponse<User>>(`/auth/user/${userId}`);
  return response.data.data;
}

/**
 * Deactivate user account (admin only)
 * @param userId User ID to deactivate
 * @returns Success response
 */
export async function deactivateUser(userId: string): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>(`/auth/user/${userId}/deactivate`);
  return response.data.data;
}

/**
 * Activate user account (admin only)
 * @param userId User ID to activate
 * @returns Success response
 */
export async function activateUser(userId: string): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>(`/auth/user/${userId}/activate`);
  return response.data.data;
}

/**
 * Refresh access token
 * @param request Refresh token data
 * @returns New access token
 */
export async function refreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse> {
  const response = await apiClient.post<ApiResponse<RefreshTokenResponse>>('/auth/refresh', request);
  return response.data.data;
}

/**
 * User logout
 * @returns Success response
 */
export async function logout(): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>('/auth/logout');
  return response.data.data;
}

/**
 * Send verification code for password reset
 * @param request Email to send verification code to
 * @returns Success response
 */
export async function sendVerificationCode(request: SendVerificationCodeRequest): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>('/auth/send-verification-code', request);
  return response.data.data;
}

/**
 * Reset password with verification code
 * @param request Reset password data including email, verification code and new password
 * @returns Success response
 */
export async function resetPassword(request: ResetPasswordRequest): Promise<{}> {
  const response = await apiClient.post<ApiResponse<{}>>('/auth/reset-password', request);
  return response.data.data;
}



/**
 * Set authentication token in request headers
 * @param token JWT access token
 */
export function setAuthToken(token: string): void {
  apiClient.defaults.headers.Authorization = `Bearer ${token}`;
}

/**
 * Clear authentication token from request headers
 */
export function clearAuthToken(): void {
  delete apiClient.defaults.headers.Authorization;
}

/**
 * Get stored authentication token from localStorage
 * @returns Stored token or null
 */
export function getStoredToken(): string | null {
  return localStorage.getItem('access_token');
}

/**
 * Store authentication token in localStorage
 * @param token Token to store
 */
export function storeToken(token: string): void {
  localStorage.setItem('access_token', token);
}

/**
 * Store refresh token in localStorage
 * @param refreshToken Refresh token to store
 */
export function storeRefreshToken(refreshToken: string): void {
  localStorage.setItem('refresh_token', refreshToken);
}

/**
 * Get stored refresh token from localStorage
 * @returns Stored refresh token or null
 */
export function getStoredRefreshToken(): string | null {
  return localStorage.getItem('refresh_token');
}

/**
 * Clear stored tokens from localStorage
 */
export function clearStoredTokens(): void {
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
}

/**
 * Initialize authentication from stored tokens
 * This should be called when the app starts
 */
export function initializeAuth(): void {
  const token = getStoredToken();
  if (token) {
    setAuthToken(token);
  }
}

// Auth provider cache
let authProviderCache: string | null = null
let isAuthProviderLoaded = false

/**
 * Get auth provider configuration (cached after first call)
 * @returns Auth provider string or null if failed to load
 */
export async function getCachedAuthProvider(): Promise<string | null> {
  // Return cached value if already loaded
  if (isAuthProviderLoaded) {
    return authProviderCache
  }
  
  // Load auth provider configuration
  try {
    const authStatus = await getAuthStatus()
    authProviderCache = authStatus.auth_provider
    isAuthProviderLoaded = true
    return authProviderCache
  } catch (error) {
    console.warn('Failed to load auth provider configuration:', error)
    // Don't set isAuthProviderLoaded to true on error, allow retry
    return null
  }
} 


================================================
FILE: frontend/src/api/client.ts
================================================
// Backend API client configuration
import axios, { AxiosError } from 'axios';
import { fetchEventSource, EventSourceMessage } from '@microsoft/fetch-event-source';
import { router } from '@/main';
import { clearStoredTokens, getStoredToken, getStoredRefreshToken, storeToken } from './auth';

// API configuration
export const API_CONFIG = {
  host: import.meta.env.VITE_API_URL || '',
  version: 'v1',
  timeout: 30000, // Request timeout in milliseconds
};

// Complete API base URL
export const BASE_URL = API_CONFIG.host 
  ? `${API_CONFIG.host}/api/${API_CONFIG.version}` 
  : `/api/${API_CONFIG.version}`;

// Login page route name/path
const LOGIN_ROUTE = '/login';

// Unified response format
export interface ApiResponse<T> {
  code: number;
  msg: string;
  data: T;
}

// Error format
export interface ApiError {
  code: number;
  message: string;
  details?: unknown;
}

// Create axios instance
export const apiClient = axios.create({
  baseURL: BASE_URL,
  timeout: API_CONFIG.timeout,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor, add authentication token
apiClient.interceptors.request.use(
  (config) => {
    // Add authentication token if available
    const token = getStoredToken();
    if (token && !config.headers.Authorization) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Track if we're currently refreshing token to prevent multiple concurrent requests
let isRefreshing = false;
let failedQueue: any[] = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(({ resolve, reject }) => {
    if (error) {
      reject(error);
    } else {
      resolve(token);
    }
  });
  
  failedQueue = [];
};

/**
 * Redirect to login page using Vue Router
 */
const redirectToLogin = () => {
  // Check if we're already on the login page
  if (window.location.pathname === LOGIN_ROUTE || 
      router.currentRoute.value.path === LOGIN_ROUTE) {
    return; // Already on login page, no need to redirect
  }

  // Use Vue Router to navigate to login page
  setTimeout(() => {
    window.location.href = LOGIN_ROUTE;
  }, 100);
};

/**
 * Common token refresh logic used by both axios interceptor and SSE connections
 */
const refreshAuthToken = async (): Promise<string | null> => {
  if (isRefreshing) {
    // If already refreshing, queue this request
    return new Promise((resolve, reject) => {
      failedQueue.push({ resolve, reject });
    });
  }

  isRefreshing = true;
  const refreshToken = getStoredRefreshToken();
  
  if (!refreshToken) {
    // No refresh token available, clear auth and redirect to login
    clearStoredTokens();
    delete apiClient.defaults.headers.Authorization;
    window.dispatchEvent(new CustomEvent('auth:logout'));
    redirectToLogin();
    isRefreshing = false;
    throw new Error('No refresh token available');
  }

  try {
    // Attempt to refresh token
    const response = await apiClient.post('/auth/refresh', {
      refresh_token: refreshToken
    }, {
      // Add special marker to prevent interceptor from retrying this request
      __isRefreshRequest: true
    } as any);
    
    if (response.data && response.data.data) {
      const newAccessToken = response.data.data.access_token;
      storeToken(newAccessToken);
      
      // Update default headers
      apiClient.defaults.headers.Authorization = `Bearer ${newAccessToken}`;
      
      // Process queued requests
      processQueue(null, newAccessToken);
      
      return newAccessToken;
    } else {
      throw new Error('Invalid refresh response');
    }
  } catch (refreshError) {
    // Refresh token failed, clear tokens and redirect to login
    clearStoredTokens();
    delete apiClient.defaults.headers.Authorization;
    
    processQueue(refreshError, null);
    
    // Emit logout event
    window.dispatchEvent(new CustomEvent('auth:logout'));
    
    // Redirect to login page
    redirectToLogin();
    
    throw refreshError;
  } finally {
    isRefreshing = false;
  }
};

// Response interceptor, unified error handling and token refresh
apiClient.interceptors.response.use(
  (response) => {
    // Check backend response format
    if (response.data && typeof response.data.code === 'number') {
      // If it's a business logic error (code not 0), convert to error handling
      if (response.data.code !== 0) {
        const apiError: ApiError = {
          code: response.data.code,
          message: response.data.msg || 'Unknown error',
          details: response.data
        };
        return Promise.reject(apiError);
      }
    }
    return response;
  },
  async (error: AxiosError) => {
    const originalRequest = error.config as any;
    
    // Skip retry logic for refresh requests to prevent infinite loops
    if (originalRequest.__isRefreshRequest) {
      const apiError: ApiError = {
        code: error.response?.status || 500,
        message: 'Token refresh failed',
        details: error.response?.data
      };
      console.error('Refresh token request failed:', apiError);
      return Promise.reject(apiError);
    }
    
    // Handle 401 Unauthorized errors with token refresh
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const newAccessToken = await refreshAuthToken();
        if (newAccessToken) {
          // Retry original request with new token
          originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
          return apiClient(originalRequest);
        }
      } catch (refreshError) {
        // Token refresh failed, error already handled in refreshAuthToken
        console.error('Token refresh failed:', refreshError);
      }
    }

    const apiError: ApiError = {
      code: 500,
      message: 'Request failed',
    };

    if (error.response) {
      const status = error.response.status;
      apiError.code = status;
      
      // Try to extract detailed error information from response content
      if (error.response.data && typeof error.response.data === 'object') {
        const data = error.response.data as any;
        if (data.code && data.msg) {
          apiError.code = data.code;
          apiError.message = data.msg;
        } else {
          apiError.message = data.message || error.response.statusText || 'Request failed';
        }
        apiError.details = data;
      } else {
        apiError.message = error.response.statusText || 'Request failed';
      }
    } else if (error.request) {
      apiError.code = 503;
      apiError.message = 'Network error, please check your connection';
    }

    console.error('API Error:', apiError);
    return Promise.reject(apiError);
  }
); 

export interface SSECallbacks<T = any> {
  onOpen?: () => void;
  onMessage?: (event: { event: string; data: T }) => void;
  onClose?: () => void;
  onError?: (error: Error) => void;
}

export interface SSEOptions {
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: any;
  headers?: Record<string, string>;
}

/**
 * Handle SSE authentication errors and attempt token refresh
 */
const handleSSEAuthError = async <T = any>(
  _error: Error,
  _endpoint: string,
  _options: SSEOptions,
  callbacks: SSECallbacks<T>
): Promise<boolean> => {
  try {
    const newAccessToken = await refreshAuthToken();
    if (newAccessToken) {
      // Emit event for token refresh success
      window.dispatchEvent(new CustomEvent('auth:token-refreshed'));
      console.log('Token refreshed for SSE connection, will retry connection');
      return true; // Indicate successful refresh
    }
    return false; // No new token obtained
  } catch (refreshError) {
    // Token refresh failed, error already handled in refreshAuthToken
    console.error('SSE token refresh failed:', refreshError);
    if (callbacks.onError) {
      callbacks.onError(refreshError as Error);
    }
    return false; // Indicate failed refresh
  }
};

/**
 * Generic SSE connection function
 * @param endpoint - API endpoint (relative to BASE_URL)
 * @param options - Request options
 * @param callbacks - Event callbacks
 * @returns Function to cancel the SSE connection
 */
export const createSSEConnection = async <T = any>(
  endpoint: string,
  options: SSEOptions = {},
  callbacks: SSECallbacks<T> = {}
): Promise<() => void> => {
  const { onOpen, onMessage, onClose, onError } = callbacks;
  const { 
    method = 'GET', 
    body, 
    headers = {}
  } = options;
  
  // Create AbortController for cancellation
  const abortController = new AbortController();
  
  const apiUrl = `${BASE_URL}${endpoint}`;
  
  // Add authentication headers
  const requestHeaders: Record<string, string> = {
    'Content-Type': 'application/json',
    ...headers,
  };
  
  // Add authentication token if available
  const token = getStoredToken();
  if (token && !requestHeaders.Authorization) {
    requestHeaders.Authorization = `Bearer ${token}`;
  }
  
  // 创建SSE连接
  const createConnection = async (): Promise<void> => {
    return new Promise((_resolve, reject) => {
      if (abortController.signal.aborted) {
        reject(new Error('Connection aborted'));
        return;
      }

      const ssePromise = fetchEventSource(apiUrl, {
        method,
        headers: requestHeaders,
        openWhenHidden: true,
        body: body ? JSON.stringify(body) : undefined,
        signal: abortController.signal,
        async onopen(response) {
          // Check for authentication errors in the initial response
          if (response.status === 401) {
            const authError = new Error('Unauthorized');
            const refreshSuccess = await handleSSEAuthError(authError, endpoint, options, callbacks);
            
            if (refreshSuccess) {
              // Update authorization header with new token
              const newToken = getStoredToken();
              if (newToken) {
                requestHeaders.Authorization = `Bearer ${newToken}`;
                // Retry connection with new token
                setTimeout(() => createConnection().catch(console.error), 1000);
              }
            }
            return;
          }
          
          // Check for other error status codes
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          if (onOpen) {
            onOpen();
          }
        },
        onmessage(event: EventSourceMessage) {
          if (event.event && event.event.trim() !== '') {
            if (onMessage) {
              onMessage({
                event: event.event,
                data: JSON.parse(event.data) as T
              });
            }
          }
        },
        onclose() {
          if (onClose) {
            onClose();
          }
        },
        onerror(err: any) {
          const error = err instanceof Error ? err : new Error(String(err));
          console.error('EventSource error:', error);
          
          if (onError) {
            onError(error);
          }
          reject(error);
        },
      });

      ssePromise.catch(reject);
    });
  };

  createConnection().catch((error) => {
    if (!abortController.signal.aborted) {
      console.error('SSE connection failed:', error);
    }
  });

  return () => {
    abortController.abort();
  };
}; 


================================================
FILE: frontend/src/api/file.ts
================================================
// File API service
import { apiClient, ApiResponse, API_CONFIG } from './client';
import { SignedUrlResponse } from '../types/response';

/**
 * File info type
 */
export interface FileInfo {
  file_id: string;
  filename: string;
  content_type?: string;
  size: number;
  upload_date: string;
  metadata?: Record<string, any>;
}



/**
 * Upload file
 * @param file File to upload
 * @param metadata Optional metadata
 * @returns Upload result
 */
export async function uploadFile(file: File, metadata?: Record<string, any>): Promise<FileInfo> {
  const formData = new FormData();
  formData.append('file', file);
  
  if (metadata) {
    formData.append('metadata', JSON.stringify(metadata));
  }

  const response = await apiClient.post<ApiResponse<FileInfo>>('/files', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });
  return response.data.data;
}

/**
 * Download file
 * @param fileId File ID
 * @returns File download result
 */
export async function downloadFile(fileId: string): Promise<Blob> {
  const response = await apiClient.get(`/files/${fileId}`, {
    responseType: 'blob',
  });
  
  return response.data;
}

/**
 * Delete file
 * @param fileId File ID
 * @returns Success status
 */
export async function deleteFile(fileId: string): Promise<boolean> {
  try {
    await apiClient.delete<ApiResponse<void>>(`/files/${fileId}`);
    return true;
  } catch (error) {
    console.error('Failed to delete file:', error);
    return false;
  }
}

/**
 * Get file information
 * @param fileId File ID
 * @returns File information or null if not found
 */
export async function getFileInfo(fileId: string): Promise<FileInfo | null> {
  try {
    const response = await apiClient.get<ApiResponse<FileInfo>>(`/files/${fileId}`);
    return response.data.data;
  } catch (error) {
    console.error('Failed to get file info:', error);
    return null;
  }
}

/**
 * Create file signed URL
 * @param fileId File ID to create signed URL for
 * @param expireMinutes URL expiration time in minutes (default: 15)
 * @returns Signed URL response for file download
 */
export async function createFileSignedUrl(fileId: string, expireMinutes: number = 15): Promise<SignedUrlResponse> {
  const response = await apiClient.post<ApiResponse<SignedUrlResponse>>(`/files/${fileId}/signed-url`, {
    expire_minutes: expireMinutes
  });
  return response.data.data;
}

/**
 * Get file download URL
 * @param fileId File ID
 * @param expireMinutes URL/Token expiration time in minutes (default: 15)
 * @returns Promise resolving to file download URL string
 */
export async function getFileDownloadUrl(
  fileId: string,
  expireMinutes: number = 15,
): Promise<string> {
  const signedUrlResponse = await createFileSignedUrl(fileId, expireMinutes);
  return `${API_CONFIG.host}${signedUrlResponse.signed_url}`;
}



================================================
FILE: frontend/src/api/index.ts
================================================
// API modules index
export * from './client';
export * from './auth';
export * from './agent';
export * from './file';

// Export commonly used types and functions
export type { ApiResponse, ApiError } from './client';
export type { 
  User, 
  LoginRequest, 
  LoginResponse, 
  RegisterRequest, 
  RegisterResponse,
  ChangePasswordRequest,
  RefreshTokenRequest,
  RefreshTokenResponse,
  AuthStatusResponse,
  UserRole
} from './auth';

// Import and re-export auth initialization function
import { initializeAuth } from './auth';

// Initialize authentication when module is imported
initializeAuth();

export { initializeAuth };

// Export auth composable
export { useAuth } from '../composables/useAuth'; 


================================================
FILE: frontend/src/assets/global.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;


#app {
  display: contents;
}

body,html {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI Variable Display,Segoe UI,Helvetica,Apple Color Emoji,Arial,sans-serif,Segoe UI Emoji,Segoe UI Symbol;
  background-color: var(--background-white-main);
  color: var(--text-primary)
}

.clickable {
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

/* Remove focus outline/blue border */
*:focus {
  outline: none;
}

*:focus-visible {
  outline: none;
}

.ltr\:border-l {
  border-left-width: 1px;
}


================================================
FILE: frontend/src/assets/theme.css
================================================
:root {
    --text-primary: #34322d;
    --text-secondary: #535350;
    --text-tertiary: #858481;
    --text-disable: #b9b9b7;
    --text-brand: #0081f2;
    --text-onblack: #fff;
    --text-white: #fff;
    --text-white-tsp: #ffffff99;
    --theme-text-primary: #262626;
    --logo-color: #34322d;
    --background-gray-main: #f8f8f7;
    --background-white-main: #fff;
    --background-menu-white: #fff;
    --background-tsp-menu-white: #ffffff14;
    --background-tsp-card-gray: #37352f0a;
    --background-nav: #ebebeb;
    --background-card: #fff;
    --background-mask: #000000a6;
    --border-main: #0000000f;
    --border-white: #ffffff0a;
    --border-btn-main: #0000001f;
    --border-input-active: #0081f280;
    --border-light: #0000000a;
    --border-dark: #0000001f;
    --icon-primary: #34322d;
    --icon-secondary: #535350;
    --icon-tertiary: #858481;
    --icon-disable: #b9b9b7;
    --icon-brand: #0081f2;
    --icon-onblack: #fff;
    --icon-white: #fff;
    --icon-white-tsp: #ffffff99;
    --function-error: #f25a5a;
    --function-success: #25ba3b;
    --function-warning: #efa201;
    --function-error-tsp: #f25a5a14;
    --function-warning-tsp: #efa2011f;
    --fill-blue: #0081f214;
    --fill-tsp-white-main: #37352f0f;
    --fill-tsp-white-dark: #37352f14;
    --fill-tsp-white-light: #37352f0a;
    --fill-tsp-gray-dark: #37352f14;
    --fill-tsp-gray-main: #37352f0a;
    --fill-input-chat: #fff;
    --fill-white: #fff;
    --fill-black: #28282973;
    --Button-primary-black: #1a1a19;
    --Button-primary-white: #fff;
    --Button-primary-brand: #0081f2;
    --Button-secondary-brand: #0081f21a;
    --Button-secondary-error-border: #f25a5a80;
    --Button-secondary-error-fill: #fff;
    --Button-secondary-main: #fff;
    --Button-secondary-gray: #37352f0f;
    --tab-fill: rgba(0,0,0,.004);
    --tab-active-black: #1a1a19;
    --shadow-L: #0000003d;
    --shadow-M: #0000001f;
    --shadow-S: #00000014;
    --shadow-XS: #0000000f;
    --Tooltips-main: #000000e6;
    --gradual-white-0: #ffffff00;
    --gradual-gray-100: #ffffff00;
    --gradual-gray-0: #ffffff00;
    --gradual-dark-20: #00000033
}

.dark {
    --text-primary: #dadada;
    --text-secondary: #acacac;
    --text-tertiary: #7f7f7f;
    --text-disable: #5f5f5f;
    --text-brand: #1a93fe;
    --text-onblack: #000000e6;
    --text-white: #fff;
    --text-white-tsp: #ffffff99;
    --theme-text-primary: #dbdbdb;
    --logo-color: #dadada;
    --background-gray-main: #272728;
    --background-white-main: #161618;
    --background-menu-white: #383739;
    --background-tsp-menu-white: #ffffff0f;
    --background-tsp-card-gray: #ffffff0f;
    --background-nav: #212122;
    --background-card: #444345;
    --background-mask: #000000a6;
    --border-main: #ffffff14;
    --border-white: #ffffff0a;
    --border-btn-main: #ffffff1a;
    --border-input-active: #1a93fe80;
    --border-light: #ffffff0f;
    --border-dark: #ffffff29;
    --icon-primary: #dadada;
    --icon-secondary: #acacac;
    --icon-tertiary: #7f7f7f;
    --icon-disable: #5f5f5f;
    --icon-brand: #1a93fe;
    --icon-onblack: #000000d9;
    --icon-white: #fff;
    --icon-white-tsp: #ffffff99;
    --function-error: #eb4d4d;
    --function-success: #5eb92d;
    --function-warning: #ffbf36;
    --function-error-tsp: #eb4d4d14;
    --function-warning-tsp: #ffbf361f;
    --fill-blue: #1a93fe1f;
    --fill-tsp-white-main: #ffffff0f;
    --fill-tsp-white-dark: #ffffff1f;
    --fill-tsp-white-light: #ffffff0a;
    --fill-tsp-gray-dark: #00000047;
    --fill-tsp-gray-main: #00000033;
    --fill-input-chat: #363537;
    --fill-white: #3e3d3e;
    --fill-black: #28282973;
    --Button-primary-black: #fff;
    --Button-primary-white: #ffffff14;
    --Button-primary-brand: #1a93fe;
    --Button-secondary-brand: #1a93fe1f;
    --Button-secondary-error-border: #eb4d4d29;
    --Button-secondary-error-fill: #eb4d4d1f;
    --Button-secondary-main: #ffffff1f;
    --Button-secondary-gray: #ffffff0f;
    --tab-fill: hsla(0,0%,100%,.006);
    --tab-active-black: #fff;
    --shadow-L: #00000066;
    --shadow-M: #0000003d;
    --shadow-S: #00000029;
    --shadow-XS: #0000001f;
    --Tooltips-main: #000000e6;
    --gradual-white-0: #27272800;
    --gradual-gray-100: #444345;
    --gradual-gray-0: #44434500;
    --gradual-dark-20: #ffffff33
}

.dark,:root {
    --color-1: 0 100% 63%;
    --color-2: 270 100% 63%;
    --color-3: 210 100% 63%;
    --color-4: 195 100% 63%;
    --color-5: 90 100% 63%
}


================================================
FILE: frontend/src/components/AttachmentsMessage.vue
================================================
<template>
  <!-- User messages (right-aligned) -->
  <div v-if="content.role === 'user'" class="flex flex-col flex-wrap gap-2 items-end justify-end">
    <div class="flex gap-2 flex-wrap max-w-[568px] justify-end">
      <div v-for="attachment in content.attachments" @click="showFilePanel(attachment)"
        class="flex items-center gap-1.5 p-2 pr-2.5 w-[280px] group/attach relative overflow-hidden cursor-pointer rounded-[12px] border-[0.5px] border-[var(--border-dark)] bg-[var(--background-menu-white)] hover:bg-[--background-tsp-menu-white]">
        <div class="flex items-center justify-center w-8 h-8 rounded-md">
          <div class="relative flex items-center justify-center">
            <component :is="getFileType(attachment.filename).icon" />
          </div>
        </div>
        <div class="flex flex-col gap-0.5 flex-1 min-w-0">
          <div class="flex-1 min-w-0 flex items-center">
            <div
              class="text-sm text-[var(--text-primary)] text-ellipsis overflow-hidden whitespace-nowrap flex-1 min-w-0">
              {{ attachment.filename }}</div>
          </div>
          <div class="text-xs text-[var(--text-tertiary)]">{{ getFileTypeText(attachment.filename) }} · {{
            formatFileSize(attachment.size) }}</div>
        </div>
        <div
          class="items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md w-6 h-6 border border-[var(--border-main)] flex opacity-0 group-hover/attach:opacity-100">
          <Eye class="size-5 w-4 h-4 text-[var(--icon-secondary)]" />
        </div>
      </div>
    </div>
  </div>

  <!-- Assistant messages (left-aligned) -->
  <div v-else class="flex flex-col flex-wrap gap-2 justify-start">
    <div class="flex gap-2 flex-wrap max-w-[568px]">
      <div v-for="attachment in content.attachments" @click="showFilePanel(attachment)"
        class="flex items-center gap-1.5 p-2 pr-2.5 w-[280px] group/attach relative overflow-hidden cursor-pointer rounded-[12px] border-[0.5px] border-[var(--border-dark)] bg-[var(--background-menu-white)] hover:bg-[--background-tsp-menu-white]">
        <div class="flex items-center justify-center w-8 h-8 rounded-md">
          <div class="relative flex items-center justify-center">
            <component :is="getFileType(attachment.filename).icon" />
          </div>
        </div>
        <div class="flex flex-col gap-0.5 flex-1 min-w-0">
          <div class="flex-1 min-w-0 flex items-center">
            <div
              class="text-sm text-[var(--text-primary)] text-ellipsis overflow-hidden whitespace-nowrap flex-1 min-w-0">
              {{ attachment.filename }}</div>
          </div>
          <div class="text-xs text-[var(--text-tertiary)]">{{ getFileTypeText(attachment.filename) }} · {{
            formatFileSize(attachment.size) }}</div>
        </div>
        <div
          class="items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md w-6 h-6 border border-[var(--border-main)] flex opacity-0 group-hover/attach:opacity-100">
          <Eye class="size-5 w-4 h-4 text-[var(--icon-secondary)]" />
        </div>
      </div>
      <button @click="showAllFiles"
        class="h-[54px] pl-4 pr-1.5 flex items-center justify-center gap-1.5 w-[280px] rounded-[12px] border-[0.5px] border-[var(--border-dark)] bg-[var(--background-menu-white)] hover:bg-[var(--background-tsp-menu-white)]">
        <FileSearch :size="16" />
        <span class="text-sm text-[var(--icon-secondary)]">{{ t('View all files in this task') }}</span>
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { FileSearch, Eye } from 'lucide-vue-next';
import { useI18n } from 'vue-i18n';
import type { AttachmentsContent } from '../types/message';
import { formatFileSize, getFileTypeText } from '../utils/fileType';
import { getFileType } from '../utils/fileType';
import { useSessionFileList } from '../composables/useSessionFileList';
import { useFilePanel } from '../composables/useFilePanel';

const { t } = useI18n();
const { showFilePanel } = useFilePanel();
const { showSessionFileList } = useSessionFileList();

defineProps<{
  content: AttachmentsContent;
}>();

const showAllFiles = () => {
  showSessionFileList();
};

</script>


================================================
FILE: frontend/src/components/ChatBox.vue
================================================
<template>
    <div class="pb-3 relative bg-[var(--background-gray-main)]">
        <div
            class="flex flex-col gap-3 rounded-[22px] transition-all relative bg-[var(--fill-input-chat)] py-3 max-h-[300px] shadow-[0px_12px_32px_0px_rgba(0,0,0,0.02)] border border-black/8 dark:border-[var(--border-main)]">
            <ChatBoxFiles ref="chatBoxFileListRef" :attachments="attachments" />
            <div class="overflow-y-auto pl-4 pr-2">
                <textarea
                    class="flex rounded-md border-input focus-visible:outline-none focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 overflow-hidden flex-1 bg-transparent p-0 pt-[1px] border-0 focus-visible:ring-0 focus-visible:ring-offset-0 w-full placeholder:text-[var(--text-disable)] text-[15px] shadow-none resize-none min-h-[40px]"
                    :rows="rows" :value="modelValue"
                    @input="$emit('update:modelValue', ($event.target as HTMLTextAreaElement).value)"
                    @compositionstart="isComposing = true" @compositionend="isComposing = false"
                    @keydown.enter.exact="handleEnterKeydown" :placeholder="t('Give Manus a task to work on...')"
                    :style="{ height: '46px' }"></textarea>
            </div>
            <footer class="flex flex-row justify-between w-full px-3">
                <div class="flex gap-2 pr-2 items-center">
                    <button @click="uploadFile"
                        class="rounded-full border border-[var(--border-main)] inline-flex items-center justify-center gap-1 clickable cursor-pointer text-xs text-[var(--text-secondary)] hover:bg-[var(--fill-tsp-gray-main)] w-8 h-8 p-0 data-[popover-trigger]:bg-[var(--fill-tsp-gray-main)] shrink-0"
                        aria-expanded="false" aria-haspopup="dialog">
                        <Paperclip :size="16" />
                    </button>
                </div>
                <div class="flex gap-2">
                    <button v-if="!isRunning || sendEnabled"
                        class="whitespace-nowrap text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 text-primary-foreground hover:bg-primary/90 p-0 w-8 h-8 rounded-full flex items-center justify-center transition-colors hover:opacity-90"
                        :class="!sendEnabled ? 'cursor-not-allowed bg-[var(--fill-tsp-white-dark)]' : 'cursor-pointer bg-[var(--Button-primary-black)]'"
                        @click="handleSubmit">
                        <SendIcon :disabled="!sendEnabled" />
                    </button>
                    <button v-else @click="handleStop"
                        class="inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring bg-[var(--Button-primary-black)] text-[var(--text-onblack)] gap-[4px] hover:opacity-90 rounded-full p-0 w-8 h-8">
                        <div class="w-[10px] h-[10px] bg-[var(--icon-onblack)] rounded-[2px]">
                        </div>
                    </button>
                </div>
            </footer>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import SendIcon from './icons/SendIcon.vue';
import { useI18n } from 'vue-i18n';
import ChatBoxFiles from './ChatBoxFiles.vue';
import { Paperclip } from 'lucide-vue-next';
import type { FileInfo } from '../api/file';

const { t } = useI18n();
const hasTextInput = ref(false);
const isComposing = ref(false);
const chatBoxFileListRef = ref();

const props = defineProps<{
    modelValue: string;
    rows: number;
    isRunning: boolean;
    attachments: FileInfo[];
}>();

const sendEnabled = computed(() => {
    return chatBoxFileListRef.value?.isAllUploaded && hasTextInput.value;
});

const emit = defineEmits<{
    (e: 'update:modelValue', value: string): void;
    (e: 'submit'): void;
    (e: 'stop'): void;
}>();

const handleEnterKeydown = (event: KeyboardEvent) => {
    if (isComposing.value) {
        // If in input method composition state, do nothing and allow default behavior
        return;
    }

    // Not in input method composition state and has text input, prevent default behavior and submit
    if (sendEnabled.value) {
        event.preventDefault();
        handleSubmit();
    }
};

const handleSubmit = () => {
    if (!sendEnabled.value) return;
    emit('submit');
};

const handleStop = () => {
    emit('stop');
};

const uploadFile = () => {
    chatBoxFileListRef.value?.uploadFile();
};

watch(() => props.modelValue, (value) => {
    hasTextInput.value = value.trim() !== '';
});
</script>


================================================
FILE: frontend/src/components/ChatBoxFiles.vue
================================================
<template>
    <div v-if="files.length > 0" class="w-full relative rounded-md overflow-hidden flex-shrink-0 pb-3 -mb-3">
        <div v-if="canScrollLeft"
            class="absolute top-0 bottom-0 left-0 z-10 flex h-full items-center gap-2.5 px-3 cursor-pointer"
            style="background-image: linear-gradient(270deg, var(--gradual-white-0) 0%, var(--fill-input-chat) 100%);">
            <div
                class="flex h-7 w-7 items-center justify-center rounded-full border border-[var(--border-white)] bg-[var(--background-menu-white)] overflow-hidden cursor-pointer hover:bg-[var(--fill-tsp-primary)] shadow-[0_0_1.25px_0_var(--shadow-M),0_5px_16px_0_var(--shadow-M)] backdrop-blur-[40px]">
                <div @click="scrollLeft"
                    class="flex w-full h-full items-center justify-center bg-[var(--background-menu-white)] cursor-pointer hover:bg-[var(--fill-tsp-white-main)] shadow-[0_0_1.25px_0_var(--shadow-M),0_5px_16px_0_var(--shadow-M)]">
                    <ChevronLeft :size="14" />
                </div>
            </div>
        </div>
        <div ref="scrollContainer" @scroll="onScroll"
            class="w-full overflow-y-hidden overflow-x-auto scrollbar-hide pb-[10px] -mb-[10px] pl-[10px] pr-2 flex">
            <div class="flex gap-3">
                <div v-for="file in files" :key="file.file_id" @click="handleFileClick(file)"
                    class="flex items-center gap-1.5 p-2 pr-2.5 w-[280px] rounded-[10px] bg-[var(--fill-tsp-white-main)] group/attach relative overflow-hidden cursor-pointer hover:bg-[var(--fill-tsp-white-dark)]">
                    <div class="flex items-center justify-center w-8 h-8 rounded-md">
                        <div class="relative flex items-center justify-center">
                            <!-- Loading state -->
                            <LoadingSpinnerIcon v-if="file.status === 'uploading'">
                                <component :is="getFileType(file.filename).icon" />
                            </LoadingSpinnerIcon>
                            <!-- Normal state -->
                            <component v-else :is="getFileType(file.filename).icon" />
                        </div>
                    </div>
                    <div class="flex flex-col gap-0.5 flex-1 min-w-0">
                        <div class="flex-1 min-w-0 flex items-center">
                            <div
                                class="text-sm text-[var(--text-primary)] text-ellipsis overflow-hidden whitespace-nowrap flex-1 min-w-0">
                                {{ file.filename }}</div>
                            <button @click.stop="removeFile(file.file_id)"
                                class="hidden touch-device:flex group-hover/attach:flex rounded-full p-[2px] bg-[var(--icon-tertiary)] transition-all duration-200 hover:opacity-85">
                                <X class="text-white" :size="10" />
                            </button>
                        </div>
                        <div class="text-xs text-[var(--text-tertiary)]">
                            <div v-if="file.status === 'failed'"
                                class="text-[var(--function-error)] text-xs flex items-center gap-1">
                                {{ t('Upload failed') }}
                                <RefreshCcw @click.stop="retryUpload(file)" class="clickable hover:opacity-85 cursor-pointer"
                                    :size="14" />
                            </div>
                            <div v-else-if="file.status === 'uploading'">{{ t('Uploading...') }}</div>
                            <div v-else>{{ getFileTypeText(file.filename) }} · {{ formatFileSize(file.size) }}</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div v-if="canScrollRight"
            class="absolute top-0 bottom-0 right-0 z-10 flex h-full items-center gap-2.5 px-3 cursor-pointer"
            style="background-image: linear-gradient(90deg, var(--gradual-white-0) 0%, var(--fill-input-chat) 100%);">
            <div
                class="flex h-7 w-7 items-center justify-center rounded-full border border-[var(--border-white)] bg-[var(--background-menu-white)] overflow-hidden cursor-pointer hover:bg-[var(--fill-tsp-primary)] shadow-[0_0_1.25px_0_var(--shadow-M),0_5px_16px_0_var(--shadow-M)] backdrop-blur-[40px]">
                <div @click="scrollRight"
                    class="flex w-full h-full items-center justify-center bg-[var(--background-menu-white)] cursor-pointer hover:bg-[var(--fill-tsp-white-main)] shadow-[0_0_1.25px_0_var(--shadow-M),0_5px_16px_0_var(--shadow-M)]">
                    <ChevronRight :size="14" />
                </div>
            </div>
        </div>
    </div>
    <!-- Hidden file input -->
    <input ref="fileInput" type="file" multiple class="hidden" @change="handleFileSelect" />
</template>

<script setup lang="ts">
import { ChevronLeft, ChevronRight } from 'lucide-vue-next';
import type { FileInfo } from '../api/file';
import { uploadFile as apiUploadFile } from '../api/file';
import { getFileType, getFileTypeText, formatFileSize } from '../utils/fileType';
import { useI18n } from 'vue-i18n';
import { ref, nextTick, watch, onMounted, computed } from 'vue';
import { X, RefreshCcw } from 'lucide-vue-next';
import LoadingSpinnerIcon from './icons/LoadingSpinnerIcon.vue';
const { t } = useI18n();
import { useFilePanel } from '../composables/useFilePanel';

const props = defineProps<{
    attachments: FileInfo[];
}>();

const { showFilePanel } = useFilePanel();

// Extended FileInfo type to include upload status
interface ExtendedFileInfo extends FileInfo {
    status?: 'uploading' | 'success' | 'failed';
    file?: File | null; // Keep reference to original file for retry
}

const files = ref<ExtendedFileInfo[]>(props.attachments);
const fileInput = ref<HTMLInputElement>();
const scrollContainer = ref<HTMLElement>();

// Scroll state
const canScrollLeft = ref(false);
const canScrollRight = ref(false);

const uploadFile = () => {
    fileInput.value?.click();
};

const getFiles = () => {
    return files.value;
};

const handleFileSelect = async (event: Event) => {
    const target = event.target as HTMLInputElement;
    const selectedFiles = target.files;

    if (!selectedFiles || selectedFiles.length === 0) {
        return;
    }

    // Process each selected file
    for (const file of Array.from(selectedFiles)) {
        await processFileUpload(file);
    }

    // Clear the input value to allow selecting the same file again
    target.value = '';
};

const processFileUpload = async (file: File) => {
    // Create temporary file info for UI
    const tempFileInfo: ExtendedFileInfo = {
        file_id: `temp-${Date.now()}-${Math.random()}`,
        filename: file.name,
        content_type: file.type,
        size: file.size,
        upload_date: new Date().toISOString(),
        status: 'uploading',
        file: file
    };

    // Add to files list with uploading status
    files.value.push(tempFileInfo);

    try {
        // Upload the file
        const uploadedFile = await apiUploadFile(file);

        // Update the file info with successful upload
        const index = files.value.findIndex(f => f.file_id === tempFileInfo.file_id);
        if (index !== -1) {
            files.value[index] = {
                ...uploadedFile,
                status: 'success',
                file: null
            };
        }
    } catch (error) {
        console.error('Upload failed:', error);

        // Update status to failed
        const index = files.value.findIndex(f => f.file_id === tempFileInfo.file_id);
        if (index !== -1) {
            files.value[index].status = 'failed';
        }
    }
};

const removeFile = (fileId: string) => {
    const index = files.value.findIndex(f => f.file_id === fileId);
    if (index !== -1) {
        files.value.splice(index, 1);
    }
};

const retryUpload = async (fileInfo: ExtendedFileInfo) => {
    if (!fileInfo.file) {
        return;
    }

    // Reset status to uploading
    fileInfo.status = 'uploading';

    try {
        // Retry upload
        const uploadedFile = await apiUploadFile(fileInfo.file);

        // Update with new file info
        const index = files.value.findIndex(f => f.file_id === fileInfo.file_id);
        if (index !== -1) {
            files.value[index] = {
                ...uploadedFile,
                status: 'success',
                file: null
            };
        }
    } catch (error) {
        console.error('Retry upload failed:', error);
        fileInfo.status = 'failed';
    }
};

// Check scroll position and update button visibility
const updateScrollButtons = () => {
    if (!scrollContainer.value) return;

    const container = scrollContainer.value;
    const scrollLeft = container.scrollLeft;
    const scrollWidth = container.scrollWidth;
    const clientWidth = container.clientWidth;

    canScrollLeft.value = scrollLeft > 0;
    canScrollRight.value = scrollLeft < scrollWidth - clientWidth - 5; // 5px tolerance
};

// Handle scroll event
const onScroll = () => {
    updateScrollButtons();
};

const scrollLeft = () => {
    if (scrollContainer.value) {
        scrollContainer.value.scrollBy({
            left: -280, // Approximate width of one file item
            behavior: 'smooth'
        });
    }
};

const scrollRight = () => {
    if (scrollContainer.value) {
        scrollContainer.value.scrollBy({
            left: 280, // Approximate width of one file item
            behavior: 'smooth'
        });
    }
};

// Watch for changes in files to update scroll buttons
watch(files, async () => {
    await nextTick();
    updateScrollButtons();
}, { deep: true });

// Initialize scroll buttons on mount
onMounted(() => {
    nextTick(() => {
        updateScrollButtons();
    });
});

const isAllUploaded = computed(() => {
    return files.value.every(file => file.status === 'success');
});

const handleFileClick = (file: ExtendedFileInfo) => {
    if (file.status === 'success') {
        showFilePanel(file);
    }
};

defineExpose({
    uploadFile,
    getFiles,
    isAllUploaded
});
</script>


================================================
FILE: frontend/src/components/ChatMessage.vue
================================================
<template>
  <div v-if="message.type === 'user'" class="flex w-full flex-col items-end justify-end gap-1 group mt-3">
    <div class="flex items-end">
      <div class="flex items-center justify-end gap-[2px] invisible group-hover:visible">
        <div class="float-right transition text-[12px] text-[var(--text-tertiary)] invisible group-hover:visible">
          {{ relativeTime(message.content.timestamp) }}
        </div>
      </div>
    </div>
    <div class="flex max-w-[90%] relative flex-col gap-2 items-end">
      <div
        class="relative flex items-center rounded-[12px] overflow-hidden bg-[var(--fill-white)] dark:bg-[var(--fill-tsp-white-main)] p-3 ltr:rounded-br-none rtl:rounded-bl-none border border-[var(--border-main)] dark:border-0"
        v-html="renderMarkdown(messageContent.content)">
      </div>
    </div>
  </div>
  <div v-else-if="message.type === 'assistant'" class="flex flex-col gap-2 w-full group mt-3">
    <div class="flex items-center justify-between h-7 group">
      <div class="flex items-center gap-[3px]">
        <Bot :size="24" class="w-6 h-6" />
        <ManusTextIcon />
      </div>
      <div class="flex items-center gap-[2px] invisible group-hover:visible">
        <div class="float-right transition text-[12px] text-[var(--text-tertiary)] invisible group-hover:visible">
          {{ relativeTime(message.content.timestamp) }}
        </div>
      </div>
    </div>
    <div
      class="max-w-none p-0 m-0 prose prose-sm sm:prose-base dark:prose-invert [&_pre:not(.shiki)]:!bg-[var(--fill-tsp-white-light)] [&_pre:not(.shiki)]:text-[var(--text-primary)] text-base text-[var(--text-primary)]"
      v-html="renderMarkdown(messageContent.content)"></div>
  </div>
  <ToolUse v-else-if="message.type === 'tool'" :tool="toolContent" @click="handleToolClick(toolContent)" />
  <div v-else-if="message.type === 'step'" class="flex flex-col">
    <div class="text-sm w-full clickable flex gap-2 justify-between group/header truncate text-[var(--text-primary)]"
      data-event-id="HNtP7XOMUOhPemItd2EkK2">
      <div class="flex flex-row gap-2 justify-center items-center truncate">
        <div v-if="stepContent.status !== 'completed'"
          class="w-4 h-4 flex-shrink-0 flex items-center justify-center border border-[var(--border-dark)] rounded-[15px]">
        </div>
        <div v-else
          class="w-4 h-4 flex-shrink-0 flex items-center justify-center border-[var(--border-dark)] rounded-[15px] bg-[var(--text-disable)] dark:bg-[var(--fill-tsp-white-dark)] border-0">
          <CheckIcon class="text-[var(--icon-white)] dark:text-[var(--icon-white-tsp)]" :size="10" />
        </div>
        <div class="truncate font-medium markdown-content"
          v-html="stepContent.description ? renderMarkdown(stepContent.description) : ''">
        </div>
        <span class="flex-shrink-0 flex" @click="isExpanded = !isExpanded;">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
            class="lucide lucide-chevron-down transition-transform duration-300 w-4 h-4"
            :class="{ 'rotate-180': isExpanded }">
            <path d="m6 9 6 6 6-6"></path>
          </svg>
        </span>
      </div>
      <div class="float-right transition text-[12px] text-[var(--text-tertiary)] invisible group-hover/header:visible">
        {{ relativeTime(message.content.timestamp) }}
      </div>
    </div>
    <div class="flex">
      <div class="w-[24px] relative">
        <div class="border-l border-dashed border-[var(--border-dark)] absolute start-[8px] top-0 bottom-0"
          style="height: calc(100% + 14px);"></div>
      </div>
      <div
        class="flex flex-col gap-3 flex-1 min-w-0 overflow-hidden pt-2 transition-[max-height,opacity] duration-150 ease-in-out"
        :class="{ 'max-h-[100000px] opacity-100': isExpanded, 'max-h-0 opacity-0': !isExpanded }">
        <ToolUse v-for="(tool, index) in stepContent.tools" :key="index" :tool="tool" @click="handleToolClick(tool)" />
      </div>
    </div>
  </div>
  <AttachmentsMessage v-else-if="message.type === 'attachments'" :content="attachmentsContent"/>
</template>

<script setup lang="ts">
import ManusTextIcon from './icons/ManusTextIcon.vue';
import { Message, MessageContent, AttachmentsContent } from '../types/message';
import ToolUse from './ToolUse.vue';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import { CheckIcon } from 'lucide-vue-next';
import { computed, ref } from 'vue';
import { ToolContent, StepContent } from '../types/message';
import { useRelativeTime } from '../composables/useTime';
import { Bot } from 'lucide-vue-next';
import AttachmentsMessage from './AttachmentsMessage.vue';


const props = defineProps<{
  message: Message;
  sessionId?: string;
}>();

const emit = defineEmits<{
  (e: 'toolClick', tool: ToolContent): void;
}>();

const handleToolClick = (tool: ToolContent) => {
  emit('toolClick', tool);
};

// For backward compatibility, provide the original computed properties
const stepContent = computed(() => props.message.content as StepContent);
const messageContent = computed(() => props.message.content as MessageContent);
const toolContent = computed(() => props.message.content as ToolContent);
const attachmentsContent = computed(() => props.message.content as AttachmentsContent);

// Control content expand/collapse state
const isExpanded = ref(true);

const { relativeTime } = useRelativeTime();

// Render Markdown to HTML and sanitize
const renderMarkdown = (text: string) => {
  if (typeof text !== 'string') return '';
  const html = marked(text) as string;
  return DOMPurify.sanitize(html);
};
</script>

<style>
.duration-300 {
  animation-duration: .3s;
}

.duration-300 {
  transition-duration: .3s;
}
</style>



================================================
FILE: frontend/src/components/FilePanel.vue
================================================
<template>
  <div
    ref="filePanelRef"
    v-if="visible"
    :class="{
      'h-full w-full top-0 ltr:right-0 rtl:left-0 z-50 fixed sm:sticky sm:top-0 sm:h-[100vh]': isShow,
      'h-full overflow-hidden': !isShow 
    }"
    :style="{ 'width': isShow ? `${parentSize/2}px` : '0px', 'opacity': isShow ? '1' : '0', 'transition': '0.2s ease-in-out' }">
    <div class="h-full" :style="{ 'width': isShow ? '100%' : '0px' }">
      <div v-if="isShow && fileInfo && fileType" class="bg-[var(--background-gray-main)] overflow-hidden shadow-[0px_0px_8px_0px_rgba(0,0,0,0.02)] ltr:border-l rtl:border-r border-black/8 dark:border-[var(--border-light)] flex flex-col h-full w-full">
        <div
          class="px-4 pt-2 pb-4 gap-4 flex items-center justify-between flex-shrink-0 border-b border-[var(--border-main)] flex-col-reverse md:flex-row md:py-4">
          <div class="flex justify-between self-stretch flex-1 truncate">
            <div
              class="flex flex-row gap-1 items-center text-[var(--text-secondary)] font-medium truncate [&amp;_svg]:flex-shrink-0">
              <a href="" class="p-1 flex-shrink-0 cursor-default" target="_blank">
                <div class="relative flex items-center justify-center">
                  <component :is="fileType.icon" />
                </div>
              </a>
              <div class="truncate flex flex-col"><span class="truncate" :title="fileInfo.filename">{{ fileInfo.filename }}</span></div>
            </div>
          </div>
          <div class="flex items-center justify-between gap-2 w-full py-3 md:w-auto md:py-0 select-none">
            <div class="flex items-center gap-2">
              <div @click="download"
                class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md"
                aria-expanded="false" aria-haspopup="dialog">
                <Download class="text-[var(--icon-secondary)] size-[18px]" />
              </div>
            </div>
            <div class="flex items-center gap-2">
              <div @click="hideFilePanel"
                class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md">
                <X class="size-5 text-[var(--icon-secondary)]" />
              </div>
            </div>
          </div>
        </div>
        <component :is="fileType.preview" :file="fileInfo" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onUnmounted } from 'vue'
import { Download, X } from 'lucide-vue-next'
import { useFilePanel } from '../composables/useFilePanel'
import { getFileDownloadUrl } from '../api/file'
import { getFileType } from '../utils/fileType'
import { useResizeObserver } from '../composables/useResizeObserver'
import { eventBus } from '../utils/eventBus'
import { EVENT_SHOW_TOOL_PANEL } from '../constants/event'


const {
  isShow,
  fileInfo,
  visible,
  showFilePanel,
  hideFilePanel
} = useFilePanel()

const filePanelRef = ref<HTMLElement>()
const { size: parentSize } = useResizeObserver(filePanelRef, {
  target: 'parent',
  property: 'width'
})

const fileType = computed(() => {
  if (!fileInfo.value) return null
  return getFileType(fileInfo.value.filename)
})

const download = async () => {
  if (!fileInfo.value) return
  const url = await getFileDownloadUrl(fileInfo.value.file_id)
  window.open(url, '_blank')
}

onMounted(() => {
  eventBus.on(EVENT_SHOW_TOOL_PANEL, () => {
    visible.value = false
  })
})

onUnmounted(() => {
  eventBus.off(EVENT_SHOW_TOOL_PANEL)
})

defineExpose({
  showFilePanel,
  hideFilePanel,
  isShow
})
</script>



================================================
FILE: frontend/src/components/FilePanelContent.vue
================================================
<template>
      <div class="bg-[var(--background-gray-main)] overflow-hidden shadow-[0px_0px_8px_0px_rgba(0,0,0,0.02)] ltr:border-l rtl:border-r border-black/8 dark:border-[var(--border-light)] flex flex-col h-full w-full">
        <div
          class="px-4 pt-2 pb-4 gap-4 flex items-center justify-between flex-shrink-0 border-b border-[var(--border-main)] flex-col-reverse md:flex-row md:py-4">
          <div class="flex justify-between self-stretch flex-1 truncate">
            <div
              class="flex flex-row gap-1 items-center text-[var(--text-secondary)] font-medium truncate [&amp;_svg]:flex-shrink-0">
              <a href="" class="p-1 flex-shrink-0 cursor-default" target="_blank">
                <div class="relative flex items-center justify-center">
                  <component :is="fileType.icon" />
                </div>
              </a>
              <div class="truncate flex flex-col"><span class="truncate" :title="file.filename">{{ file.filename }}</span></div>
            </div>
          </div>
          <div class="flex items-center justify-between gap-2 w-full py-3 md:w-auto md:py-0 select-none">
            <div class="flex items-center gap-2">
              <div @click="download"
                class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md"
                aria-expanded="false" aria-haspopup="dialog">
                <Download class="text-[var(--icon-secondary)] size-[18px]" />
              </div>
            </div>
            <div class="flex items-center gap-2">
              <div @click="hide"
                class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md">
                <X class="size-5 text-[var(--icon-secondary)]" />
              </div>
            </div>
          </div>
        </div>
        <component :is="fileType.preview" :file="file" />
      </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { Download, X } from 'lucide-vue-next';
import type { FileInfo } from '../api/file';
import { getFileDownloadUrl } from '../api/file';
import { getFileType } from '../utils/fileType';

const props = defineProps<{
  file: FileInfo;
}>();

const emit = defineEmits<{
  (e: 'hide'): void
}>();

const hide = () => {
  emit('hide');
};

const fileType = computed(() => {
  return getFileType(props.file.filename);
});

const download = async () => {
  const url = await getFileDownloadUrl(props.file.file_id);
  window.open(url, '_blank');
};
</script>



================================================
FILE: frontend/src/components/LeftPanel.vue
================================================
<template>
  <div :class="isLeftPanelShow ?
    'h-full flex flex-col' :
    'h-full flex flex-col fixed top-0 start-0 bottom-0 z-[1]'" :style="isLeftPanelShow ?
      'width: 300px; transition: width 0.28s cubic-bezier(0.4, 0, 0.2, 1);' :
      'width: 24px; transition: width 0.36s cubic-bezier(0.4, 0, 0.2, 1);'">
    <div
      :class="isLeftPanelShow ?
        'flex flex-col overflow-hidden bg-[var(--background-nav)] h-full opacity-100 translate-x-0' :
        'flex flex-col overflow-hidden bg-[var(--background-nav)] fixed top-1 start-1 bottom-1 z-[1] border-1 dark:border-[1px] border-[var(--border-main)] dark:border-[var(--border-light)] rounded-xl shadow-[0px_8px_32px_0px_rgba(0,0,0,0.16),0px_0px_0px_1px_rgba(0,0,0,0.06)] opacity-0 pointer-events-none -translate-x-10'"
      :style="(isLeftPanelShow ? 'width: 300px;' : 'width: 0px;') + ' transition: opacity 0.2s, transform 0.2s, width 0.2s;'">
      <div class="flex">
        <div class="flex items-center px-3 py-3 flex-row h-[52px] gap-1 justify-end w-full">
          <div class="flex justify-between w-full px-1 pt-2">
            <div class="relative flex">
              <div
                class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md"
                @click="toggleLeftPanel">
                <PanelLeft class="h-5 w-5 text-[var(--icon-secondary)]" />
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="px-3 mb-1 flex justify-center flex-shrink-0">
        <button @click="handleNewTaskClick"
          class="flex min-w-[36px] w-full items-center justify-center gap-1.5 rounded-lg h-[32px] bg-[var(--Button-primary-white)] hover:bg-white/20 dark:hover:bg-black/60 cursor-pointer shadow-[0px_0.5px_3px_0px_var(--shadow-S)]">
          <Plus class="h-4 w-4 text-[var(--icon-primary)]" />
          <span class="text-sm font-medium text-[var(--text-primary)] whitespace-nowrap truncate">
            {{ t('New Task') }}
          </span>
          <div class="flex items-center gap-0.5">
            <span
              class="flex text-[var(--text-tertiary)] justify-center items-center min-w-5 h-5 px-1 rounded-[4px] bg-[var(--fill-tsp-white-light)] border border-[var(--border-light)]">
              <Command :size="14" />
            </span>
            <span
              class="flex justify-center items-center w-5 h-5 px-1 rounded-[4px] bg-[var(--fill-tsp-white-light)] border border-[var(--border-light)] text-sm font-normal text-[var(--text-tertiary)] ">
              K
            </span>
          </div>
        </button>
      </div>
      <div v-if="sessions.length > 0" class="flex flex-col flex-1 min-h-0 overflow-auto pt-2 pb-5 overflow-x-hidden">
        <SessionItem v-for="session in sessions" :key="session.session_id" :session="session"
          @deleted="handleSessionDeleted" />
      </div>
      <div v-else class="flex flex-1 flex-col items-center justify-center gap-4">
        <div class="flex flex-col items-center gap-2 text-[var(--text-tertiary)]">
          <MessageSquareDashed :size="38" />
          <span class="text-sm font-medium">{{ t('Create a task to get started') }}</span></div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { PanelLeft, Plus, Command, MessageSquareDashed } from 'lucide-vue-next';
import SessionItem from './SessionItem.vue';
import { useLeftPanel } from '../composables/useLeftPanel';
import { ref, onMounted, watch, onUnmounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { getSessionsSSE, getSessions } from '../api/agent';
import { ListSessionItem } from '../types/response';
import { useI18n } from 'vue-i18n';

const { t } = useI18n()
const { isLeftPanelShow, toggleLeftPanel } = useLeftPanel()
const route = useRoute()
const router = useRouter()

const sessions = ref<ListSessionItem[]>([])
const cancelGetSessionsSSE = ref<(() => void) | null>(null)

// Function to fetch sessions data
const updateSessions = async () => {
  try {
    const response = await getSessions()
    sessions.value = response.sessions
  } catch (error) {
    console.error('Failed to fetch sessions:', error)
  }
}

// Function to fetch sessions data
const fetchSessions = async () => {
  try {
    if (cancelGetSessionsSSE.value) {
      cancelGetSessionsSSE.value()
      cancelGetSessionsSSE.value = null
    }
    cancelGetSessionsSSE.value = await getSessionsSSE({
      onOpen: () => {
        console.log('Sessions SSE opened')
      },
      onMessage: (event) => {
        sessions.value = event.data.sessions
      },
      onError: (error) => {
        console.error('Failed to fetch sessions:', error)
      },
      onClose: () => {
        console.log('Sessions SSE closed')
      }
    })
  } catch (error) {
    console.error('Failed to fetch sessions:', error)
  }
}

const handleNewTaskClick = () => {
  router.push('/')
}

const handleSessionDeleted = (sessionId: string) => {
  console.log('handleSessionDeleted', sessionId)
  sessions.value = sessions.value.filter(session => session.session_id !== sessionId);
}

// Handle keyboard shortcuts
const handleKeydown = (event: KeyboardEvent) => {
  // Check for Command + K (Mac) or Ctrl + K (Windows/Linux)
  if ((event.metaKey || event.ctrlKey) && event.key === 'k') {
    event.preventDefault()
    handleNewTaskClick()
  }
}

onMounted(async () => {
  // Initial fetch of sessions
  fetchSessions()

  // Add keyboard event listener
  window.addEventListener('keydown', handleKeydown)
})

onUnmounted(() => {
  if (cancelGetSessionsSSE.value) {
    cancelGetSessionsSSE.value()
    cancelGetSessionsSSE.value = null
  }

  // Remove keyboard event listener
  window.removeEventListener('keydown', handleKeydown)
})

watch(() => route.path, async () => {
  await updateSessions()
})
</script>



================================================
FILE: frontend/src/components/PlanPanel.vue
================================================
<template>
  <div class="[&:not(:empty)]:pb-2 bg-[var(--background-gray-main)] rounded-[22px_22px_0px_0px]">
    <div v-if="isExpanded"
      class="border border-black/8 dark:border-[var(--border-main)] bg-[var(--background-menu-white)] rounded-[16px] sm:rounded-[12px] shadow-[0px_0px_1px_0px_rgba(0,_0,_0,_0.05),_0px_8px_32px_0px_rgba(0,_0,_0,_0.04)] z-99 flex flex-col py-4">
      <div class="flex px-4 mb-4 w-full">
        <div class="flex items-start ml-auto">
          <div class="flex items-center justify-center gap-2">
            <div @click="togglePanel"
              class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md">
              <ChevronDown class="text-[var(--icon-tertiary)]" :size="16" />
            </div>
          </div>
        </div>
      </div>
      <div class="px-4">
        <div class="bg-[var(--fill-tsp-gray-main)] rounded-lg pt-4 pb-2">
          <div class="flex justify-between w-full px-4">
            <span class="text-[var(--text-primary)] font-bold">{{ $t('Task Progress') }}</span>
            <div class="flex items-center gap-3">
              <span class="text-xs text-[var(--text-tertiary)]">{{ planProgress }}</span>
            </div>
          </div>
          <div class="max-h-[min(calc(100vh-360px),400px)] overflow-y-auto">
            <div v-for="step in plan.steps" :key="step.id"
              class="flex items-start gap-2.5 w-full px-4 py-2 truncate">
              <StepSuccessIcon v-if="step.status === 'completed'" />
              <Clock v-else class="relative top-[2px] flex-shrink-0" :size="16" />
              <div class="flex flex-col w-full gap-[2px] truncate">
                <div class="text-sm truncate" :title="step.description"
                  style="color: var(--text-primary);">
                  {{ step.description }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div v-if="!isExpanded" @click="togglePanel"
      class="flex flex-row items-start justify-between pe-3 relative clickable border border-black/8 dark:border-[var(--border-main)] bg-[var(--background-menu-white)] rounded-[16px] sm:rounded-[12px] shadow-[0px_0px_1px_0px_rgba(0,_0,_0,_0.05),_0px_8px_32px_0px_rgba(0,_0,_0,_0.04)] z-99">
      <div class="flex-1 min-w-0 relative overflow-hidden">
        <div class="w-full" style="height: 36px; --offset: -36px;">
          <div class="w-full">
            <div class="flex items-start gap-2.5 w-full px-4 py-2 truncate">
              <StepSuccessIcon v-if="isCompleted" />
              <Clock v-else class="relative top-[2px] flex-shrink-0" :size="16" />
              <div class="flex flex-col w-full gap-[2px] truncate">
                <div class="text-sm truncate" :title="currentStep" style="color: var(--text-tertiary);">
                  {{ currentStep }}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <button
        class="flex h-full cursor-pointer justify-center gap-2 hover:opacity-80 flex-shrink-0 items-start py-2.5">
        <span class="text-xs text-[var(--text-tertiary)] hidden sm:flex">{{ planProgress }}</span>
        <ChevronUp class="text-[var(--icon-tertiary)]" :size="16" />
      </button>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useI18n } from 'vue-i18n';
import { ChevronUp, ChevronDown, Clock } from 'lucide-vue-next';
import StepSuccessIcon from './icons/StepSuccessIcon.vue';
import type { PlanEventData } from '../types/event';

interface Props {
  plan: PlanEventData;
}

const props = defineProps<Props>();

const { t } = useI18n();

const isExpanded = ref(false);

const togglePanel = () => {
  isExpanded.value = !isExpanded.value;
};

const planProgress = computed((): string => {
  const completedSteps = props.plan?.steps.filter(step => step.status === 'completed').length ?? 0;
  return `${completedSteps} / ${props.plan?.steps.length ?? 1}`;
});

const isCompleted = computed((): boolean => {
  return props.plan?.steps.every(step => step.status === 'completed') ?? false;
});

const currentStep = computed((): string => {
  for (const step of props.plan?.steps ?? []) {
    if (step.status === 'running' || step.status === 'pending') {
      return step.description;
    }
  }
  return t('Task Completed');
});
</script>

<style scoped>
.\[\&\:not\(\:empty\)\]\:pb-2:not(:empty) {
  padding-bottom: .5rem;
}
</style> 


================================================
FILE: frontend/src/components/SessionFileList.vue
================================================
<template>
    <div class="absolute z-[1000] pointer-events-auto" v-if="visible">
        <div class="w-full h-full bg-black/60 backdrop-blur-[4px] fixed inset-0 data-[state=open]:animate-dialog-bg-fade-in data-[state=closed]:animate-dialog-bg-fade-out"
            style="position: fixed; overflow: auto; inset: 0px;" @click="hideSessionFileList"></div>
        <div role="dialog"
            class="bg-[var(--background-menu-white)] rounded-[20px] border border-white/5 fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 max-w-[95%] max-h-[95%] overflow-auto data-[state=open]:animate-dialog-slide-in-from-bottom data-[state=closed]:animate-dialog-slide-out-to-bottom h-[680px] flex flex-col"
            style="width: 600px;">
            <div class="p-0">
                <h3 class="text-[var(--text-primary)] text-[18px] leading-[24px] font-semibold flex items-center"></h3>
            </div>
            <header class="flex items-center pt-6 pr-6 pl-6 pb-2.5">
                <h1 class="flex-1 text-[var(--text-primary)] text-lg font-semibold">{{ $t('All Files in This Task') }}</h1>
                <div class="flex items-center gap-4">
                    <div @click="hideSessionFileList"
                        class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md">
                        <X class="size-5 text-[var(--icon-tertiary)]" />
                    </div>
                </div>
            </header>
            <div class="flex-1 min-h-0 flex flex-col">
                <div v-if="files.length > 0" class="flex-1 min-h-0 overflow-auto px-3 mt-4 pb-4">
                    <div class="flex flex-col gap-1 first:pt-0 pt-2">
                        <div class="">
                            <div v-for="file in files" 
                                class="flex items-center gap-3 px-3 py-2.5 hover:bg-[var(--fill-tsp-gray-main)] transition-colors rounded-lg clickable">
                                <div class="relative flex items-center justify-center">
                                    <component :is="getFileType(file.filename).icon" />
                                </div>
                                <div @click="showFile(file)" class="flex flex-col gap-1 flex-grow flex-1 min-w-0">
                                    <div class="flex justify-between items-center flex-1 min-w-0">
                                        <div class="flex flex-col flex-1 min-w-0 max-w-[100%]">
                                            <div class="flex-1 min-w-0 flex gap-2 items-center">
                                                <span
                                                    class="inline-block whitespace-nowrap text-sm text-[var(--text-primary)]"
                                                    style="overflow: hidden; text-overflow: ellipsis;">{{ file.filename
                                                    }}</span>
                                                <div class="flex gap-2 flex-shrink-0 items-center"></div>
                                            </div>
                                            <span class="text-xs text-[var(--text-tertiary)]">{{
                                                formatRelativeTime(parseISODateTime(file.upload_date)) }}</span>
                                        </div>
                                        <div @click="downloadFile(file.file_id)"
                                            class="flex items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md w-8 h-8 text-[var(--icon-tertiary)]"
                                            aria-expanded="false" aria-haspopup="dialog">
                                            <Download class="size-5 text-[var(--icon-tertiary)]" />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div v-else class="flex-1 min-h-0 flex flex-col items-center justify-center gap-3">
                    <File />
                    <p class="text-[var(--icon-tertiary)] text-[14px]">{{ $t('No Content') }}</p>
                </div>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { X, Download, File } from 'lucide-vue-next';
import { ref, watch } from 'vue';
import { useRoute } from 'vue-router';
import type { FileInfo } from '../api/file';
import { getFileDownloadUrl } from '../api/file';
import { getSessionFiles } from '../api/agent';
import { formatRelativeTime, parseISODateTime } from '../utils/time';
import { getFileType } from '../utils/fileType';
import { useSessionFileList } from '../composables/useSessionFileList';
import { useFilePanel } from '../composables/useFilePanel';

const route = useRoute();
const files = ref<FileInfo[]>([]);

const { showFilePanel } = useFilePanel();

const { visible, hideSessionFileList } = useSessionFileList();

const fetchFiles = async (sessionId: string) => {
    if (!sessionId) {
        return;
    }
    const response = await getSessionFiles(sessionId);
    files.value = response;
}

const downloadFile = async (fileId: string) => {
    const url = await getFileDownloadUrl(fileId);
    window.open(url, '_blank');
}

const showFile = (file: FileInfo) => {
    showFilePanel(file);
    hideSessionFileList();
}

watch(visible, (newVisible) => {
    if (newVisible) {
        const sessionId = route.params.sessionId as string;
        if (sessionId) {
            fetchFiles(sessionId);
        }
    }
})
</script>


================================================
FILE: frontend/src/components/SessionItem.vue
================================================
<template>
  <div class="px-2">
    <div @click="handleSessionClick"
      class="group flex h-14 cursor-pointer items-center gap-2 rounded-[10px] px-2 transition-colors"
      :class="isCurrentSession ? 'bg-[var(--background-white-main)]' : 'hover:bg-[var(--fill-tsp-gray-main)]'">
      <div class="relative">
        <div class="h-8 w-8 rounded-full flex items-center justify-center relative bg-[var(--fill-tsp-white-dark)]">
          <div class="relative h-4 w-4 object-cover brightness-0 opacity-75 dark:opacity-100 dark:brightness-100">
            <img alt="Hello" class="w-full h-full object-cover" src="/chatting.svg">
          </div>
        </div>
        <div v-if="session.status === SessionStatus.RUNNING || session.status === SessionStatus.PENDING"
          class="absolute -start-[5px] -top-[3px] w-[calc(100%+8px)] h-[calc(100%+8px)]"
          style="transform: rotateY(180deg);">
          <SpinnigIcon />
        </div>
        <div v-if="session.unread_message_count > 0 && !isCurrentSession"
          class="flex h-4 min-w-[16px] items-center justify-center rounded-full bg-[var(--function-error)] absolute -end-1 -top-1">
          <span class="px-1 text-xs text-[var(--text-white)]">{{ session.unread_message_count }}</span>
        </div>
      </div>
      <div class="min-w-20 flex-1 transition-opacity opacity-100">
        <div class="flex items-center gap-1 overflow-x-hidden">
          <span class="truncate text-sm font-medium text-[var(--text-primary)] flex-1 min-w-0"
            :title="session.title || t('New Chat')">
            <span class="">
              {{ session.title || t('New Chat') }}
            </span>
          </span>
          <span class="text-[var(--text-tertiary)] text-xs whitespace-nowrap">
            {{ session.latest_message_at ? customTime(session.latest_message_at) : '' }}
          </span>
        </div>
        <div class="flex items-center gap-2 h-[18px] relative">
          <span class="min-w-0 flex-1 truncate text-xs text-[var(--text-tertiary)]"
            :title="session.latest_message || ''">
            {{ session.latest_message }}
          </span>
          <div @click="handleSessionMenuClick"
            class="w-[22px] h-[22px] flex rounded-[6px] items-center justify-center pointer cursor-pointer border border-[var(--border-main)] shadow-sm group-hover:visible touch-device:visible"
            :class="!isContextMenuOpen ? 'invisible bg-[var(--background-menu-white)]' : 'visible bg-[var(--fill-tsp-gray-dark)]'"
            aria-expanded="false" aria-haspopup="dialog">
            <Ellipsis :size="16" />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { Ellipsis } from 'lucide-vue-next';
import { computed, ref } from 'vue';
import { useI18n } from 'vue-i18n';
import { useRoute, useRouter } from 'vue-router';
import { useCustomTime } from '../composables/useTime';
import { ListSessionItem, SessionStatus } from '../types/response';
import SpinnigIcon from './icons/SpinnigIcon.vue';
import { useContextMenu, createDangerMenuItem } from '../composables/useContextMenu';
import { useDialog } from '../composables/useDialog';
import { deleteSession } from '../api/agent';
import { showSuccessToast, showErrorToast } from '../utils/toast';
import { Trash } from 'lucide-vue-next';

interface Props {
  session: ListSessionItem;
}

const props = defineProps<Props>();

const { t } = useI18n();
const { customTime } = useCustomTime();
const route = useRoute();
const router = useRouter();
const { showContextMenu } = useContextMenu();
const { showConfirmDialog } = useDialog();
const isContextMenuOpen = ref(false);

const emit = defineEmits<{
  (e: 'deleted', sessionId: string): void
}>();

const currentSessionId = computed(() => {
  return route.params.sessionId as string;
});

const isCurrentSession = computed(() => {
  return currentSessionId.value === props.session.session_id;
});

const handleSessionClick = () => {
  router.push(`/chat/${props.session.session_id}`);
};

const handleSessionMenuClick = (event: MouseEvent) => {
  event.stopPropagation();

  const target = event.currentTarget as HTMLElement;
  isContextMenuOpen.value = true;

  showContextMenu(props.session.session_id, target, [
    createDangerMenuItem('delete', t('Delete'), { icon: Trash }),
  ], (itemKey: string, _: string) => {
    if (itemKey === 'delete') {
      showConfirmDialog({
        title: t('Are you sure you want to delete this session?'),
        content: t('The chat history of this session cannot be recovered after deletion.'),
        confirmText: t('Delete'),
        cancelText: t('Cancel'),
        confirmType: 'danger',
        onConfirm: () => {
          deleteSession(props.session.session_id).then(() => {
            showSuccessToast(t('Deleted successfully'));
            emit('deleted', props.session.session_id);
          }).catch(() => {
            showErrorToast(t('Failed to delete session'));
          });
          if (isCurrentSession.value) {
            router.push('/');
          }
        }
      })
    }
  }, (_: string) => {
    isContextMenuOpen.value = false;
  });
};
</script>


================================================
FILE: frontend/src/components/SimpleBar.vue
================================================
<template>
    <div data-simplebar="init" class="[&_.simplebar-scrollbar]:opacity-0 [&_.simplebar-scrollbar::before]:w-[var(--simplebar-scrollbar-width)] [&_.simplebar-scrollbar::before]:bg-[var(--text-disable)] [&_.simplebar-track.simplebar-vertical]:w-[calc(var(--simplebar-scrollbar-width)+2px)] [&_.simplebar-track.simplebar-vertical]:mr-1 [&:hover_.simplebar-scrollbar]:opacity-100 [&:hover_.simplebar-scrollbar::before]:bg-[var(--text-tertiary)] [&_.simplebar-track.simplebar-vertical.simplebar-hover_.simplebar-scrollbar::before]:bg-[var(--text-tertiary)] [&_.simplebar-content-wrapper]:flex [&_.simplebar-content-wrapper]:flex-col [&_.simplebar-content-wrapper]:h-full [&_.simplebar-content]:flex [&_.simplebar-content]:flex-1 flex flex-1 min-w-0 h-full [&_.simplebar-content]:flex-row simplebar-scrollable-y"
        style="--simplebar-scrollbar-width: 6px;">
        <div class="simplebar-wrapper" :style="{ margin: 0 }">
            <div class="simplebar-height-auto-observer-wrapper">
                <div class="simplebar-height-auto-observer"></div>
            </div>
            <div class="simplebar-mask">
                <div class="simplebar-offset" :style="{ right: '0px', bottom: '0px' }">
                    <div ref="contentWrapperRef" class="simplebar-content-wrapper" tabIndex="0" role="region"
                        aria-label="scrollable content" :style="{ height: '100%', overflow: 'hidden scroll' }"
                        @scroll="handleScroll">
                        <div class="simplebar-content" :style="{ padding: '0px' }">
                            <slot></slot>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';

const emit = defineEmits(['scroll']);
const contentWrapperRef = ref<HTMLElement | null>(null);

const handleScroll = (event: Event) => {
    emit('scroll', event);
};

const scrollToBottom = () => {
    if (contentWrapperRef.value) {
        contentWrapperRef.value.scrollTop = contentWrapperRef.value.scrollHeight;
    }
};

const isScrolledToBottom = (threshold = 10) => {
    if (!contentWrapperRef.value) return false;
    const { scrollTop, scrollHeight, clientHeight } = contentWrapperRef.value;
    return scrollHeight - scrollTop - clientHeight <= threshold;
};

const canScroll = () => {
    if (!contentWrapperRef.value) return false;
    return contentWrapperRef.value.scrollHeight > contentWrapperRef.value.clientHeight;
};

defineExpose({
    scrollToBottom,
    isScrolledToBottom,
    canScroll
});
</script>
<style>
[data-simplebar] {
    position: relative;
    flex-direction: column;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-content: flex-start;
    align-items: flex-start
}

.simplebar-wrapper {
    overflow: hidden;
    width: inherit;
    height: inherit;
    max-width: inherit;
    max-height: inherit
}

.simplebar-mask {
    direction: inherit;
    overflow: hidden;
    width: auto !important;
    height: auto !important;
    z-index: 0
}

.simplebar-mask,
.simplebar-offset {
    position: absolute;
    padding: 0;
    margin: 0;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0
}

.simplebar-offset {
    direction: inherit !important;
    box-sizing: inherit !important;
    resize: none !important;
    -webkit-overflow-scrolling: touch
}

.simplebar-content-wrapper {
    direction: inherit;
    box-sizing: border-box !important;
    position: relative;
    display: block;
    height: 100%;
    width: auto;
    max-width: 100%;
    max-height: 100%;
    overflow: auto;
    scrollbar-width: none;
    -ms-overflow-style: none
}

.simplebar-content-wrapper::-webkit-scrollbar,
.simplebar-hide-scrollbar::-webkit-scrollbar {
    display: none;
    width: 0;
    height: 0
}

.simplebar-content:after,
.simplebar-content:before {
    content: " ";
    display: table
}

.simplebar-placeholder {
    max-height: 100%;
    max-width: 100%;
    width: 100%;
    pointer-events: none
}

.simplebar-height-auto-observer-wrapper {
    box-sizing: inherit !important;
    height: 100%;
    width: 100%;
    max-width: 1px;
    position: relative;
    float: left;
    max-height: 1px;
    overflow: hidden;
    z-index: -1;
    padding: 0;
    margin: 0;
    pointer-events: none;
    flex-grow: inherit;
    flex-shrink: 0;
    flex-basis: 0
}

.simplebar-height-auto-observer {
    box-sizing: inherit;
    display: block;
    opacity: 0;
    top: 0;
    left: 0;
    height: 1000%;
    width: 1000%;
    min-height: 1px;
    min-width: 1px;
    z-index: -1
}

.simplebar-height-auto-observer,
.simplebar-track {
    position: absolute;
    overflow: hidden;
    pointer-events: none
}

.simplebar-track {
    z-index: 1;
    right: 0;
    bottom: 0
}

[data-simplebar].simplebar-dragging,
[data-simplebar].simplebar-dragging .simplebar-content {
    pointer-events: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none
}

[data-simplebar].simplebar-dragging .simplebar-track {
    pointer-events: all
}

.simplebar-scrollbar {
    position: absolute;
    left: 0;
    right: 0;
    min-height: 10px
}

.simplebar-scrollbar:before {
    position: absolute;
    content: "";
    background: #000;
    border-radius: 7px;
    opacity: 0;
    transition: opacity .2s linear .5s
}

.simplebar-scrollbar.simplebar-visible:before {
    opacity: .5;
    transition-delay: 0s;
    transition-duration: 0s
}

.simplebar-track.simplebar-vertical {
    top: 0;
    width: 11px
}

.simplebar-scrollbar:before {
    top: 2px;
    bottom: 2px;
    left: 2px;
    right: 2px
}

.simplebar-track.simplebar-horizontal {
    left: 0;
    height: 11px
}

.simplebar-track.simplebar-horizontal .simplebar-scrollbar {
    right: auto;
    left: 0;
    top: 0;
    bottom: 0;
    min-height: 0;
    min-width: 10px;
    width: auto
}

[data-simplebar-direction=rtl] .simplebar-track.simplebar-vertical {
    right: auto;
    left: 0
}

.simplebar-dummy-scrollbar-size {
    direction: rtl;
    position: fixed;
    opacity: 0;
    visibility: hidden;
    height: 500px;
    width: 500px;
    overflow-y: hidden;
    overflow-x: scroll;
    -ms-overflow-style: scrollbar !important
}

.simplebar-dummy-scrollbar-size>div {
    width: 200%;
    height: 200%;
    margin: 10px 0
}

.simplebar-hide-scrollbar {
    position: fixed;
    left: 0;
    visibility: hidden;
    overflow-y: scroll;
    scrollbar-width: none;
    -ms-overflow-style: none
}
</style>


================================================
FILE: frontend/src/components/TakeOverView.vue
================================================
<template>
    <div v-if="shouldShow" class="fixed bg-[var(--background-gray-main)] z-50 transition-all w-full h-full inset-0">
        <div class="w-full h-full">
            <VNCViewer 
                :session-id="sessionId"
                :enabled="shouldShow"
                :view-only="false"
                @connected="onVNCConnected"
                @disconnected="onVNCDisconnected"
                @credentials-required="onVNCCredentialsRequired"
            />
        </div>
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2">
            <button @click="exitTakeOver"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring hover:opacity-90 active:opacity-80 bg-[var(--Button-primary-black)] text-[var(--text-onblack)] h-[36px] px-[12px] gap-[6px] text-sm rounded-full border-2 border-[var(--border-dark)] shadow-[0px_8px_32px_0px_rgba(0,0,0,0.32)]">
                <span class="text-sm font-medium text-[var(--text-onblack)]">{{ t('Exit Takeover') }}</span>
            </button>
        </div>
    </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onBeforeUnmount } from 'vue';
import { useRoute } from 'vue-router';
import { useI18n } from 'vue-i18n';
import VNCViewer from './VNCViewer.vue';

const route = useRoute();
const { t } = useI18n();

// Takeover state
const takeOverActive = ref(false);
const currentSessionId = ref('');



// Listen to takeover events
const handleTakeOverEvent = (event: Event) => {
    const customEvent = event as CustomEvent;
    takeOverActive.value = customEvent.detail.active;
    currentSessionId.value = customEvent.detail.sessionId;
};

// VNC event handlers
const onVNCConnected = () => {
    console.log('TakeOver VNC connection successful');
};

const onVNCDisconnected = (reason?: any) => {
    console.log('TakeOver VNC connection disconnected', reason);
};

const onVNCCredentialsRequired = () => {
    console.log('TakeOver VNC credentials required');
};

// Calculate whether to show takeover view
const shouldShow = computed(() => {
    // Check component state first (from takeover event)
    if (takeOverActive.value && currentSessionId.value) {
        return true;
    }
    
    // Also check route parameters (for direct URL access or page refresh)
    const { params: { sessionId }, query: { vnc } } = route;
    // Only show if both sessionId exists in route AND vnc=1 in query
    return !!sessionId && vnc === '1';
});

// Add event listener when component is mounted
onMounted(() => {
    window.addEventListener('takeover', handleTakeOverEvent as EventListener);
});



// Remove event listener when component is unmounted
onBeforeUnmount(() => {
    window.removeEventListener('takeover', handleTakeOverEvent as EventListener);
});

// Get session ID
const sessionId = computed(() => {
    return currentSessionId.value || route.params.sessionId as string || '';
});

// Exit takeover functionality
const exitTakeOver = () => {
    // Update local state
    takeOverActive.value = false;
    currentSessionId.value = '';
};

// Expose sessionId for parent component to use
defineExpose({
    sessionId
});
</script>

<style scoped>
</style>


================================================
FILE: frontend/src/components/ToolPanel.vue
================================================
<template>
  <div
    ref="toolPanelRef"
    v-if="visible"
    :class="{
      'h-full w-full top-0 ltr:right-0 rtl:left-0 z-50 fixed sm:sticky sm:top-0 sm:right-0 sm:h-[100vh] sm:ml-3 sm:py-3 sm:mr-4': isShow,
      'h-full overflow-hidden': !isShow 
    }"
    :style="{ 'width': isShow ? `${parentSize/2}px` : '0px', 'opacity': isShow ? '1' : '0', 'transition': '0.2s ease-in-out' }">
    <div class="h-full" :style="{ 'width': isShow ? '100%' : '0px' }">
      <ToolPanelContent v-if="isShow && toolContent" :sessionId="sessionId" :realTime="realTime" :toolContent="toolContent" :live="live" @hide="hideToolPanel" @jumpToRealTime="jumpToRealTime" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import type { ToolContent } from '../types/message'
import ToolPanelContent from './ToolPanelContent.vue'
import { useResizeObserver } from '../composables/useResizeObserver'
import { eventBus } from '../utils/eventBus'
import { EVENT_SHOW_FILE_PANEL, EVENT_SHOW_TOOL_PANEL } from '../constants/event'

const toolPanelRef = ref<HTMLElement>()
const { size: parentSize } = useResizeObserver(toolPanelRef, {
  target: 'parent',
  property: 'width'
})

// Tool panel state
const isShow = ref(false)
const live = ref(false)
const toolContent = ref<ToolContent>()
const visible = ref(true)

const emit = defineEmits<{
  (e: 'jumpToRealTime'): void
}>()

defineProps<{
  sessionId?: string
  realTime: boolean
}>()

const showToolPanel = (content: ToolContent, isLive: boolean = false) => {
  eventBus.emit(EVENT_SHOW_TOOL_PANEL)
  visible.value = true
  toolContent.value = content
  isShow.value = true
  live.value = isLive
}

const hideToolPanel = () => {
  isShow.value = false
}

const jumpToRealTime = () => {
  emit('jumpToRealTime')
}

onMounted(() => {
  eventBus.on(EVENT_SHOW_FILE_PANEL, () => {
    visible.value = false
  })
})

onUnmounted(() => {
  eventBus.off(EVENT_SHOW_FILE_PANEL)
})

defineExpose({
  showToolPanel,
  hideToolPanel,
  isShow
})
</script>



================================================
FILE: frontend/src/components/ToolPanelContent.vue
================================================
<template>
  <div class="bg-[var(--background-gray-main)] sm:bg-[var(--background-menu-white)] sm:rounded-[22px] shadow-[0px_0px_8px_0px_rgba(0,0,0,0.02)] border border-black/8 dark:border-[var(--border-light)] flex h-full w-full">
    <div class="flex-1 min-w-0 p-4 flex flex-col h-full">
      <div class="flex items-center gap-2 w-full">
        <div class="text-[var(--text-primary)] text-lg font-semibold flex-1">{{ $t('Manus Computer') }}</div>
        <button
          class="w-7 h-7 relative rounded-md inline-flex items-center justify-center gap-2.5 cursor-pointer hover:bg-[var(--fill-tsp-gray-main)]">
          <Minimize2 class="w-5 h-5 text-[var(--icon-tertiary)]" @click="hide" />
        </button>
      </div>
      <div v-if="toolInfo" class="flex items-center gap-2 mt-2">
        <div
          class="w-[40px] h-[40px] bg-[var(--fill-tsp-gray-main)] rounded-lg flex items-center justify-center flex-shrink-0">
          <component :is="toolInfo.icon" :size="28" />
        </div>
        <div class="flex-1 flex flex-col gap-1 min-w-0">
          <div class="text-[12px] text-[var(--text-tertiary)]">{{ $t('Manus is using') }} <span
              class="text-[var(--text-secondary)]">{{ toolInfo.name }}</span></div>
          <div title="{{ toolInfo.function }} {{ toolInfo.functionArg }}"
            class="max-w-[100%] w-[max-content] truncate text-[13px] rounded-full inline-flex items-center px-[10px] py-[3px] border border-[var(--border-light)] bg-[var(--fill-tsp-gray-main)] text-[var(--text-secondary)]">
            {{ toolInfo.function }}<span
              class="flex-1 min-w-0 px-1 ml-1 text-[12px] font-mono max-w-full text-ellipsis overflow-hidden whitespace-nowrap text-[var(--text-tertiary)]"><code>{{ toolInfo.functionArg }}</code></span>
          </div>
        </div>
      </div>
      <div
        class="flex flex-col rounded-[12px] overflow-hidden bg-[var(--background-gray-main)] border border-[var(--border-dark)] dark:border-black/30 shadow-[0px_4px_32px_0px_rgba(0,0,0,0.04)] flex-1 min-h-0 mt-[16px]">
        <component v-if="toolInfo" :is="toolInfo.view" :live="live" :sessionId="sessionId"
          :toolContent="toolContent" />
        <div class="mt-auto flex w-full items-center gap-2 px-4 h-[44px] relative" v-if="!realTime">
          <button
            class="h-10 px-3 border border-[var(--border-main)] flex items-center gap-1 bg-[var(--background-white-main)] hover:bg-[var(--background-gray-main)] shadow-[0px_5px_16px_0px_var(--shadow-S),0px_0px_1.25px_0px_var(--shadow-S)] rounded-full cursor-pointer absolute left-[50%] translate-x-[-50%]"
            style="bottom: calc(100% + 10px);" @click="jumpToRealTime">
            <PlayIcon :size="16" />
            <span class="text-[var(--text-primary)] text-sm font-medium">{{ $t('Jump to live') }}</span>
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { toRef } from 'vue';
import { Minimize2, PlayIcon } from 'lucide-vue-next';
import type { ToolContent } from '@/types/message';
import { useToolInfo } from '@/composables/useTool';

const props = defineProps<{
  sessionId?: string;
  realTime: boolean;
  toolContent: ToolContent;
  live: boolean;
}>();

const { toolInfo } = useToolInfo(toRef(props, 'toolContent'));

const emit = defineEmits<{
  (e: 'jumpToRealTime'): void,
  (e: 'hide'): void
}>();

const hide = () => {
  emit('hide');
};


const jumpToRealTime = () => {
  emit('jumpToRealTime');
};
</script>



================================================
FILE: frontend/src/components/ToolUse.vue
================================================
<template>
  <p v-if="tool.name === 'message' && tool.args?.text" class="text-[var(--text-secondary)] text-[14px] overflow-hidden text-ellipsis whitespace-pre-line">
    {{ tool.args.text }}
  </p>
  <div v-else-if="toolInfo" class="flex items-center group gap-2">
    <div class="flex-1 min-w-0">
      <div @click="handleClick"
        class="rounded-[15px] items-center gap-2 px-[10px] py-[3px] border border-[var(--border-light)] bg-[var(--fill-tsp-gray-main)] inline-flex max-w-full clickable hover:bg-[var(--fill-tsp-gray-dark)] dark:hover:bg-white/[0.02]">
        <div class="w-[16px] inline-flex items-center text-[var(--text-primary)]">
          <component :is="toolInfo.icon" :size="21" />
        </div>
        <div class="flex-1 h-full min-w-0 flex">
          <div
            class="inline-flex items-center h-full rounded-full text-[14px] text-[var(--text-secondary)] max-w-[100%]">
            <div class="max-w-[100%] text-ellipsis overflow-hidden whitespace-nowrap text-[13px]"
              :title="`${toolInfo.function}${toolInfo.functionArg}`">
              <div class="flex items-center">
                {{ toolInfo.function
                }}<span
                  class="flex-1 min-w-0 rounded-[6px] px-1 ml-1 relative top-[0px] text-[12px] font-mono max-w-full text-ellipsis overflow-hidden whitespace-nowrap text-[var(--text-tertiary)]"><code>{{ toolInfo.functionArg }}</code></span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="float-right transition text-[12px] text-[var(--text-tertiary)] invisible group-hover:visible">
      {{ relativeTime(tool.timestamp) }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";
import { ToolContent } from "../types/message";
import { useToolInfo } from "../composables/useTool";
import { useRelativeTime } from "../composables/useTime";

const props = defineProps<{
  tool: ToolContent;
}>();

const emit = defineEmits<{
  (e: "click"): void;
}>();

const { relativeTime } = useRelativeTime();
const { toolInfo } = useToolInfo(ref(props.tool));

const handleClick = () => {
  emit("click");
};
</script>



================================================
FILE: frontend/src/components/UserMenu.vue
================================================
<template>
    <div class="pointer-events-auto cursor-default">
        <div class="min-w-max inline-block transition-[transform,opacity,scale] duration-150" tabindex="-1"
            role="dialog">
            <div
                class="flex w-[300px] flex-col bg-[var(--background-menu-white)] rounded-[20px] border-[0.5px] border-[var(--border-dark)] shadow-[0px_8px_32px_0px_var(--shadow-XS)]">
                <div class="flex gap-2 px-4 pt-5 pb-3 w-full">
                    <div class="relative flex items-center justify-center font-bold cursor-pointer flex-shrink-0">
                        <div class="relative flex items-center justify-center font-bold flex-shrink-0 rounded-full overflow-hidden"
                            style="width: 48px; height: 48px; font-size: 24px; color: rgba(255, 255, 255, 0.9); background-color: rgb(59, 130, 246);">
                            {{ avatarLetter }}</div>
                    </div>
                    <div class="flex overflow-hidden flex-col justify-center">
                        <div class="flex gap-1 items-center w-full"><span
                                class="text-[var(--text-primary)] text-base font-semibold leading-[22px] truncate">{{
                                    currentUser?.fullname || t('Unknown User') }}</span></div><span
                            class="text-[var(--text-tertiary)] text-[13px] font-normal leading-[18px] truncate">{{
                                currentUser?.email || t('No email') }}</span>
                    </div>
                </div>
                <div class="flex flex-col gap-3 px-3 pb-3">
                    <div class="flex flex-col gap-1">
                        <div class="w-full h-[1px] my-1 bg-[var(--border-main)]"></div>
                        <div
                            class="flex gap-3 items-center p-2 rounded-lg cursor-pointer text-[var(--text-primary)] hover:bg-[var(--fill-tsp-white-main)]"
                            @click="handleAccountClick">
                            <div class="flex-shrink-0 w-5 h-5">
                                <User :size="20" />
                            </div>
                            <span
                                class="overflow-hidden flex-1 text-sm font-medium leading-5 whitespace-nowrap text-ellipsis">{{
                                t('Account') }}</span>
                        </div>
                        <div
                            class="flex gap-3 items-center p-2 rounded-lg cursor-pointer text-[var(--text-primary)] hover:bg-[var(--fill-tsp-white-main)]"
                            @click="handleSettingsClick">
                            <div class="flex-shrink-0 w-5 h-5">
                                <Settings2 :size="20" />
                            </div>
                            <span
                                class="overflow-hidden flex-1 text-sm font-medium leading-5 whitespace-nowrap text-ellipsis">{{
                                t('Settings') }}</span>
                        </div>
                        <div class="w-full h-[1px] my-1 bg-[var(--border-main)]"></div>
                        <div v-if="authProvider !== 'none'"
                            class="flex gap-3 items-center p-2 rounded-lg cursor-pointer hover:bg-[var(--fill-tsp-white-main)] text-[var(--function-error)]"
                            @click="handleLogout">
                            <div class="flex-shrink-0 w-5 h-5">
                                <LogOut :size="20" />
                            </div>
                            <span
                                class="overflow-hidden flex-1 text-sm font-medium leading-5 whitespace-nowrap text-ellipsis">{{
                                t('Logout') }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { computed, onMounted, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useI18n } from 'vue-i18n';
import { useAuth } from '../composables/useAuth';
import { useSettingsDialog } from '../composables/useSettingsDialog';
import { getCachedAuthProvider } from '../api/auth';
import { LogOut, User, Settings2 } from 'lucide-vue-next';

const router = useRouter();
const { t } = useI18n();
const { currentUser, logout } = useAuth();
const { openSettingsDialog } = useSettingsDialog();
const authProvider = ref<string | null>(null);

// Get first letter of user's fullname for avatar display
const avatarLetter = computed(() => {
    return currentUser.value?.fullname?.charAt(0)?.toUpperCase() || 'M';
});

// Handle Account click - open settings dialog with account tab
const handleAccountClick = () => {
    openSettingsDialog('account');
};

// Handle Settings click - open settings dialog with settings tab
const handleSettingsClick = () => {
    openSettingsDialog('settings');
};

// Handle logout action
const handleLogout = async () => {
    try {
        await logout();
        router.push('/login');
    } catch (error) {
        console.error('Logout failed:', error);
    }
};

onMounted(async () => {
    authProvider.value = await getCachedAuthProvider();
});
</script>


================================================
FILE: frontend/src/components/VNCViewer.vue
================================================
<template>
  <div
    ref="vncContainer"
    class="vnc-container"
    style="display: flex; width: 100%; height: 100%; overflow: auto; background: rgb(40, 40, 40);">
  </div>
</template>

<script setup lang="ts">
import { ref, onBeforeUnmount, watch } from 'vue';
import { getVNCUrl } from '@/api/agent';
// @ts-ignore
import RFB from '@novnc/novnc/lib/rfb';

const props = defineProps<{
  sessionId: string;
  enabled?: boolean;
  viewOnly?: boolean;
}>();

const emit = defineEmits<{
  connected: [];
  disconnected: [reason?: any];
  credentialsRequired: [];
}>();

const vncContainer = ref<HTMLDivElement | null>(null);
let rfb: RFB | null = null;

const initVNCConnection = async () => {
  if (!vncContainer.value || !props.enabled) return;

  // Disconnect existing connection
  if (rfb) {
    rfb.disconnect();
    rfb = null;
  }

  try {
    const wsUrl = await getVNCUrl(props.sessionId);

    // Create NoVNC connection
    rfb = new RFB(vncContainer.value, wsUrl, {
      credentials: { password: '' },
      shared: true,
      repeaterID: '',
      wsProtocols: ['binary'],
      // Scaling options
      scaleViewport: true,  // Automatically scale to fit container
      //resizeSession: true   // Request server to adjust resolution
    });

    // Set viewOnly based on props, default to false (interactive)
    rfb.viewOnly = props.viewOnly ?? false;
    rfb.scaleViewport = true;
    //rfb.resizeSession = true;

    rfb.addEventListener('connect', () => {
      console.log('VNC connection successful');
      emit('connected');
    });

    rfb.addEventListener('disconnect', (e: any) => {
      console.log('VNC connection disconnected', e);
      emit('disconnected', e);
    });

    rfb.addEventListener('credentialsrequired', () => {
      console.log('VNC credentials required');
      emit('credentialsRequired');
    });
  } catch (error) {
    console.error('Failed to initialize VNC connection:', error);
  }
};

const disconnect = () => {
  if (rfb) {
    rfb.disconnect();
    rfb = null;
  }
};

// Watch for session ID or enabled state changes
watch([() => props.sessionId, () => props.enabled], () => {
  if (props.enabled && vncContainer.value) {
    initVNCConnection();
  } else {
    disconnect();
  }
}, { immediate: true });

// Watch for container availability
watch(vncContainer, () => {
  if (vncContainer.value && props.enabled) {
    initVNCConnection();
  }
});

onBeforeUnmount(() => {
  disconnect();
});

// Expose methods for parent component
defineExpose({
  disconnect,
  initConnection: initVNCConnection
});
</script>

<style scoped>
</style>



================================================
FILE: frontend/src/components/filePreviews/CodeFilePreview.vue
================================================
<template>
    <section style="display: flex; position: relative; text-align: initial; width: 100%; height: 100%;">
        <div class="w-full h-full" data-keybinding-context="9" data-mode-id="c"
            style="width: 100%; --vscode-editorCodeLens-lineHeight: 15px; --vscode-editorCodeLens-fontSize: 10px; --vscode-editorCodeLens-fontFeatureSettings: 'liga' off, 'calt' off;">

          <MonacoEditor
            :value="content"
            :filename="file.filename"
            :read-only="true"
            theme="vs"
            :line-numbers="'off'"
            :word-wrap="'on'"
            :minimap="false"
            :scroll-beyond-last-line="false"
            :automatic-layout="true"
          />
        </div>
    </section>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import MonacoEditor from '@/components/ui/MonacoEditor.vue';
import type { FileInfo } from '../../api/file';
import { downloadFile } from '../../api/file';

const content = ref('');

const props = defineProps<{
    file: FileInfo;
}>();

watch(() => props.file.file_id, async (fileId) => {
    if (!fileId) return;
    try {
        const blob = await downloadFile(fileId);
        const text = await blob.text();
        content.value = text;
    } catch (error) {
        console.error('Failed to load file content:', error);
        content.value = '(Failed to load file content)';
    }
}, { immediate: true });
</script>


================================================
FILE: frontend/src/components/filePreviews/ImageFilePreview.vue
================================================
<template>
    <div class="flex flex-col items-center justify-center gap-6 flex-1 w-full min-h-0">
        <img :src="imageUrl" alt="Image" class="w-full h-full object-contain" />
    </div>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';
import { getFileDownloadUrl } from '../../api/file';
import type { FileInfo } from '../../api/file';

const props = defineProps<{
    file: FileInfo;
}>();

const imageUrl = ref('');

watch(() => props.file.file_id, async (fileId) => {
    if (!fileId) return;
    imageUrl.value = await getFileDownloadUrl(fileId);
}, { immediate: true });
</script>


================================================
FILE: frontend/src/components/filePreviews/MarkdownFilePreview.vue
================================================
<template>
    <div class="relative overflow-auto flex-1 min-h-0 p-5">
        <div class="relative w-full max-w-[768px] mx-auto" style="min-height: calc(-200px + 100vh);">
            <div class="prose prose-gray max-w-none dark:prose-invert" 
                 v-html="renderedContent">
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import type { FileInfo } from '../../api/file';
import { downloadFile } from '../../api/file';

const content = ref('');

const props = defineProps<{
    file: FileInfo;
}>();

// Configure marked options
marked.setOptions({
    breaks: true,
    gfm: true,
});

// Compute rendered HTML content
const renderedContent = computed(() => {
    if (!content.value) return '';
    try {
        const html = marked.parse(content.value);
        return DOMPurify.sanitize(html as string);
    } catch (error) {
        console.error('Failed to render markdown:', error);
        return `<pre class="text-sm text-red-500">Failed to render markdown content</pre>`;
    }
});

watch(() => props.file.file_id, async (fileId) => {
    if (!fileId) return;
    try {
        const blob = await downloadFile(fileId);
        const text = await blob.text();
        content.value = text;
    } catch (error) {
        console.error('Failed to load file content:', error);
        content.value = '(Failed to load file content)';
    }
}, { immediate: true });
</script>


================================================
FILE: frontend/src/components/filePreviews/UnknownFilePreview.vue
================================================
<template>
    <div class="flex flex-col items-center justify-center gap-6 flex-1 w-full min-h-0">
        <div class="flex items-center gap-1.5 rounded-[10px] bg-[var(--fill-tsp-gray-main)] px-2 py-2 w-[280px]">
            <div class="relative flex items-center justify-center">
                <component :is="fileType.icon" />
            </div>
            <div class="flex flex-col gap-0.5 flex-1 min-w-0">
                <div class="text-sm text-[var(--text-primary)] truncate">{{ file.filename }}</div>
                <div class="text-xs text-[var(--text-tertiary)] truncate">{{ getFileTypeText(file.filename) }}</div>
            </div>
        </div>
        <div class="text-sm text-center text-[var(--text-tertiary)]">{{ t('This format cannot be previewed') }}。<br>{{
            t('Please download the file to view its content') }}。
        </div>
        <button @click="download"
            class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring hover:opacity-90 active:opacity-80 bg-[var(--Button-primary-black)] text-[var(--text-onblack)] h-[36px] px-[12px] rounded-[10px] gap-[6px] text-sm">
            <Download :size="16" />
            <span class="text-sm ">{{ t('Download') }}</span>
        </button>
    </div>
</template>

<script setup lang="ts">
import { Download } from 'lucide-vue-next';
import { useI18n } from 'vue-i18n';
import { computed } from 'vue';
import type { FileInfo } from '../../api/file';
import { getFileDownloadUrl } from '../../api/file';
import { getFileType, getFileTypeText } from '../../utils/fileType';

const { t } = useI18n();

const props = defineProps<{
    file: FileInfo;
}>();

const fileType = computed(() => {
  return getFileType(props.file.filename);
});

const download = async () => {
  const url = await getFileDownloadUrl(props.file.file_id);
  window.open(url, '_blank');
};
</script>


================================================
FILE: frontend/src/components/icons/AttachmentIcon.vue
================================================
<template>
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
        stroke="var(--icon-secondary)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="lucide lucide-paperclip">
        <path d="M13.234 20.252 21 12.3"></path>
        <path
            d="m16 6-8.414 8.586a2 2 0 0 0 0 2.828 2 2 0 0 0 2.828 0l8.414-8.586a4 4 0 0 0 0-5.656 4 4 0 0 0-5.656 0l-8.415 8.585a6 6 0 1 0 8.486 8.486">
        </path>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/BrowserIcon.vue
================================================
<template>
    <svg :width="size" :height="size" viewBox="0 0 19 18" fill="none" xmlns="http://www.w3.org/2000/svg"
        :style="{ minWidth: `${size}px`, minHeight: `${size}px` }">
        <g filter="url(#filter0_ii_1527_83610)">
            <rect x="1.5" y="1.5" width="15" height="15" rx="7.5" fill="url(#paint0_linear_1527_83610)"></rect>
        </g>
        <rect x="1.92857" y="1.92857" width="14.1429" height="14.1429" rx="7.07143" stroke="#B9B9B7"
            stroke-width="0.857143"></rect>
        <path
            d="M7.52172 7.76297C7.56208 7.65057 7.65057 7.56208 7.76297 7.52172L11.2014 6.28681C11.5197 6.17249 11.8274 6.48026 11.7131 6.79854L10.4776 10.2365C10.4373 10.3488 10.3488 10.4373 10.2365 10.4776L6.79854 11.7131C6.48026 11.8274 6.17249 11.5197 6.28681 11.2014L7.52172 7.76297Z"
            stroke="#535350" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"></path>
        <defs>
            <filter id="filter0_ii_1527_83610" x="1" y="1" width="16" height="16" filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB">
                <feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood>
                <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="1" dy="1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.6 0"></feColorMatrix>
                <feBlend mode="normal" in2="shape" result="effect1_innerShadow_1527_83610"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="-1" dy="-1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0"></feColorMatrix>
                <feBlend mode="normal" in2="effect1_innerShadow_1527_83610" result="effect2_innerShadow_1527_83610">
                </feBlend>
            </filter>
            <linearGradient id="paint0_linear_1527_83610" x1="9" y1="1.5" x2="9" y2="16.5"
                gradientUnits="userSpaceOnUse">
                <stop stop-color="white" stop-opacity="0"></stop>
                <stop offset="1" stop-opacity="0.16"></stop>
            </linearGradient>
        </defs>
    </svg>
</template>

<script setup lang="ts">
defineProps({
    size: {
        type: Number,
        default: 21
    }
});
</script>


================================================
FILE: frontend/src/components/icons/ClearIcon.vue
================================================
<template>
    <svg 
        :width="size" 
        :height="size" 
        viewBox="0 0 16 16" 
        fill="none" 
        :style="{ minWidth: `${size}px`, minHeight: `${size}px` }"
        :color="color"
    >
        <g clip-path="url(#clearIconClipPath)">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd"
                d="M7.99994 0.733322C3.98667 0.733322 0.733276 3.98672 0.733276 7.99999C0.733276 12.0133 3.98667 15.2667 7.99994 15.2667C12.0132 15.2667 15.2666 12.0133 15.2666 7.99999C15.2666 3.98672 12.0132 0.733322 7.99994 0.733322ZM6.42421 5.57573C6.18989 5.34141 5.80999 5.34141 5.57568 5.57573C5.34136 5.81004 5.34136 6.18994 5.57568 6.42425L7.15141 7.99999L5.57568 9.57572C5.34136 9.81004 5.34136 10.1899 5.57568 10.4243C5.80999 10.6586 6.18989 10.6586 6.42421 10.4243L7.99994 8.84852L9.57568 10.4243C9.80999 10.6586 10.1899 10.6586 10.4242 10.4243C10.6585 10.1899 10.6585 9.81004 10.4242 9.57572L8.84847 7.99999L10.4242 6.42425C10.6585 6.18994 10.6585 5.81004 10.4242 5.57573C10.1899 5.34141 9.80999 5.34141 9.57568 5.57573L7.99994 7.15146L6.42421 5.57573Z"
                fill="currentColor"
            />
        </g>
        <defs>
            <clipPath id="clearIconClipPath">
                <rect width="16" height="16" fill="white" />
            </clipPath>
        </defs>
    </svg>
</template>

<script setup lang="ts">
defineProps({
    size: {
        type: Number,
        default: 16
    },
    color: {
        type: String,
        default: 'var(--icon-tertiary)'
    }
});
</script>



================================================
FILE: frontend/src/components/icons/CodeFileIcon.vue
================================================
<template>
    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
            d="M3.55566 26.8889C3.55566 28.6071 4.94856 30 6.66678 30H25.3334C27.0517 30 28.4446 28.6071 28.4446 26.8889V9.77778L20.6668 2H6.66678C4.94856 2 3.55566 3.39289 3.55566 5.11111V26.8889Z"
            fill="#4999E9"></path>
        <path opacity="0.8"
            d="M20.6685 6.66647C20.6685 8.38469 22.0613 9.77759 23.7796 9.77759H28.4462L20.6685 1.99981V6.66647Z"
            fill="#7CBDFF"></path>
        <g opacity="0.9">
            <path
                d="M12.2146 23.0075C10.8351 21.6055 9.41533 20.2051 8.00342 18.8399C9.32659 17.5371 10.7038 16.1826 12.0868 14.8106C12.4508 15.1731 12.8166 15.5372 13.1831 15.9025C12.1737 16.9083 11.1695 17.9061 10.19 18.8828C11.2178 19.8927 12.2378 20.9105 13.2498 21.9361C12.9037 22.2922 12.5586 22.6494 12.2146 23.0075Z"
                fill="white"></path>
            <path
                d="M20.1101 22.9923C19.7678 22.6361 19.4246 22.2809 19.0803 21.9267C20.0955 20.9008 21.1189 19.883 22.1503 18.8735C21.173 17.9015 20.17 16.9067 19.1604 15.9025C19.5269 15.5378 19.8925 15.1745 20.2562 14.8131C21.6404 16.1831 23.0167 17.5325 24.3368 18.8272C22.9219 20.1886 21.4969 21.5883 20.1101 22.9923Z"
                fill="white"></path>
            <path d="M15.8827 24.1754H14.4272L16.5372 13.7883H18.0544L15.8827 24.1754Z" fill="white"></path>
            <path
                d="M12.2146 23.0075C10.8351 21.6055 9.41533 20.2051 8.00342 18.8399C9.32659 17.5371 10.7038 16.1826 12.0868 14.8106C12.4508 15.1731 12.8166 15.5372 13.1831 15.9025C12.1737 16.9083 11.1695 17.9061 10.19 18.8828C11.2178 19.8927 12.2378 20.9105 13.2498 21.9361C12.9037 22.2922 12.5586 22.6494 12.2146 23.0075Z"
                stroke="white" stroke-width="0.233333"></path>
            <path
                d="M20.1101 22.9923C19.7678 22.6361 19.4246 22.2809 19.0803 21.9267C20.0955 20.9008 21.1189 19.883 22.1503 18.8735C21.173 17.9015 20.17 16.9067 19.1604 15.9025C19.5269 15.5378 19.8925 15.1745 20.2562 14.8131C21.6404 16.1831 23.0167 17.5325 24.3368 18.8272C22.9219 20.1886 21.4969 21.5883 20.1101 22.9923Z"
                stroke="white" stroke-width="0.233333"></path>
            <path d="M15.8827 24.1754H14.4272L16.5372 13.7883H18.0544L15.8827 24.1754Z" stroke="white"
                stroke-width="0.233333"></path>
        </g>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/EditIcon.vue
================================================
<template>
    <svg :width="size" :height="size" viewBox="0 0 19 18" fill="none"
        :style="{ minWidth: `${size}px`, minHeight: `${size}px` }">
        <g filter="url(#filter0_ii_1527_83564)">
            <path
                d="M2 4.7C2 3.20883 3.20883 2 4.7 2H13.3C14.7912 2 16 3.20883 16 4.7V13.3C16 14.7912 14.7912 16 13.3 16H4.7C3.20883 16 2 14.7912 2 13.3V4.7Z"
                fill="url(#paint0_linear_1527_83564)"></path>
        </g>
        <path
            d="M2.42857 4.7C2.42857 3.44552 3.44552 2.42857 4.7 2.42857H13.3C14.5545 2.42857 15.5714 3.44552 15.5714 4.7V13.3C15.5714 14.5545 14.5545 15.5714 13.3 15.5714H4.7C3.44552 15.5714 2.42857 14.5545 2.42857 13.3V4.7Z"
            stroke="#B9B9B7" stroke-width="0.857143"></path>
        <path
            d="M9.24211 5.70711C9.63264 5.31658 10.2658 5.31658 10.6563 5.70711V5.70711V5.70711C11.0468 6.09763 11.0468 6.7308 10.6563 7.12132L7.12079 10.6569H5.70658V9.24264L9.24211 5.70711Z"
            stroke="#535350" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"></path>
        <path d="M8 12H12" stroke="#535350" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"></path>
        <defs>
            <filter id="filter0_ii_1527_83564" x="1.5" y="1.5" width="15" height="15" filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB">
                <feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood>
                <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="1" dy="1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.6 0"></feColorMatrix>
                <feBlend mode="normal" in2="shape" result="effect1_innerShadow_1527_83564"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="-1" dy="-1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0"></feColorMatrix>
                <feBlend mode="normal" in2="effect1_innerShadow_1527_83564" result="effect2_innerShadow_1527_83564">
                </feBlend>
            </filter>
            <linearGradient id="paint0_linear_1527_83564" x1="9" y1="2" x2="9" y2="16" gradientUnits="userSpaceOnUse">
                <stop stop-color="white" stop-opacity="0"></stop>
                <stop offset="1" stop-opacity="0.16"></stop>
            </linearGradient>
        </defs>
    </svg>
</template>

<script setup lang="ts">
defineProps({
    size: {
        type: Number,
        default: 21
    }
});
</script>



================================================
FILE: frontend/src/components/icons/ErrorIcon.vue
================================================
<template>
    <svg height="20" width="20" fill="none" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
        <g clip-path="url(#clip0_toast_error)">
            <path
                d="M10.0013 18.3332C14.6037 18.3332 18.3346 14.6022 18.3346 9.99984C18.3346 5.39746 14.6037 1.6665 10.0013 1.6665C5.39893 1.6665 1.66797 5.39746 1.66797 9.99984C1.66797 14.6022 5.39893 18.3332 10.0013 18.3332Z"
                stroke="var(--function-error)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.66667">
            </path>
            <path d="M10 6.6665V9.99984" stroke="var(--function-error)" stroke-linecap="round" stroke-linejoin="round"
                stroke-width="1.66667"></path>
            <path d="M10 13.3335H10.0083" stroke="var(--function-error)" stroke-linecap="round" stroke-linejoin="round"
                stroke-width="1.66667"></path>
        </g>
        <defs>
            <clipPath id="clip0_toast_error">
                <rect height="20" width="20" fill="white"></rect>
            </clipPath>
        </defs>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/FileIcon.vue
================================================
<template>
    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
            d="M3.55566 26.8889C3.55566 28.6071 4.94856 30 6.66678 30H25.3334C27.0517 30 28.4446 28.6071 28.4446 26.8889V9.77778L20.6668 2H6.66678C4.94856 2 3.55566 3.39289 3.55566 5.11111V26.8889Z"
            fill="#4D81E8"></path>
        <path d="M20.6685 6.66647C20.6685 8.38469 22.0613 9.77759 23.7796 9.77759H28.4462L20.6685 1.99981V6.66647Z"
            fill="#9CC3F4"></path>
        <path opacity="0.9" d="M10.1685 18.2363H21.8351" stroke="white" stroke-width="1.75" stroke-linecap="square"
            stroke-linejoin="round"></path>
        <path opacity="0.9" d="M10.1685 14.3472H12.1129" stroke="white" stroke-width="1.75" stroke-linecap="square"
            stroke-linejoin="round"></path>
        <path opacity="0.9" d="M15.0293 14.3472H16.9737" stroke="white" stroke-width="1.75" stroke-linecap="square"
            stroke-linejoin="round"></path>
        <path opacity="0.9" d="M10.1685 21.8333H21.8351" stroke="white" stroke-width="1.75" stroke-linecap="square"
            stroke-linejoin="round"></path>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/InfoIcon.vue
================================================
<template>
    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
        width="20" height="20" viewBox="0 0 128 128" enable-background="new 0 0 128 128" xml:space="preserve">
        <g>
            <g>
                <path fill="#03A9F4" d="M64,0C28.656,0,0,28.656,0,64s28.656,64,64,64s64-28.656,64-64S99.344,0,64,0z M64,120
			C33.125,120,8,94.875,8,64S33.125,8,64,8s56,25.125,56,56S94.875,120,64,120z" />
            </g>
        </g>
        <g>
            <g>
                <path fill="#03A9F4" d="M64,48c-4.414,0-8,3.586-8,8v40c0,4.414,3.586,8,8,8s8-3.586,8-8V56C72,51.586,68.414,48,64,48z M64,40
			c4.414,0,8-3.586,8-8s-3.586-8-8-8s-8,3.586-8,8S59.586,40,64,40z" />
            </g>
        </g>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/LoadingSpinnerIcon.vue
================================================
<template>
    <div class="inline-flex relative">
        <svg
            class="transform -rotate-90 absolute top-[50%] mt-[2px] left-[50%] translate-x-[-50%] translate-y-[-50%]"
            viewBox="0 0 16 15" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="8" cy="7.5" r="6" class="stroke-current text-[var(--icon-white-tsp)]"
                stroke-opacity="0.48" stroke-width="1.2" fill="none"></circle>
            <circle cx="8" cy="7.5" r="6" class="stroke-current text-[var(--icon-white)]"
                stroke-width="1.2" fill="none"
                stroke-dasharray="37.69911184307752 37.69911184307752"
                stroke-dashoffset="37.69911184307752" stroke-linecap="round"></circle>
        </svg>
        <slot />
    </div>
</template>

<script setup lang="ts">
// Empty script block for consistency with other icon components
</script> 


================================================
FILE: frontend/src/components/icons/ManusIcon.vue
================================================
<template>
    <svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6">
        <g clip-path="url(#clip0_6115_92550)">
            <g clip-path="url(#clip1_6115_92550)">
                <path
                    d="M17.6335 22.5843C19.2956 21.5297 20.4448 15.874 20.192 14.1899C20.192 14.1899 19.9286 13.2857 19.2857 13.2857C18.6429 13.2857 18.3754 13.963 18.3754 13.963C18.3754 13.963 17.278 18.0192 16.2857 18.4766C15.2934 18.934 14.3312 18.4766 14.3312 18.4766C15.0597 21.2397 15.9713 23.6388 17.6335 22.5843Z"
                    fill="var(--logo-color)"></path>
                <path
                    d="M14.8769 9.43597L13.1816 9.07019L13.1891 9.03356L13.1982 8.99732L14.8769 9.43597ZM15.1488 8.35717L16.8493 8.69695L16.8399 8.74673L16.8276 8.79582L15.1488 8.35717ZM14.857 7.6186L15.2958 5.98341L15.4865 6.03624L15.6612 6.12972L14.857 7.6186ZM13.5668 7.96431L12.2211 6.87184L12.2943 6.78412L12.3789 6.70708L13.5668 7.96431ZM12.4288 9.64282L13.9834 10.416L13.8349 10.713L13.5821 10.9307L12.4288 9.64282ZM11.786 10.5L13.4744 10.166L14.2109 13.461L11.0854 12.0401L11.786 10.5ZM7.72621 14.1431L6.04152 14.4931L6.04152 14.4931L7.72621 14.1431ZM8.57171 14.7857L8.53095 13.0862C9.10686 13.0838 9.65171 13.3636 9.98402 13.8324C10.3163 14.3012 10.3924 14.8974 10.187 15.4224L8.57171 14.7857ZM8.35726 16.0715L10.0853 16.0472L10.0853 16.0472L8.35726 16.0715ZM15.6431 12.2143L17.1005 11.3277L17.1005 11.3277L15.6431 12.2143ZM12.8278 18.165L12.3033 19.7742L12.2737 19.7643L12.2444 19.7535L12.8278 18.165ZM15.8571 18.8571L16.1755 17.1931L16.2245 17.203L16.2728 17.2157L15.8571 18.8571ZM17.8514 15.4626L18.4368 13.875L18.4368 13.875L17.8514 15.4626ZM18.2116 15.6574L18.8791 14.1027L19.9534 14.565L19.9404 15.7092L18.2116 15.6574ZM17.323 17.8479L15.9244 16.8223L15.9244 16.8223L17.323 17.8479ZM4.92908 8.99997L3.37429 8.22714L3.37429 8.22714L4.92908 8.99997ZM8.14299 11.1428L8.76991 9.57124L8.76991 9.57124L8.14299 11.1428ZM7.92885 8.7857L7.37592 10.3851L7.37592 10.3851L7.92885 8.7857ZM13.1982 8.99732L13.4701 7.91851L16.8276 8.79582L16.5556 9.87462L13.1982 8.99732ZM15.1488 8.35717C13.4484 8.01738 13.4483 8.018 13.4482 8.01863C13.4481 8.01883 13.448 8.01945 13.4479 8.01986C13.4478 8.02069 13.4476 8.0215 13.4475 8.02232C13.4472 8.02394 13.4469 8.02555 13.4466 8.02713C13.446 8.03031 13.4455 8.03341 13.445 8.03643C13.4439 8.04248 13.4429 8.04826 13.442 8.05378C13.4403 8.0648 13.4388 8.07497 13.4375 8.08443C13.4351 8.10301 13.4334 8.12042 13.4323 8.13745C13.4306 8.16641 13.4293 8.21679 13.4397 8.28536C13.4569 8.3985 13.5614 8.84439 14.0528 9.10748L15.6612 6.12972C16.5438 6.60228 16.7943 7.41746 16.8596 7.84751C16.894 8.07453 16.8923 8.27028 16.8842 8.40499C16.8799 8.4749 16.8735 8.53528 16.8672 8.58362C16.864 8.60795 16.8607 8.62969 16.8577 8.64856C16.8562 8.65801 16.8547 8.66679 16.8533 8.67485C16.8526 8.67888 16.8519 8.68274 16.8512 8.68643C16.8509 8.68827 16.8506 8.69007 16.8502 8.69182C16.8501 8.6927 16.8499 8.69356 16.8498 8.69442C16.8497 8.69485 16.8496 8.69548 16.8495 8.69569C16.8494 8.69632 16.8493 8.69695 15.1488 8.35717ZM14.857 7.6186C14.4182 9.25379 14.419 9.254 14.4198 9.25422C14.42 9.25429 14.4208 9.2545 14.4213 9.25464C14.4224 9.25493 14.4234 9.25521 14.4244 9.25548C14.4264 9.25604 14.4284 9.25658 14.4304 9.25711C14.4343 9.25817 14.4382 9.25918 14.4419 9.26015C14.4493 9.26208 14.4563 9.26384 14.4628 9.26545C14.4759 9.26865 14.4875 9.27125 14.4976 9.27336C14.5177 9.27756 14.5331 9.28006 14.545 9.2816C14.5668 9.28444 14.5842 9.28501 14.6015 9.28369C14.6467 9.28022 14.7133 9.2592 14.7547 9.22155L12.3789 6.70708C13.0124 6.13044 13.7241 5.93657 14.2664 5.89499C14.5322 5.87461 14.7611 5.88982 14.9324 5.91205C15.0189 5.92328 15.0935 5.93667 15.1541 5.94934C15.1844 5.95569 15.2116 5.96191 15.2352 5.96768C15.247 5.97057 15.258 5.97335 15.2681 5.97598C15.2731 5.9773 15.278 5.97858 15.2826 5.97982C15.2849 5.98044 15.2871 5.98105 15.2893 5.98165C15.2904 5.98195 15.2915 5.98225 15.2926 5.98254C15.2931 5.98269 15.2939 5.98291 15.2942 5.98298C15.295 5.9832 15.2958 5.98341 14.857 7.6186ZM14.9125 9.05679C14.5225 9.52443 14.1276 10.1277 13.9834 10.416L10.8742 8.8696C11.1586 8.30084 11.7098 7.48495 12.2211 6.87184L14.9125 9.05679ZM13.5821 10.9307C13.4132 11.0761 13.3344 11.1607 13.314 11.1863C13.3031 11.2 13.352 11.1437 13.4033 11.0265C13.4477 10.9251 13.5718 10.6021 13.4744 10.166L10.0976 10.8339C9.97797 10.2986 10.1228 9.86076 10.2228 9.63227C10.3297 9.38807 10.4692 9.19266 10.5759 9.05867C10.7908 8.78903 11.0556 8.54429 11.2755 8.35499L13.5821 10.9307ZM9.4109 13.7931C9.37928 13.6578 9.30196 13.5019 9.17241 13.3662C9.05261 13.2406 8.92966 13.1751 8.85221 13.1429C8.77705 13.1117 8.71764 13.1003 8.68143 13.095C8.66063 13.092 8.63908 13.0898 8.61583 13.0884C8.60399 13.0877 8.59119 13.0871 8.57725 13.0867C8.57026 13.0865 8.56293 13.0864 8.55524 13.0863C8.55139 13.0863 8.54744 13.0862 8.5434 13.0862C8.54138 13.0862 8.53933 13.0862 8.53725 13.0862C8.53621 13.0862 8.53517 13.0862 8.53412 13.0862C8.53359 13.0862 8.5328 13.0862 8.53254 13.0862C8.53174 13.0862 8.53095 13.0862 8.57171 14.7857C8.61247 16.4852 8.61166 16.4852 8.61086 16.4852C8.61059 16.4852 8.60978 16.4852 8.60923 16.4852C8.60814 16.4852 8.60703 16.4852 8.60591 16.4852C8.60366 16.4852 8.60136 16.4852 8.59901 16.4852C8.59429 16.4851 8.58935 16.4851 8.58418 16.4851C8.57385 16.4849 8.5626 16.4847 8.55049 16.4844C8.5263 16.4838 8.49843 16.4826 8.4673 16.4807C8.40547 16.4769 8.32848 16.47 8.2402 16.4571C8.06904 16.4322 7.82655 16.3812 7.55887 16.27C6.98288 16.0307 6.27445 15.4896 6.04152 14.4931L9.4109 13.7931ZM8.57171 14.7857C10.187 15.4224 10.1871 15.4221 10.1872 15.4218C10.1873 15.4217 10.1874 15.4214 10.1875 15.4212C10.1876 15.4208 10.1878 15.4204 10.1879 15.42C10.1882 15.4193 10.1885 15.4185 10.1888 15.4178C10.1893 15.4165 10.1898 15.4152 10.1902 15.4141C10.1911 15.4118 10.1917 15.4101 10.1922 15.4089C10.1931 15.4064 10.1933 15.4059 10.1928 15.4073C10.1918 15.41 10.1883 15.4199 10.1831 15.436C10.1725 15.4687 10.156 15.5233 10.1394 15.5928C10.1037 15.7423 10.0804 15.9068 10.0853 16.0472L6.62927 16.0958C6.61084 15.5578 6.69482 15.0794 6.77214 14.7556C6.81207 14.5884 6.85354 14.4488 6.88677 14.3464C6.90348 14.295 6.91836 14.2521 6.93028 14.219C6.93624 14.2024 6.94149 14.1882 6.94589 14.1765C6.94809 14.1707 6.95007 14.1654 6.95183 14.1608C6.95271 14.1586 6.95354 14.1564 6.9543 14.1544C6.95468 14.1535 6.95505 14.1525 6.9554 14.1516C6.95558 14.1512 6.95575 14.1507 6.95592 14.1503C6.95601 14.1501 6.95613 14.1498 6.95617 14.1496C6.95629 14.1493 6.95642 14.149 8.57171 14.7857ZM14.5386 15.328C14.285 14.8452 14.2612 14.3726 14.2561 14.1379C14.2533 14.0058 14.257 13.8772 14.2598 13.7848C14.2629 13.6804 14.2655 13.6081 14.2659 13.5322C14.2673 13.2629 14.2361 13.1793 14.1858 13.1009L17.1005 11.3277C17.6708 12.2165 17.7267 13.0695 17.7238 13.6161C17.7231 13.7441 17.7187 13.8683 17.7162 13.9513C17.7133 14.0463 17.7126 14.0963 17.7133 14.1322C17.7155 14.2337 17.7312 14.0558 17.6046 13.8148L14.5386 15.328ZM14.1858 13.1009C14.0128 12.8313 13.973 12.7899 13.7732 12.4869C13.6252 12.2624 13.4429 11.9674 13.3016 11.6077C12.9886 10.8113 12.9908 10.003 13.1816 9.07019L16.5723 9.80174C16.5132 10.0906 16.5055 10.2532 16.5085 10.3374C16.511 10.4058 16.5201 10.4264 16.5241 10.4366C16.5349 10.464 16.5626 10.5233 16.6641 10.6772C16.7164 10.7565 16.7713 10.8361 16.8494 10.9504C16.9231 11.0583 17.0092 11.1854 17.1005 11.3277L14.1858 13.1009ZM13.3522 16.5559C13.5383 16.6177 14.1836 16.7689 14.9077 16.9261C15.2427 16.9989 15.5602 17.0657 15.7944 17.1145C15.9113 17.1388 16.0071 17.1586 16.0734 17.1722C16.1066 17.179 16.1324 17.1843 16.1497 17.1878C16.1584 17.1896 16.165 17.1909 16.1693 17.1918C16.1715 17.1923 16.1731 17.1926 16.1741 17.1928C16.1746 17.1929 16.175 17.193 16.1752 17.193C16.1753 17.193 16.1754 17.1931 16.1755 17.1931C16.1755 17.1931 16.1755 17.1931 16.1755 17.1931C16.1755 17.1931 16.1755 17.1931 15.8571 18.8571C15.5388 20.5212 15.5387 20.5212 15.5387 20.5211C15.5387 20.5211 15.5386 20.5211 15.5385 20.5211C15.5384 20.5211 15.5383 20.5211 15.5381 20.521C15.5377 20.521 15.5372 20.5209 15.5366 20.5207C15.5353 20.5205 15.5334 20.5201 15.5309 20.5196C15.526 20.5186 15.5188 20.5171 15.5095 20.5152C15.491 20.5114 15.4639 20.5059 15.4293 20.4988C15.3603 20.4846 15.2613 20.4642 15.1408 20.4391C14.9002 20.389 14.5721 20.32 14.2243 20.2444C13.5828 20.1051 12.7134 19.9103 12.3033 19.7742L13.3522 16.5559ZM17.6046 13.8148C17.5305 13.6738 17.4481 13.584 17.4014 13.5391C17.3769 13.5155 17.3572 13.4994 17.3451 13.4902C17.333 13.4808 17.3259 13.4763 17.3256 13.476C17.3251 13.4758 17.3293 13.4784 17.339 13.4838C17.3485 13.4891 17.362 13.4961 17.3799 13.5048C17.4163 13.5225 17.4636 13.5432 17.5231 13.5668C17.6453 13.6151 17.7837 13.6615 17.9411 13.7116C18.0021 13.731 18.111 13.7652 18.1757 13.7859C18.2501 13.8097 18.345 13.8408 18.4368 13.875L17.266 17.0503C17.218 17.0324 17.1454 17.0107 16.9336 16.9433C16.7589 16.8877 16.5254 16.8114 16.2854 16.7164C16.0521 16.6241 15.7574 16.4929 15.4739 16.3108C15.2113 16.1423 14.8041 15.8333 14.5386 15.328L17.6046 13.8148ZM18.4368 13.875C18.5007 13.8988 18.562 13.9225 18.6196 13.9464C18.675 13.9693 18.7426 13.9988 18.8137 14.0347C18.8789 14.0675 18.9923 14.1282 19.1166 14.2213C19.183 14.271 19.2603 14.3357 19.3395 14.4178C19.4217 14.5032 19.4945 14.5954 19.5573 14.693C19.6175 14.7866 19.6553 14.8652 19.6689 14.8939C19.672 14.9004 19.6745 14.9059 19.6747 14.9062C19.6756 14.9082 19.6737 14.9042 19.6717 14.8999C19.6672 14.8905 19.6556 14.866 19.6393 14.8351C19.6032 14.7665 19.5508 14.6786 19.477 14.5839C19.4047 14.4911 19.3296 14.4144 19.2585 14.3518C19.1274 14.2364 19.0108 14.1703 18.9651 14.1454C18.9374 14.1302 18.9156 14.1196 18.9028 14.1135C18.8896 14.1073 18.8812 14.1036 18.8791 14.1027L17.544 17.2121C17.4886 17.1883 17.4139 17.1544 17.3331 17.1104C17.2581 17.0695 17.1229 16.9905 16.9794 16.8643C16.9022 16.7963 16.8224 16.7145 16.7465 16.6171C16.6691 16.5177 16.614 16.4254 16.5756 16.3526C16.5582 16.3196 16.5455 16.293 16.5401 16.2814C16.5386 16.2784 16.5375 16.2759 16.5368 16.2744C16.5364 16.2736 16.5361 16.273 16.5359 16.2726C16.5359 16.2724 16.5358 16.2722 16.5357 16.2721C16.5357 16.272 16.5357 16.272 16.5356 16.272C16.5353 16.2713 16.5374 16.2757 16.54 16.2812C16.5516 16.3057 16.5872 16.3801 16.6446 16.4692C16.7045 16.5624 16.7737 16.6499 16.8511 16.7302C16.9254 16.8073 16.9965 16.8665 17.0548 16.9102C17.163 16.9913 17.253 17.0376 17.2826 17.0526C17.3183 17.0706 17.3383 17.0785 17.3296 17.0749C17.3232 17.0722 17.3039 17.0644 17.266 17.0503L18.4368 13.875ZM19.9404 15.7092C19.9328 16.3819 19.6622 17.0911 19.4702 17.5301C19.2586 18.0142 18.979 18.5304 18.7216 18.8735L15.9244 16.8223C15.9737 16.7566 16.1348 16.4901 16.2891 16.1374C16.3607 15.9735 16.4161 15.8242 16.4513 15.7045C16.4917 15.5671 16.4834 15.5434 16.4827 15.6056L19.9404 15.7092ZM18.7216 18.8735C18.3621 19.3527 17.9547 19.8587 17.4646 20.1823C17.1758 20.373 16.8269 20.5247 16.4153 20.5744C16.0179 20.6224 15.6785 20.5607 15.4414 20.4985L16.2728 17.2157C16.2603 17.2124 16.124 17.1771 15.9281 17.2007C15.7181 17.2261 15.5692 17.3027 15.4984 17.3495C15.4468 17.3835 15.4596 17.3866 15.549 17.2887C15.6345 17.1951 15.7542 17.0493 15.9244 16.8223L18.7216 18.8735ZM10.0853 16.0472C10.0723 15.6704 9.82126 15.5052 9.88279 15.5482C9.97194 15.6105 10.1947 15.7194 10.6186 15.8478C11.0237 15.9704 11.4713 16.0711 11.9651 16.1838C12.4043 16.2839 12.964 16.4106 13.4111 16.5766L12.2444 19.7535C12.0625 19.6859 11.755 19.6102 11.2456 19.494C10.7908 19.3903 10.2085 19.2608 9.65915 19.0944C9.12875 18.9338 8.47272 18.6949 7.91568 18.3056C7.33101 17.897 6.66629 17.1766 6.62927 16.0958L10.0853 16.0472ZM6.48386 9.7728C6.55036 9.63972 6.60965 9.40988 6.55236 9.13814C6.50026 8.89097 6.38092 8.74864 6.3449 8.71003C6.31056 8.67324 6.39398 8.76174 6.746 8.9118C7.05416 9.04316 7.41778 9.16 7.77868 9.26604C7.97386 9.32338 8.10223 9.3588 8.27673 9.40942C8.40142 9.44559 8.60254 9.50406 8.76991 9.57124L7.51608 12.7144C7.5428 12.7252 7.51792 12.7145 7.3573 12.6679C7.24649 12.6358 7.03025 12.5748 6.84755 12.5211C6.45271 12.4051 5.92754 12.2415 5.42223 12.0261C4.96079 11.8294 4.30605 11.5048 3.81725 10.981C3.55399 10.6989 3.27834 10.2945 3.16689 9.7658C3.05025 9.21254 3.14717 8.68169 3.37429 8.22714L6.48386 9.7728ZM8.76991 9.57124C9.13478 9.7177 9.53993 9.9535 9.86319 10.3431C10.2058 10.7561 10.3621 11.2286 10.3854 11.677C10.4247 12.434 10.0758 13.0784 9.9233 13.3559C9.82693 13.5311 9.71881 13.709 9.64207 13.8371C9.55588 13.9811 9.49749 14.0815 9.454 14.1664C9.31674 14.4345 9.50887 14.2122 9.41091 13.7931L6.04152 14.4931C5.93271 14.0277 5.99289 13.6151 6.06922 13.3255C6.14576 13.0351 6.26203 12.7813 6.3592 12.5916C6.45798 12.3987 6.56783 12.2139 6.6532 12.0713C6.74802 11.9129 6.81478 11.803 6.87396 11.6954C6.93248 11.5889 6.95273 11.539 6.95696 11.5271C6.96302 11.5099 6.92282 11.6094 6.93193 11.7848C6.94283 11.9945 7.022 12.2455 7.20033 12.4604C7.35925 12.652 7.51278 12.7131 7.51608 12.7144L8.76991 9.57124ZM11.0854 12.0401C9.98447 11.5396 8.34615 10.7254 7.37592 10.3851L8.48177 7.18629C9.65129 7.59647 11.6215 8.5666 12.4866 8.95991L11.0854 12.0401ZM7.37592 10.3851C7.0517 10.2714 6.77906 10.1934 6.55497 10.1462C6.32651 10.098 6.18624 10.09 6.11583 10.0926C6.04674 10.0951 6.10241 10.1054 6.21105 10.0468C6.34006 9.97729 6.43596 9.86866 6.48386 9.7728L3.37429 8.22714C3.92717 7.12065 4.98323 6.72972 5.9225 6.6959C6.77063 6.66536 7.67313 6.90268 8.48177 7.18629L7.37592 10.3851Z"
                    fill="var(--logo-color)" mask="url(#path-2-outside-1_6115_92550)"></path>
                <path
                    d="M7.71498 12.0001C8.30182 11.4302 10.0059 10.9969 11.7867 11.7858C13.5676 12.5746 13.8721 15.2062 13.1206 16.0674C12.3692 16.9286 10.7152 16.0674 10.7152 16.0674"
                    stroke="var(--logo-color)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.71429">
                </path>
                <path d="M6.43004 5.1428C5.79407 4.42578 5.14453 4.07134 4.50157 3.75595" stroke="var(--logo-color)"
                    stroke-linecap="round" stroke-miterlimit="10" stroke-width="1.71429"></path>
                <path d="M9.12714 3.9793C9.00084 3.21423 8.78655 2.57138 8.57227 1.71423" stroke="var(--logo-color)"
                    stroke-linecap="round" stroke-miterlimit="10" stroke-width="1.71429"></path>
                <path d="M12.0007 4.49997C12.1175 3.60306 12.4293 2.78568 12.8193 2.14282" stroke="var(--logo-color)"
                    stroke-linecap="round" stroke-miterlimit="10" stroke-width="1.71429"></path>
                <mask height="21.89" id="path-2-outside-1_6115_92550" width="20.7036" fill="black" x="2.12614"
                    y="2.44341" maskUnits="userSpaceOnUse">
                    <rect height="21.89" width="20.7036" fill="white" x="2.12614" y="2.44341"></rect>
                    <path
                        d="M15.1488 8.35717L14.8769 9.43597C14.5717 10.9286 15.0225 11.2471 15.6431 12.2143C16.2638 13.1815 15.8175 14.0877 16.0716 14.5714C16.3258 15.0552 17.4444 15.311 17.8514 15.4626C18.2584 15.6143 17.9898 15.562 18.2116 15.6574C18.2045 16.2825 17.6297 17.4391 17.323 17.8479C16.5845 18.8324 16.3061 18.975 15.8571 18.8571C15.8571 18.8571 13.4239 18.3629 12.8278 18.165C11.5699 17.6981 8.40549 17.4793 8.35726 16.0715C8.33403 15.3931 8.57171 14.7857 8.57171 14.7857C8.57171 14.7857 7.8771 14.7886 7.72621 14.1431C7.51733 13.2496 9.58927 11.7234 8.14299 11.1428C7.58039 10.917 4.28656 10.2859 4.92908 8.99997C5.33142 8.19475 6.43373 8.26131 7.92885 8.7857C8.99872 9.16093 10.803 10.0531 11.786 10.5C11.7416 10.3015 12.04 9.97753 12.4288 9.64282C12.6431 9.21425 13.1162 8.50469 13.5668 7.96431C14.1589 7.42534 14.857 7.6186 14.857 7.6186C15.2482 7.82807 15.1488 8.35717 15.1488 8.35717Z">
                    </path>
                </mask>
            </g>
        </g>
        <defs>
            <clipPath id="clip0_6115_92550">
                <rect height="24" width="24" fill="white" transform="matrix(1 -8.74228e-08 -8.74228e-08 -1 0 24)">
                </rect>
            </clipPath>
            <clipPath id="clip1_6115_92550">
                <rect height="24" width="24" fill="white" transform="matrix(1 -8.74228e-08 -8.74228e-08 -1 0 24)">
                </rect>
            </clipPath>
        </defs>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/ManusLogoTextIcon.vue
================================================
<template>
    <svg xmlns="http://www.w3.org/2000/svg" :width="width" :height="height" viewBox="0 0 88 38" fill="none">
        <path
            d="M75.9757 24.9999H75.2937V20.9959H76.2177C76.4677 22.0519 76.8267 22.8219 77.2957 23.3059C77.7657 23.7899 78.3737 24.0319 79.1217 24.0319C79.6647 24.0319 80.0827 23.9219 80.3757 23.7019C80.6837 23.4672 80.8377 23.1519 80.8377 22.7559C80.8377 22.3452 80.6547 21.9492 80.2877 21.5679C79.9217 21.1719 79.3277 20.7539 78.5057 20.3139C77.3917 19.7126 76.5917 19.1186 76.1077 18.5319C75.6237 17.9306 75.3817 17.2559 75.3817 16.5079C75.3817 16.0239 75.4697 15.5766 75.6457 15.1659C75.8367 14.7406 76.0857 14.3739 76.3937 14.0659C76.7167 13.7579 77.0977 13.5232 77.5377 13.3619C77.9777 13.1859 78.4547 13.0979 78.9677 13.0979C79.4227 13.0979 79.8697 13.1639 80.3097 13.2959C80.7647 13.4279 81.1607 13.6112 81.4977 13.8459L81.8937 13.3179H82.4657V16.6399H81.6077C81.2707 15.8039 80.9187 15.2026 80.5517 14.8359C80.1997 14.4692 79.7677 14.2859 79.2537 14.2859C78.8437 14.2859 78.5137 14.3959 78.2637 14.6159C78.0297 14.8359 77.9117 15.1292 77.9117 15.4959C77.9117 15.9066 78.0877 16.2952 78.4397 16.6619C78.8067 17.0286 79.4077 17.4319 80.2437 17.8719C80.8307 18.1946 81.3367 18.5099 81.7617 18.8179C82.1877 19.1259 82.5317 19.4412 82.7957 19.7639C83.0597 20.0719 83.2507 20.4019 83.3677 20.7539C83.4997 21.0912 83.5657 21.4579 83.5657 21.8539C83.5657 22.3672 83.4707 22.8292 83.2797 23.2399C83.0897 23.6506 82.8177 24.0026 82.4657 24.2959C82.1137 24.5892 81.6887 24.8166 81.1897 24.9779C80.7057 25.1392 80.1637 25.2199 79.5617 25.2199C78.9317 25.2199 78.3447 25.1392 77.8017 24.9779C77.2597 24.8019 76.8117 24.5526 76.4597 24.2299L75.9757 24.9999Z"
            fill="var(--logo-color)"></path>
        <path
            d="M75.9757 24.9999H75.2937V20.9959H76.2177C76.4677 22.0519 76.8267 22.8219 77.2957 23.3059C77.7657 23.7899 78.3737 24.0319 79.1217 24.0319C79.6647 24.0319 80.0827 23.9219 80.3757 23.7019C80.6837 23.4672 80.8377 23.1519 80.8377 22.7559C80.8377 22.3452 80.6547 21.9492 80.2877 21.5679C79.9217 21.1719 79.3277 20.7539 78.5057 20.3139C77.3917 19.7126 76.5917 19.1186 76.1077 18.5319C75.6237 17.9306 75.3817 17.2559 75.3817 16.5079C75.3817 16.0239 75.4697 15.5766 75.6457 15.1659C75.8367 14.7406 76.0857 14.3739 76.3937 14.0659C76.7167 13.7579 77.0977 13.5232 77.5377 13.3619C77.9777 13.1859 78.4547 13.0979 78.9677 13.0979C79.4227 13.0979 79.8697 13.1639 80.3097 13.2959C80.7647 13.4279 81.1607 13.6112 81.4977 13.8459L81.8937 13.3179H82.4657V16.6399H81.6077C81.2707 15.8039 80.9187 15.2026 80.5517 14.8359C80.1997 14.4692 79.7677 14.2859 79.2537 14.2859C78.8437 14.2859 78.5137 14.3959 78.2637 14.6159C78.0297 14.8359 77.9117 15.1292 77.9117 15.4959C77.9117 15.9066 78.0877 16.2952 78.4397 16.6619C78.8067 17.0286 79.4077 17.4319 80.2437 17.8719C80.8307 18.1946 81.3367 18.5099 81.7617 18.8179C82.1877 19.1259 82.5317 19.4412 82.7957 19.7639C83.0597 20.0719 83.2507 20.4019 83.3677 20.7539C83.4997 21.0912 83.5657 21.4579 83.5657 21.8539C83.5657 22.3672 83.4707 22.8292 83.2797 23.2399C83.0897 23.6506 82.8177 24.0026 82.4657 24.2959C82.1137 24.5892 81.6887 24.8166 81.1897 24.9779C80.7057 25.1392 80.1637 25.2199 79.5617 25.2199C78.9317 25.2199 78.3447 25.1392 77.8017 24.9779C77.2597 24.8019 76.8117 24.5526 76.4597 24.2299L75.9757 24.9999Z"
            fill="var(--logo-color)"></path>
        <path
            d="M68.9587 16.9478C68.9587 16.3612 68.9437 15.8992 68.9147 15.5618C68.8853 15.2098 68.8047 14.9458 68.6727 14.7698C68.5407 14.5792 68.3427 14.4545 68.0787 14.3958C67.8293 14.3225 67.4847 14.2638 67.0447 14.2198V13.3398H72.0167V20.0058C72.0167 20.9005 72.0237 21.6045 72.0387 22.1178C72.0677 22.6165 72.1117 22.9905 72.1707 23.2398C72.2147 23.4305 72.2657 23.5845 72.3247 23.7018C72.3837 23.8045 72.4787 23.8925 72.6107 23.9658C72.7427 24.0245 72.9187 24.0685 73.1387 24.0978C73.3737 24.1125 73.6737 24.1198 74.0407 24.1198V24.9778L69.6627 25.2418L69.4207 23.2838H69.3327C68.9517 23.8998 68.416 24.3765 67.7267 24.7138C67.0373 25.0512 66.2673 25.2198 65.4167 25.2198C63.8473 25.2198 62.652 24.6625 61.8307 23.5478C61.2 22.6972 60.8847 21.4872 60.8847 19.9178V16.9478C60.8847 16.3465 60.87 15.8772 60.8407 15.5398C60.8113 15.1878 60.7307 14.9238 60.5987 14.7478C60.4813 14.5718 60.298 14.4545 60.0487 14.3958C59.7993 14.3225 59.4547 14.2638 59.0147 14.2198V13.3398H63.9427V19.5658C63.9427 21.0472 64.126 22.1252 64.4927 22.7998C64.8593 23.4598 65.446 23.7898 66.2527 23.7898C67.118 23.7898 67.7853 23.3938 68.2547 22.6018C68.724 21.8392 68.9587 20.7172 68.9587 19.2358V16.9478Z"
            fill="var(--logo-color)"></path>
        <path
            d="M68.9587 16.9478C68.9587 16.3612 68.9437 15.8992 68.9147 15.5618C68.8853 15.2098 68.8047 14.9458 68.6727 14.7698C68.5407 14.5792 68.3427 14.4545 68.0787 14.3958C67.8293 14.3225 67.4847 14.2638 67.0447 14.2198V13.3398H72.0167V20.0058C72.0167 20.9005 72.0237 21.6045 72.0387 22.1178C72.0677 22.6165 72.1117 22.9905 72.1707 23.2398C72.2147 23.4305 72.2657 23.5845 72.3247 23.7018C72.3837 23.8045 72.4787 23.8925 72.6107 23.9658C72.7427 24.0245 72.9187 24.0685 73.1387 24.0978C73.3737 24.1125 73.6737 24.1198 74.0407 24.1198V24.9778L69.6627 25.2418L69.4207 23.2838H69.3327C68.9517 23.8998 68.416 24.3765 67.7267 24.7138C67.0373 25.0512 66.2673 25.2198 65.4167 25.2198C63.8473 25.2198 62.652 24.6625 61.8307 23.5478C61.2 22.6972 60.8847 21.4872 60.8847 19.9178V16.9478C60.8847 16.3465 60.87 15.8772 60.8407 15.5398C60.8113 15.1878 60.7307 14.9238 60.5987 14.7478C60.4813 14.5718 60.298 14.4545 60.0487 14.3958C59.7993 14.3225 59.4547 14.2638 59.0147 14.2198V13.3398H63.9427V19.5658C63.9427 21.0472 64.126 22.1252 64.4927 22.7998C64.8593 23.4598 65.446 23.7898 66.2527 23.7898C67.118 23.7898 67.7853 23.3938 68.2547 22.6018C68.724 21.8392 68.9587 20.7172 68.9587 19.2358V16.9478Z"
            fill="var(--logo-color)"></path>
        <path
            d="M48.6182 21.4139C48.6182 22.0152 48.6328 22.4919 48.6622 22.8439C48.7062 23.1812 48.7868 23.4452 48.9042 23.6359C49.0362 23.8119 49.2268 23.9292 49.4762 23.9879C49.7402 24.0465 50.0922 24.0905 50.5322 24.1199V24.9999H43.6022V24.1199C44.0275 24.0905 44.3648 24.0465 44.6142 23.9879C44.8782 23.9292 45.0762 23.8119 45.2082 23.6359C45.3548 23.4599 45.4502 23.2105 45.4942 22.8879C45.5382 22.5652 45.5602 22.1252 45.5602 21.5679V18.8179C45.5602 17.9525 45.5455 17.2559 45.5162 16.7279C45.4868 16.1852 45.4502 15.8185 45.4062 15.6279C45.3622 15.4372 45.3035 15.2832 45.2302 15.1659C45.1568 15.0339 45.0468 14.9385 44.9002 14.8799C44.7535 14.8065 44.5702 14.7625 44.3502 14.7479C44.1302 14.7185 43.8515 14.7039 43.5142 14.7039V13.9559L47.7602 13.1199L48.0462 15.0559H48.1342C48.6182 14.4399 49.1902 13.9632 49.8502 13.6259C50.5102 13.2885 51.2362 13.1199 52.0282 13.1199C52.9668 13.1199 53.7222 13.2519 54.2942 13.5159C54.8808 13.7652 55.4015 14.1905 55.8562 14.7919C56.1055 15.1292 56.3255 15.5692 56.5162 16.1119C56.7068 16.6399 56.8022 17.3732 56.8022 18.3119V21.4139C56.8022 22.0152 56.8168 22.4919 56.8462 22.8439C56.8902 23.1812 56.9708 23.4452 57.0882 23.6359C57.2202 23.8119 57.4108 23.9292 57.6602 23.9879C57.9095 24.0465 58.2468 24.0905 58.6722 24.1199V24.9999H51.7862V24.1199C52.2262 24.1052 52.5708 24.0685 52.8202 24.0099C53.0842 23.9365 53.2822 23.8119 53.4142 23.6359C53.5462 23.4599 53.6342 23.2105 53.6782 22.8879C53.7222 22.5505 53.7442 22.1105 53.7442 21.5679V18.5759C53.7442 17.8279 53.7002 17.1972 53.6122 16.6839C53.5242 16.1705 53.3775 15.7599 53.1722 15.4519C52.9815 15.1292 52.7248 14.9019 52.4022 14.7699C52.0795 14.6232 51.6762 14.5499 51.1922 14.5499C50.7228 14.5499 50.3195 14.6819 49.9822 14.9459C49.6448 15.2099 49.3515 15.5765 49.1022 16.0459C48.9702 16.3099 48.8528 16.6545 48.7502 17.0799C48.6622 17.4905 48.6182 17.9232 48.6182 18.3779V21.4139Z"
            fill="var(--logo-color)"></path>
        <path
            d="M48.6196 21.4139C48.6196 22.0152 48.6342 22.4919 48.6636 22.8439C48.7076 23.1812 48.7882 23.4452 48.9056 23.6359C49.0376 23.8119 49.2282 23.9292 49.4776 23.9879C49.7416 24.0465 50.0936 24.0905 50.5336 24.1199V24.9999H43.6036V24.1199C44.0289 24.0905 44.3662 24.0465 44.6156 23.9879C44.8796 23.9292 45.0776 23.8119 45.2096 23.6359C45.3562 23.4599 45.4516 23.2105 45.4956 22.8879C45.5396 22.5652 45.5616 22.1252 45.5616 21.5679V18.8179C45.5616 17.9525 45.5469 17.2559 45.5176 16.7279C45.4882 16.1852 45.4516 15.8185 45.4076 15.6279C45.3636 15.4372 45.3049 15.2832 45.2316 15.1659C45.1582 15.0339 45.0482 14.9385 44.9016 14.8799C44.7549 14.8065 44.5716 14.7625 44.3516 14.7479C44.1316 14.7185 43.8529 14.7039 43.5156 14.7039V13.9559L47.7616 13.1199L48.0476 15.0559H48.1356C48.6196 14.4399 49.1916 13.9632 49.8516 13.6259C50.5116 13.2885 51.2376 13.1199 52.0296 13.1199C52.9682 13.1199 53.7236 13.2519 54.2956 13.5159C54.8822 13.7652 55.4029 14.1905 55.8576 14.7919C56.1069 15.1292 56.3269 15.5692 56.5176 16.1119C56.7082 16.6399 56.8036 17.3732 56.8036 18.3119V21.4139C56.8036 22.0152 56.8182 22.4919 56.8476 22.8439C56.8916 23.1812 56.9722 23.4452 57.0896 23.6359C57.2216 23.8119 57.4122 23.9292 57.6616 23.9879C57.9109 24.0465 58.2482 24.0905 58.6736 24.1199V24.9999H51.7876V24.1199C52.2276 24.1052 52.5722 24.0685 52.8216 24.0099C53.0856 23.9365 53.2836 23.8119 53.4156 23.6359C53.5476 23.4599 53.6356 23.2105 53.6796 22.8879C53.7236 22.5505 53.7456 22.1105 53.7456 21.5679V18.5759C53.7456 17.8279 53.7016 17.1972 53.6136 16.6839C53.5256 16.1705 53.3789 15.7599 53.1736 15.4519C52.9829 15.1292 52.7262 14.9019 52.4036 14.7699C52.0809 14.6232 51.6776 14.5499 51.1936 14.5499C50.7242 14.5499 50.3209 14.6819 49.9836 14.9459C49.6462 15.2099 49.3529 15.5765 49.1036 16.0459C48.9716 16.3099 48.8542 16.6545 48.7516 17.0799C48.6636 17.4905 48.6196 17.9232 48.6196 18.3779V21.4139Z"
            fill="var(--logo-color)"></path>
        <path
            d="M38.1193 18.7299C36.8873 19.2872 35.956 19.8079 35.3253 20.2919C34.7093 20.7612 34.4013 21.2525 34.4013 21.7659C34.4013 22.1912 34.5187 22.5285 34.7533 22.7779C34.988 23.0272 35.2813 23.1519 35.6333 23.1519C35.9853 23.1519 36.3153 23.0932 36.6233 22.9759C36.9313 22.8439 37.1953 22.6752 37.4153 22.4699C37.6353 22.2645 37.804 22.0225 37.9213 21.7439C38.0533 21.4505 38.1193 21.1425 38.1193 20.8199V18.7299ZM38.1193 17.5639V16.6399C38.1193 15.7892 37.9653 15.1732 37.6573 14.7919C37.364 14.3959 36.902 14.1979 36.2713 14.1979C35.846 14.1979 35.5233 14.3152 35.3033 14.5499C35.0833 14.7699 34.878 15.1439 34.6873 15.6719C34.5553 16.0385 34.3647 16.3245 34.1153 16.5299C33.8807 16.7352 33.5507 16.8379 33.1253 16.8379C32.7147 16.8379 32.3993 16.7132 32.1793 16.4639C31.9593 16.2145 31.8493 15.8625 31.8493 15.4079C31.8493 14.7039 32.2307 14.1465 32.9933 13.7359C33.7707 13.3252 34.9367 13.1199 36.4913 13.1199C38.134 13.1199 39.3073 13.4205 40.0113 14.0219C40.7153 14.6085 41.0673 15.5985 41.0673 16.9919V21.8099C41.0673 23.0565 41.3167 23.6799 41.8153 23.6799C42.094 23.6799 42.3507 23.5845 42.5853 23.3939L42.9153 24.0319C42.71 24.3985 42.3873 24.6919 41.9473 24.9119C41.522 25.1172 41.038 25.2199 40.4953 25.2199C39.8207 25.2199 39.3073 25.0145 38.9553 24.6039C38.6033 24.1932 38.4273 23.6139 38.4273 22.8659H38.3173C37.892 23.6285 37.342 24.2079 36.6673 24.6039C35.9927 24.9999 35.2227 25.1979 34.3573 25.1979C33.4333 25.1979 32.6927 24.9412 32.1353 24.4279C31.578 23.8999 31.2993 23.2179 31.2993 22.3819C31.2993 21.7365 31.5853 21.1352 32.1573 20.5779C32.7293 20.0059 33.6827 19.4485 35.0173 18.9059L38.1193 17.5639Z"
            fill="var(--logo-color)"></path>
        <path
            d="M38.1208 18.7299C36.8888 19.2872 35.9575 19.8079 35.3268 20.2919C34.7108 20.7612 34.4028 21.2525 34.4028 21.7659C34.4028 22.1912 34.5202 22.5285 34.7548 22.7779C34.9895 23.0272 35.2828 23.1519 35.6348 23.1519C35.9868 23.1519 36.3168 23.0932 36.6248 22.9759C36.9328 22.8439 37.1968 22.6752 37.4168 22.4699C37.6368 22.2645 37.8055 22.0225 37.9228 21.7439C38.0548 21.4505 38.1208 21.1425 38.1208 20.8199V18.7299ZM38.1208 17.5639V16.6399C38.1208 15.7892 37.9668 15.1732 37.6588 14.7919C37.3655 14.3959 36.9035 14.1979 36.2728 14.1979C35.8475 14.1979 35.5248 14.3152 35.3048 14.5499C35.0848 14.7699 34.8795 15.1439 34.6888 15.6719C34.5568 16.0385 34.3662 16.3245 34.1168 16.5299C33.8822 16.7352 33.5522 16.8379 33.1268 16.8379C32.7162 16.8379 32.4008 16.7132 32.1808 16.4639C31.9608 16.2145 31.8508 15.8625 31.8508 15.4079C31.8508 14.7039 32.2322 14.1465 32.9948 13.7359C33.7722 13.3252 34.9382 13.1199 36.4928 13.1199C38.1355 13.1199 39.3088 13.4205 40.0128 14.0219C40.7168 14.6085 41.0688 15.5985 41.0688 16.9919V21.8099C41.0688 23.0565 41.3182 23.6799 41.8168 23.6799C42.0955 23.6799 42.3522 23.5845 42.5868 23.3939L42.9168 24.0319C42.7115 24.3985 42.3888 24.6919 41.9488 24.9119C41.5235 25.1172 41.0395 25.2199 40.4968 25.2199C39.8222 25.2199 39.3088 25.0145 38.9568 24.6039C38.6048 24.1932 38.4288 23.6139 38.4288 22.8659H38.3188C37.8935 23.6285 37.3435 24.2079 36.6688 24.6039C35.9942 24.9999 35.2242 25.1979 34.3588 25.1979C33.4348 25.1979 32.6942 24.9412 32.1368 24.4279C31.5795 23.8999 31.3008 23.2179 31.3008 22.3819C31.3008 21.7365 31.5868 21.1352 32.1588 20.5779C32.7308 20.0059 33.6842 19.4485 35.0188 18.9059L38.1208 17.5639Z"
            fill="var(--logo-color)"></path>
        <path
            d="M12.1055 21.3699C12.1055 21.9859 12.1201 22.4699 12.1495 22.8219C12.1788 23.1739 12.2595 23.4452 12.3915 23.6359C12.5235 23.8119 12.7141 23.9292 12.9635 23.9879C13.2128 24.0465 13.5575 24.0905 13.9975 24.1199V24.9999H7.04549V24.1199C7.48549 24.0905 7.83749 24.0465 8.10149 23.9879C8.36549 23.9292 8.56349 23.8119 8.69549 23.6359C8.82749 23.4599 8.91549 23.2105 8.95949 22.8879C9.00349 22.5505 9.02549 22.1032 9.02549 21.5459V18.8179C9.02549 17.9819 9.01079 17.2852 8.98149 16.7279C8.96679 16.1705 8.93009 15.7892 8.87149 15.5839C8.82749 15.3932 8.76879 15.2465 8.69549 15.1439C8.63679 15.0265 8.53409 14.9385 8.38749 14.8799C8.25549 14.8065 8.07949 14.7625 7.85949 14.7479C7.63949 14.7185 7.35349 14.7039 7.00149 14.7039V13.9559L11.2475 13.1199L11.5115 15.0339H11.6435C12.2595 14.3445 12.8755 13.8532 13.4915 13.5599C14.1221 13.2665 14.8481 13.1199 15.6695 13.1199C16.6375 13.1199 17.4368 13.2885 18.0675 13.6259C18.6981 13.9632 19.1748 14.4472 19.4975 15.0779H19.5855C20.1135 14.4619 20.7441 13.9852 21.4775 13.6479C22.2108 13.2959 22.9955 13.1199 23.8315 13.1199C24.7115 13.1199 25.4741 13.2299 26.1195 13.4499C26.7795 13.6699 27.2928 13.9852 27.6595 14.3959C27.9528 14.7332 28.1655 15.1732 28.2975 15.7159C28.4441 16.2585 28.5175 17.0139 28.5175 17.9819V21.3699C28.5175 21.9712 28.5321 22.4479 28.5615 22.7999C28.6055 23.1519 28.6935 23.4232 28.8255 23.6139C28.9575 23.8045 29.1481 23.9292 29.3975 23.9879C29.6468 24.0465 29.9915 24.0905 30.4315 24.1199V24.9999H23.4795V24.1199C23.9195 24.1052 24.2641 24.0685 24.5135 24.0099C24.7775 23.9365 24.9755 23.8119 25.1075 23.6359C25.2541 23.4452 25.3421 23.1885 25.3715 22.8659C25.4155 22.5432 25.4375 22.1032 25.4375 21.5459V18.6639C25.4375 17.9012 25.3935 17.2559 25.3055 16.7279C25.2175 16.1999 25.0781 15.7745 24.8875 15.4519C24.6968 15.1292 24.4401 14.9019 24.1175 14.7699C23.8095 14.6232 23.4281 14.5499 22.9735 14.5499C22.4601 14.5499 22.0348 14.6745 21.6975 14.9239C21.3748 15.1732 21.1035 15.4959 20.8835 15.8919C20.5021 16.5812 20.3115 17.4392 20.3115 18.4659V21.3699C20.3115 21.9712 20.3261 22.4479 20.3555 22.7999C20.3848 23.1519 20.4655 23.4232 20.5975 23.6139C20.7295 23.8045 20.9201 23.9292 21.1695 23.9879C21.4335 24.0465 21.7928 24.0905 22.2475 24.1199V24.9999H15.2735V24.1199C15.7135 24.0905 16.0581 24.0465 16.3075 23.9879C16.5715 23.9292 16.7695 23.8119 16.9015 23.6359C17.0481 23.4599 17.1361 23.2105 17.1655 22.8879C17.2095 22.5505 17.2315 22.1032 17.2315 21.5459V18.6639C17.2315 17.9012 17.1875 17.2559 17.0995 16.7279C17.0115 16.1999 16.8648 15.7745 16.6595 15.4519C16.4688 15.1292 16.2121 14.9019 15.8895 14.7699C15.5668 14.6232 15.1635 14.5499 14.6795 14.5499C14.1955 14.5499 13.7921 14.6672 13.4695 14.9019C13.1615 15.1365 12.9048 15.4519 12.6995 15.8479C12.5088 16.1999 12.3621 16.6032 12.2595 17.0579C12.1568 17.5125 12.1055 17.9819 12.1055 18.4659V21.3699Z"
            fill="var(--logo-color)"></path>
        <path
            d="M12.104 21.3699C12.104 21.9859 12.1186 22.4699 12.148 22.8219C12.1773 23.1739 12.258 23.4452 12.39 23.6359C12.522 23.8119 12.7126 23.9292 12.962 23.9879C13.2113 24.0465 13.556 24.0905 13.996 24.1199V24.9999H7.044V24.1199C7.484 24.0905 7.836 24.0465 8.1 23.9879C8.364 23.9292 8.562 23.8119 8.694 23.6359C8.826 23.4599 8.914 23.2105 8.958 22.8879C9.002 22.5505 9.024 22.1032 9.024 21.5459V18.8179C9.024 17.9819 9.0093 17.2852 8.98 16.7279C8.9653 16.1705 8.9286 15.7892 8.87 15.5839C8.826 15.3932 8.7673 15.2465 8.694 15.1439C8.6353 15.0265 8.5326 14.9385 8.386 14.8799C8.254 14.8065 8.078 14.7625 7.858 14.7479C7.638 14.7185 7.352 14.7039 7 14.7039V13.9559L11.246 13.1199L11.51 15.0339H11.642C12.258 14.3445 12.874 13.8532 13.49 13.5599C14.1206 13.2665 14.8466 13.1199 15.668 13.1199C16.636 13.1199 17.4353 13.2885 18.066 13.6259C18.6966 13.9632 19.1733 14.4472 19.496 15.0779H19.584C20.112 14.4619 20.7426 13.9852 21.476 13.6479C22.2093 13.2959 22.994 13.1199 23.83 13.1199C24.71 13.1199 25.4726 13.2299 26.118 13.4499C26.778 13.6699 27.2913 13.9852 27.658 14.3959C27.9513 14.7332 28.164 15.1732 28.296 15.7159C28.4426 16.2585 28.516 17.0139 28.516 17.9819V21.3699C28.516 21.9712 28.5306 22.4479 28.56 22.7999C28.604 23.1519 28.692 23.4232 28.824 23.6139C28.956 23.8045 29.1466 23.9292 29.396 23.9879C29.6453 24.0465 29.99 24.0905 30.43 24.1199V24.9999H23.478V24.1199C23.918 24.1052 24.2626 24.0685 24.512 24.0099C24.776 23.9365 24.974 23.8119 25.106 23.6359C25.2526 23.4452 25.3406 23.1885 25.37 22.8659C25.414 22.5432 25.436 22.1032 25.436 21.5459V18.6639C25.436 17.9012 25.392 17.2559 25.304 16.7279C25.216 16.1999 25.0766 15.7745 24.886 15.4519C24.6953 15.1292 24.4386 14.9019 24.116 14.7699C23.808 14.6232 23.4266 14.5499 22.972 14.5499C22.4586 14.5499 22.0333 14.6745 21.696 14.9239C21.3733 15.1732 21.102 15.4959 20.882 15.8919C20.5006 16.5812 20.31 17.4392 20.31 18.4659V21.3699C20.31 21.9712 20.3246 22.4479 20.354 22.7999C20.3833 23.1519 20.464 23.4232 20.596 23.6139C20.728 23.8045 20.9186 23.9292 21.168 23.9879C21.432 24.0465 21.7913 24.0905 22.246 24.1199V24.9999H15.272V24.1199C15.712 24.0905 16.0566 24.0465 16.306 23.9879C16.57 23.9292 16.768 23.8119 16.9 23.6359C17.0466 23.4599 17.1346 23.2105 17.164 22.8879C17.208 22.5505 17.23 22.1032 17.23 21.5459V18.6639C17.23 17.9012 17.186 17.2559 17.098 16.7279C17.01 16.1999 16.8633 15.7745 16.658 15.4519C16.4673 15.1292 16.2106 14.9019 15.888 14.7699C15.5653 14.6232 15.162 14.5499 14.678 14.5499C14.194 14.5499 13.7906 14.6672 13.468 14.9019C13.16 15.1365 12.9033 15.4519 12.698 15.8479C12.5073 16.1999 12.3606 16.6032 12.258 17.0579C12.1553 17.5125 12.104 17.9819 12.104 18.4659V21.3699Z"
            fill="var(--logo-color)"></path>
    </svg>
</template>
<script setup lang="ts">
// Define props with default values
defineProps({
  width: {
    type: [String, Number],
    default: 88
  },
  height: {
    type: [String, Number],
    default: 38
  }
})
</script>


================================================
FILE: frontend/src/components/icons/ManusTextIcon.vue
================================================
<template>
    <svg height="10" width="59" fill="none" viewBox="0 0 59 10" xmlns="http://www.w3.org/2000/svg">
        <path
            d="M52.481 9.37181H51.9695V6.36881H52.6625C52.8495 7.16081 53.119 7.73831 53.471 8.10131C53.823 8.46431 54.2795 8.64581 54.8405 8.64581C55.2475 8.64581 55.561 8.56331 55.781 8.39831C56.012 8.22231 56.1275 7.98581 56.1275 7.68881C56.1275 7.38081 55.99 7.08381 55.715 6.79781C55.44 6.50081 54.9945 6.18731 54.3785 5.85731C53.5425 5.40631 52.943 4.96081 52.58 4.52081C52.217 4.06981 52.0355 3.56381 52.0355 3.00281C52.0355 2.63981 52.1015 2.30431 52.2335 1.99631C52.3765 1.67731 52.5635 1.40231 52.7945 1.17131C53.0365 0.940313 53.3225 0.764313 53.6525 0.643312C53.9825 0.511313 54.34 0.445312 54.725 0.445312C55.066 0.445312 55.4015 0.494812 55.7315 0.593812C56.0725 0.692812 56.3695 0.830313 56.6225 1.00631L56.9195 0.610313H57.3485V3.10181H56.705C56.452 2.47481 56.188 2.02381 55.913 1.74881C55.649 1.47381 55.3245 1.33631 54.9395 1.33631C54.6315 1.33631 54.384 1.41881 54.197 1.58381C54.021 1.74881 53.933 1.96881 53.933 2.24381C53.933 2.55181 54.065 2.84331 54.329 3.11831C54.604 3.39331 55.055 3.69581 55.682 4.02581C56.122 4.26781 56.5015 4.50431 56.8205 4.73531C57.1395 4.96631 57.398 5.20281 57.596 5.44481C57.794 5.67581 57.937 5.92331 58.025 6.18731C58.124 6.44031 58.1735 6.71531 58.1735 7.01231C58.1735 7.39731 58.102 7.74381 57.959 8.05181C57.816 8.35981 57.6125 8.62381 57.3485 8.84381C57.0845 9.06381 56.7655 9.23431 56.3915 9.35531C56.0285 9.47631 55.6215 9.53681 55.1705 9.53681C54.6975 9.53681 54.2575 9.47631 53.8505 9.35531C53.4435 9.22331 53.108 9.03631 52.844 8.79431L52.481 9.37181Z"
            fill="var(--logo-color)"></path>
        <path
            d="M47.2177 3.33281C47.2177 2.89281 47.2067 2.54631 47.1847 2.29331C47.1627 2.02931 47.1022 1.83131 47.0032 1.69931C46.9042 1.55631 46.7557 1.46281 46.5577 1.41881C46.3707 1.36381 46.1122 1.31981 45.7822 1.28681V0.626812H49.5112V5.62631C49.5112 6.29731 49.5167 6.82531 49.5277 7.21031C49.5497 7.58431 49.5827 7.86481 49.6267 8.05181C49.6597 8.19481 49.6982 8.31031 49.7422 8.39831C49.7862 8.47531 49.8577 8.54131 49.9567 8.59631C50.0557 8.64031 50.1877 8.67331 50.3527 8.69531C50.5287 8.70631 50.7542 8.71181 51.0292 8.71181V9.35531L47.7457 9.55331L47.5642 8.08481H47.4982C47.2122 8.54681 46.8107 8.90431 46.2937 9.15731C45.7767 9.41031 45.1992 9.53681 44.5612 9.53681C43.3842 9.53681 42.4877 9.11881 41.8717 8.28281C41.3987 7.64481 41.1622 6.73731 41.1622 5.56031V3.33281C41.1622 2.88181 41.1512 2.52981 41.1292 2.27681C41.1072 2.01281 41.0467 1.81481 40.9477 1.68281C40.8597 1.55081 40.7222 1.46281 40.5352 1.41881C40.3482 1.36381 40.0897 1.31981 39.7597 1.28681V0.626812H43.4557V5.29631C43.4557 6.40731 43.5932 7.21581 43.8682 7.72181C44.1432 8.21681 44.5832 8.46431 45.1882 8.46431C45.8372 8.46431 46.3377 8.16731 46.6897 7.57331C47.0417 7.00131 47.2177 6.15981 47.2177 5.04881V3.33281Z"
            fill="var(--logo-color)"></path>
        <path
            d="M31.9625 6.68231C31.9625 7.13331 31.9735 7.49081 31.9955 7.75481C32.0285 8.00781 32.089 8.20581 32.177 8.34881C32.276 8.48081 32.419 8.56881 32.606 8.61281C32.804 8.65681 33.068 8.68981 33.398 8.71181V9.37181H28.2005V8.71181C28.5195 8.68981 28.7725 8.65681 28.9595 8.61281C29.1575 8.56881 29.306 8.48081 29.405 8.34881C29.515 8.21681 29.5865 8.02981 29.6195 7.78781C29.6525 7.54581 29.669 7.21581 29.669 6.79781V4.73531C29.669 4.08631 29.658 3.56381 29.636 3.16781C29.614 2.76081 29.5865 2.48581 29.5535 2.34281C29.5205 2.19981 29.4765 2.08431 29.4215 1.99631C29.3665 1.89731 29.284 1.82581 29.174 1.78181C29.064 1.72681 28.9265 1.69381 28.7615 1.68281C28.5965 1.66081 28.3875 1.64981 28.1345 1.64981V1.08881L31.319 0.461813L31.5335 1.91381H31.5995C31.9625 1.45181 32.3915 1.09431 32.8865 0.841312C33.3815 0.588312 33.926 0.461813 34.52 0.461813C35.224 0.461813 35.7905 0.560813 36.2195 0.758813C36.6595 0.945813 37.05 1.26481 37.391 1.71581C37.578 1.96881 37.743 2.29881 37.886 2.70581C38.029 3.10181 38.1005 3.65181 38.1005 4.35581V6.68231C38.1005 7.13331 38.1115 7.49081 38.1335 7.75481C38.1665 8.00781 38.227 8.20581 38.315 8.34881C38.414 8.48081 38.557 8.56881 38.744 8.61281C38.931 8.65681 39.184 8.68981 39.503 8.71181V9.37181H34.3385V8.71181C34.6685 8.70081 34.927 8.67331 35.114 8.62931C35.312 8.57431 35.4605 8.48081 35.5595 8.34881C35.6585 8.21681 35.7245 8.02981 35.7575 7.78781C35.7905 7.53481 35.807 7.20481 35.807 6.79781V4.55381C35.807 3.99281 35.774 3.51981 35.708 3.13481C35.642 2.74981 35.532 2.44181 35.378 2.21081C35.235 1.96881 35.0425 1.79831 34.8005 1.69931C34.5585 1.58931 34.256 1.53431 33.893 1.53431C33.541 1.53431 33.2385 1.63331 32.9855 1.83131C32.7325 2.02931 32.5125 2.30431 32.3255 2.65631C32.2265 2.85431 32.1385 3.11281 32.0615 3.43181C31.9955 3.73981 31.9625 4.06431 31.9625 4.40531V6.68231Z"
            fill="var(--logo-color)"></path>
        <path
            d="M24.0884 4.66931C23.1644 5.08731 22.4658 5.47781 21.9928 5.84081C21.5308 6.19281 21.2999 6.56131 21.2999 6.94631C21.2999 7.26531 21.3878 7.51831 21.5638 7.70531C21.7398 7.89231 21.9599 7.98581 22.2239 7.98581C22.4879 7.98581 22.7353 7.94181 22.9664 7.85381C23.1973 7.75481 23.3953 7.62831 23.5603 7.47431C23.7253 7.32031 23.8519 7.13881 23.9398 6.92981C24.0388 6.70981 24.0884 6.47881 24.0884 6.23681V4.66931ZM24.0884 3.79481V3.10181C24.0884 2.46381 23.9729 2.00181 23.7418 1.71581C23.5219 1.41881 23.1754 1.27031 22.7024 1.27031C22.3834 1.27031 22.1413 1.35831 21.9763 1.53431C21.8113 1.69931 21.6573 1.97981 21.5143 2.37581C21.4153 2.65081 21.2723 2.86531 21.0853 3.01931C20.9093 3.17331 20.6618 3.25031 20.3428 3.25031C20.0348 3.25031 19.7983 3.15681 19.6334 2.96981C19.4683 2.78281 19.3858 2.51881 19.3858 2.17781C19.3858 1.64981 19.6718 1.23181 20.2438 0.923812C20.8268 0.615812 21.7013 0.461813 22.8673 0.461813C24.0993 0.461813 24.9794 0.687312 25.5074 1.13831C26.0354 1.57831 26.2994 2.32081 26.2994 3.36581V6.97931C26.2994 7.91431 26.4864 8.38181 26.8604 8.38181C27.0694 8.38181 27.2619 8.31031 27.4379 8.16731L27.6853 8.64581C27.5313 8.92081 27.2894 9.14081 26.9594 9.30581C26.6404 9.45981 26.2774 9.53681 25.8703 9.53681C25.3644 9.53681 24.9794 9.38281 24.7154 9.07481C24.4513 8.76681 24.3193 8.33231 24.3193 7.77131H24.2369C23.9179 8.34331 23.5054 8.77781 22.9993 9.07481C22.4933 9.37181 21.9158 9.52031 21.2668 9.52031C20.5738 9.52031 20.0183 9.32781 19.6003 8.94281C19.1823 8.54681 18.9733 8.03531 18.9733 7.40831C18.9733 6.92431 19.1878 6.47331 19.6168 6.05531C20.0459 5.62631 20.7608 5.20831 21.7618 4.80131L24.0884 3.79481Z"
            fill="var(--logo-color)"></path>
        <path
            d="M4.578 6.64931C4.578 7.11131 4.589 7.47431 4.611 7.73831C4.633 8.00231 4.6935 8.20581 4.7925 8.34881C4.8915 8.48081 5.0345 8.56881 5.2215 8.61281C5.4085 8.65681 5.667 8.68981 5.997 8.71181V9.37181H0.783V8.71181C1.113 8.68981 1.377 8.65681 1.575 8.61281C1.773 8.56881 1.9215 8.48081 2.0205 8.34881C2.1195 8.21681 2.1855 8.02981 2.2185 7.78781C2.2515 7.53481 2.268 7.19931 2.268 6.78131V4.73531C2.268 4.10831 2.257 3.58581 2.235 3.16781C2.224 2.74981 2.1965 2.46381 2.1525 2.30981C2.1195 2.16681 2.0755 2.05681 2.0205 1.97981C1.9765 1.89181 1.8995 1.82581 1.7895 1.78181C1.6905 1.72681 1.5585 1.69381 1.3935 1.68281C1.2285 1.66081 1.014 1.64981 0.75 1.64981V1.08881L3.9345 0.461813L4.1325 1.89731H4.2315C4.6935 1.38031 5.1555 1.01181 5.6175 0.791812C6.0905 0.571813 6.635 0.461813 7.251 0.461813C7.977 0.461813 8.5765 0.588312 9.0495 0.841312C9.5225 1.09431 9.88 1.45731 10.122 1.93031H10.188C10.584 1.46831 11.057 1.11081 11.607 0.857812C12.157 0.593812 12.7455 0.461813 13.3725 0.461813C14.0325 0.461813 14.6045 0.544312 15.0885 0.709312C15.5835 0.874312 15.9685 1.11081 16.2435 1.41881C16.4635 1.67181 16.623 2.00181 16.722 2.40881C16.832 2.81581 16.887 3.38231 16.887 4.10831V6.64931C16.887 7.10031 16.898 7.45781 16.92 7.72181C16.953 7.98581 17.019 8.18931 17.118 8.33231C17.217 8.47531 17.36 8.56881 17.547 8.61281C17.734 8.65681 17.9925 8.68981 18.3225 8.71181V9.37181H13.1085V8.71181C13.4385 8.70081 13.697 8.67331 13.884 8.62931C14.082 8.57431 14.2305 8.48081 14.3295 8.34881C14.4395 8.20581 14.5055 8.01331 14.5275 7.77131C14.5605 7.52931 14.577 7.19931 14.577 6.78131V4.61981C14.577 4.04781 14.544 3.56381 14.478 3.16781C14.412 2.77181 14.3075 2.45281 14.1645 2.21081C14.0215 1.96881 13.829 1.79831 13.587 1.69931C13.356 1.58931 13.07 1.53431 12.729 1.53431C12.344 1.53431 12.025 1.62781 11.772 1.81481C11.53 2.00181 11.3265 2.24381 11.1615 2.54081C10.8755 3.05781 10.7325 3.70131 10.7325 4.47131V6.64931C10.7325 7.10031 10.7435 7.45781 10.7655 7.72181C10.7875 7.98581 10.848 8.18931 10.947 8.33231C11.046 8.47531 11.189 8.56881 11.376 8.61281C11.574 8.65681 11.8435 8.68981 12.1845 8.71181V9.37181H6.954V8.71181C7.284 8.68981 7.5425 8.65681 7.7295 8.61281C7.9275 8.56881 8.076 8.48081 8.175 8.34881C8.285 8.21681 8.351 8.02981 8.373 7.78781C8.406 7.53481 8.4225 7.19931 8.4225 6.78131V4.61981C8.4225 4.04781 8.3895 3.56381 8.3235 3.16781C8.2575 2.77181 8.1475 2.45281 7.9935 2.21081C7.8505 1.96881 7.658 1.79831 7.416 1.69931C7.174 1.58931 6.8715 1.53431 6.5085 1.53431C6.1455 1.53431 5.843 1.62231 5.601 1.79831C5.37 1.97431 5.1775 2.21081 5.0235 2.50781C4.8805 2.77181 4.7705 3.07431 4.6935 3.41531C4.6165 3.75631 4.578 4.10831 4.578 4.47131V6.64931Z"
            fill="var(--logo-color)"></path>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/SearchIcon.vue
================================================
<template>
    <svg xmlns="http://www.w3.org/2000/svg" :width="size" :height="size" viewBox="0 0 19 18" fill="none"
        :style="{ minWidth: `${size}px`, minHeight: `${size}px` }">
        <g filter="url(#filter0_ii_6414_3794)">
            <path
                d="M1.94922 4.7C1.94922 3.20883 3.15805 2 4.64922 2H13.2492C14.7404 2 15.9492 3.20883 15.9492 4.7V13.3C15.9492 14.7912 14.7404 16 13.2492 16H4.64922C3.15805 16 1.94922 14.7912 1.94922 13.3V4.7Z"
                fill="url(#paint0_linear_6414_3794)"></path>
        </g>
        <path
            d="M2.37779 4.7C2.37779 3.44552 3.39474 2.42857 4.64922 2.42857H13.2492C14.5037 2.42857 15.5206 3.44552 15.5206 4.7V13.3C15.5206 14.5545 14.5037 15.5714 13.2492 15.5714H4.64922C3.39474 15.5714 2.37779 14.5545 2.37779 13.3V4.7Z"
            stroke="#5F5F5F" stroke-width="0.857143"></path>
        <circle cx="8.57422" cy="8.625" r="3" stroke="#ACACAC" stroke-width="1.2" stroke-linecap="round"
            stroke-linejoin="round"></circle>
        <path d="M10.8242 10.875L12.3242 12.375" stroke="#ACACAC" stroke-width="1.2" stroke-linecap="round"
            stroke-linejoin="round"></path>
        <defs>
            <filter id="filter0_ii_6414_3794" x="1.44922" y="1.5" width="15" height="15" filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB">
                <feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood>
                <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="1" dy="1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.12 0"></feColorMatrix>
                <feBlend mode="normal" in2="shape" result="effect1_innerShadow_6414_3794"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="-1" dy="-1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.16 0"></feColorMatrix>
                <feBlend mode="normal" in2="effect1_innerShadow_6414_3794" result="effect2_innerShadow_6414_3794">
                </feBlend>
            </filter>
            <linearGradient id="paint0_linear_6414_3794" x1="8.94922" y1="2" x2="8.94922" y2="16"
                gradientUnits="userSpaceOnUse">
                <stop stop-color="#272728" stop-opacity="0"></stop>
                <stop offset="1" stop-color="white" stop-opacity="0.16"></stop>
            </linearGradient>
        </defs>
    </svg>
</template>

<script setup lang="ts">
defineProps({
    size: {
        type: Number,
        default: 21,
    },
});
</script>


================================================
FILE: frontend/src/components/icons/SendIcon.vue
================================================
<template>
    <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 16 16" fill="none">
        <path
            d="M7.91699 15.0642C7.53125 15.0642 7.22119 14.9397 6.98682 14.6907C6.75244 14.4465 6.63525 14.1218 6.63525 13.7166V6.39966L6.77441 3.34546L7.48486 3.89478L5.62451 6.12134L3.99121 7.76196C3.87402 7.87915 3.73975 7.97681 3.58838 8.05493C3.44189 8.13306 3.271 8.17212 3.07568 8.17212C2.73389 8.17212 2.4458 8.05981 2.21143 7.83521C1.98193 7.60571 1.86719 7.3103 1.86719 6.94897C1.86719 6.60229 1.99902 6.29712 2.2627 6.03345L6.97949 1.30933C7.0918 1.19214 7.2334 1.10181 7.4043 1.03833C7.5752 0.969971 7.74609 0.935791 7.91699 0.935791C8.08789 0.935791 8.25879 0.969971 8.42969 1.03833C8.60059 1.10181 8.74463 1.19214 8.86182 1.30933L13.5786 6.03345C13.8423 6.29712 13.9741 6.60229 13.9741 6.94897C13.9741 7.3103 13.8569 7.60571 13.6226 7.83521C13.3931 8.05981 13.1074 8.17212 12.7656 8.17212C12.5703 8.17212 12.397 8.13306 12.2456 8.05493C12.0991 7.97681 11.9673 7.87915 11.8501 7.76196L10.2095 6.12134L8.34912 3.89478L9.05957 3.34546L9.19141 6.39966V13.7166C9.19141 14.1218 9.07422 14.4465 8.83984 14.6907C8.60547 14.9397 8.29785 15.0642 7.91699 15.0642Z"
            :fill="disabled ? 'var(--icon-disable)' : 'var(--icon-onblack)'"></path>
    </svg>
</template>

<script setup lang="ts">
defineProps<{
    disabled?: boolean;
}>();
</script>


================================================
FILE: frontend/src/components/icons/ShellIcon.vue
================================================
<template>
    <svg :width="size" :height="size" viewBox="0 0 19 18" fill="none" xmlns="http://www.w3.org/2000/svg"
        :style="{ minWidth: `${size}px`, minHeight: `${size}px` }">
        <g id="chat/ç±»å icon">
            <g id="Rectangle 40263">
                <g filter="url(#filter0_ii_1527_83555)">
                    <path
                        d="M2 4.7C2 3.20883 3.20883 2 4.7 2H13.3C14.7912 2 16 3.20883 16 4.7V13.3C16 14.7912 14.7912 16 13.3 16H4.7C3.20883 16 2 14.7912 2 13.3V4.7Z"
                        fill="url(#paint0_linear_1527_83555)"></path>
                </g>
                <path
                    d="M2.42857 4.7C2.42857 3.44552 3.44552 2.42857 4.7 2.42857H13.3C14.5545 2.42857 15.5714 3.44552 15.5714 4.7V13.3C15.5714 14.5545 14.5545 15.5714 13.3 15.5714H4.7C3.44552 15.5714 2.42857 14.5545 2.42857 13.3V4.7Z"
                    stroke="#B9B9B7" stroke-width="0.857143"></path>
            </g>
            <path id="Vector 7323" d="M5.25 7L7 9L5.25 11" stroke="#535350" stroke-width="1.2" stroke-linecap="round"
                stroke-linejoin="round"></path>
            <path id="Vector 7324" d="M8.625 11H12" stroke="#535350" stroke-width="1.2" stroke-linecap="round"
                stroke-linejoin="round"></path>
        </g>
        <defs>
            <filter id="filter0_ii_1527_83555" x="1.5" y="1.5" width="15" height="15" filterUnits="userSpaceOnUse"
                color-interpolation-filters="sRGB">
                <feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood>
                <feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="1" dy="1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.6 0"></feColorMatrix>
                <feBlend mode="normal" in2="shape" result="effect1_innerShadow_1527_83555"></feBlend>
                <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                    result="hardAlpha"></feColorMatrix>
                <feOffset dx="-1" dy="-1"></feOffset>
                <feGaussianBlur stdDeviation="0.25"></feGaussianBlur>
                <feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"></feComposite>
                <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.08 0"></feColorMatrix>
                <feBlend mode="normal" in2="effect1_innerShadow_1527_83555" result="effect2_innerShadow_1527_83555">
                </feBlend>
            </filter>
            <linearGradient id="paint0_linear_1527_83555" x1="9" y1="2" x2="9" y2="16" gradientUnits="userSpaceOnUse">
                <stop stop-color="white" stop-opacity="0"></stop>
                <stop offset="1" stop-opacity="0.16"></stop>
            </linearGradient>
        </defs>
    </svg>
</template>

<script setup lang="ts">
defineProps({
    size: {
        type: Number,
        default: 21
    }
});
</script>


================================================
FILE: frontend/src/components/icons/SpinnigIcon.vue
================================================
<template>

    <svg xmlns="http://www.w3.org/2000/svg" width="38" height="38" viewBox="0 0 38 38" fill="none"
        style="animation: 4s linear 0s infinite reverse none running spin;">
        <mask id="path-1-inside-1_1527_82619" fill="white">
            <path
                d="M38 19C38 29.4934 29.4934 38 19 38C8.50659 38 0 29.4934 0 19C0 8.50659 8.50659 0 19 0C29.4934 0 38 8.50659 38 19Z">
            </path>
        </mask>
        <g clip-path="url(#paint0_angular_1527_82619_clip_path)" data-figma-skip-parse="true"
            mask="url(#path-1-inside-1_1527_82619)">
            <g transform="matrix(0 0.019 -0.019 0 19 19)">
                <foreignObject x="-1105.26" y="-1105.26" width="2210.53" height="2210.53">
                    <div
                        style="background: conic-gradient(from 90deg, rgb(0, 129, 242) 0deg, rgba(0, 129, 242, 0) 360deg); height: 100%; width: 100%; opacity: 1;">
                    </div>
                </foreignObject>
            </g>
        </g>
        <path
            d="M36 19C36 28.3888 28.3888 36 19 36V40C30.598 40 40 30.598 40 19H36ZM19 36C9.61116 36 2 28.3888 2 19H-2C-2 30.598 7.40202 40 19 40V36ZM2 19C2 9.61116 9.61116 2 19 2V-2C7.40202 -2 -2 7.40202 -2 19H2ZM19 2C28.3888 2 36 9.61116 36 19H40C40 7.40202 30.598 -2 19 -2V2Z"
            data-figma-gradient-fill="{&quot;type&quot;:&quot;GRADIENT_ANGULAR&quot;,&quot;stops&quot;:[{&quot;color&quot;:{&quot;r&quot;:0.0,&quot;g&quot;:0.50588238239288330,&quot;b&quot;:0.94901961088180542,&quot;a&quot;:1.0},&quot;position&quot;:0.0},{&quot;color&quot;:{&quot;r&quot;:0.0,&quot;g&quot;:0.50588238239288330,&quot;b&quot;:0.94901961088180542,&quot;a&quot;:0.0},&quot;position&quot;:1.0}],&quot;stopsVar&quot;:[{&quot;color&quot;:{&quot;r&quot;:0.0,&quot;g&quot;:0.50588238239288330,&quot;b&quot;:0.94901961088180542,&quot;a&quot;:1.0},&quot;position&quot;:0.0},{&quot;color&quot;:{&quot;r&quot;:0.0,&quot;g&quot;:0.50588238239288330,&quot;b&quot;:0.94901961088180542,&quot;a&quot;:0.0},&quot;position&quot;:1.0}],&quot;transform&quot;:{&quot;m00&quot;:2.3268289405024801e-15,&quot;m01&quot;:-38.0,&quot;m02&quot;:38.0,&quot;m10&quot;:38.0,&quot;m11&quot;:2.3268289405024801e-15,&quot;m12&quot;:-2.3268289405024801e-15},&quot;opacity&quot;:1.0,&quot;blendMode&quot;:&quot;NORMAL&quot;,&quot;visible&quot;:true}"
            mask="url(#path-1-inside-1_1527_82619)">
        </path>
        <defs>
            <clipPath id="paint0_angular_1527_82619_clip_path">
                <path
                    d="M36 19C36 28.3888 28.3888 36 19 36V40C30.598 40 40 30.598 40 19H36ZM19 36C9.61116 36 2 28.3888 2 19H-2C-2 30.598 7.40202 40 19 40V36ZM2 19C2 9.61116 9.61116 2 19 2V-2C7.40202 -2 -2 7.40202 -2 19H2ZM19 2C28.3888 2 36 9.61116 36 19H40C40 7.40202 30.598 -2 19 -2V2Z"
                    mask="url(#path-1-inside-1_1527_82619)">
                </path>
            </clipPath>
        </defs>
    </svg>
</template>



<style>
@keyframes spin {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}
</style>


================================================
FILE: frontend/src/components/icons/StepSuccessIcon.vue
================================================
<template>
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
        stroke="var(--function-success)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
        class="lucide lucide-check relative top-[2px] flex-shrink-0">
        <path d="M20 6 9 17l-5-5"></path>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/SuccessIcon.vue
================================================
<template>
    <svg height="20" width="20" fill="none" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
        <g clip-path="url(#:r5pk:_clip0_1152_60239)">
            <path
                d="M10.0013 18.3337C14.6037 18.3337 18.3346 14.6027 18.3346 10.0003C18.3346 5.39795 14.6037 1.66699 10.0013 1.66699C5.39893 1.66699 1.66797 5.39795 1.66797 10.0003C1.66797 14.6027 5.39893 18.3337 10.0013 18.3337Z"
                stroke="var(--function-success)" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.66667">
            </path>
            <path d="M7.5 10.0002L9.16667 11.6668L12.5 8.3335" stroke="var(--function-success)" stroke-linecap="round"
                stroke-linejoin="round" stroke-width="1.66667"></path>
        </g>
        <defs>
            <clipPath id=":r5pk:_clip0_1152_60239">
                <rect height="20" width="20" fill="white"></rect>
            </clipPath>
        </defs>
    </svg>
</template>


================================================
FILE: frontend/src/components/icons/TakeOverIcon.vue
================================================
<template>
    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
            d="M7.36328 12.8838L7.43164 7.36719C7.4362 7.22591 7.49772 7.13249 7.61621 7.08691C7.7347 7.03678 7.84408 7.06413 7.94434 7.16895L11.7451 11.0449C11.8499 11.1589 11.875 11.2751 11.8203 11.3936C11.7656 11.512 11.6631 11.5736 11.5127 11.5781L10.0771 11.6191L11.2803 14.3945C11.3167 14.4674 11.3236 14.5426 11.3008 14.6201C11.2826 14.7021 11.2301 14.7637 11.1436 14.8047L10.4463 15.0713C10.3597 15.1077 10.2799 15.1055 10.207 15.0645C10.1341 15.028 10.0794 14.9688 10.043 14.8867L8.9082 12.0771L7.91699 13.0889C7.81673 13.1937 7.69824 13.2233 7.56152 13.1777C7.4248 13.1367 7.35872 13.0387 7.36328 12.8838ZM4.89551 11.0381C5.02311 11.1702 5.08691 11.3343 5.08691 11.5303C5.08691 11.7217 5.02083 11.8812 4.88867 12.0088L3.4873 13.4102C3.3597 13.5423 3.19792 13.6061 3.00195 13.6016C2.80599 13.597 2.64193 13.5309 2.50977 13.4033C2.38672 13.2712 2.3252 13.1094 2.3252 12.918C2.3252 12.7266 2.39128 12.5648 2.52344 12.4326L3.9248 11.0381C4.05697 10.9059 4.21875 10.8421 4.41016 10.8467C4.60612 10.8467 4.7679 10.9105 4.89551 11.0381ZM3.66504 8.03711C3.66504 8.22396 3.59668 8.38574 3.45996 8.52246C3.32324 8.65462 3.16146 8.7207 2.97461 8.7207H0.958008C0.775716 8.7207 0.616211 8.65462 0.479492 8.52246C0.342773 8.38574 0.274414 8.22396 0.274414 8.03711C0.274414 7.85026 0.342773 7.69076 0.479492 7.55859C0.616211 7.42188 0.775716 7.35352 0.958008 7.35352H2.97461C3.16146 7.35352 3.32324 7.42188 3.45996 7.55859C3.59668 7.69076 3.66504 7.85026 3.66504 8.03711ZM4.83398 4.98828C4.70182 5.11589 4.54004 5.17969 4.34863 5.17969C4.15723 5.17969 3.99544 5.11361 3.86328 4.98145L2.46875 3.57324C2.34115 3.44564 2.27734 3.28613 2.27734 3.09473C2.27734 2.89876 2.34342 2.7347 2.47559 2.60254C2.60775 2.47493 2.76953 2.41341 2.96094 2.41797C3.15234 2.41797 3.31413 2.48405 3.44629 2.61621L4.83398 4.01758C4.96615 4.14518 5.03223 4.30697 5.03223 4.50293C5.03223 4.69434 4.96615 4.85612 4.83398 4.98828ZM7.89648 3.79883C7.71419 3.79883 7.55469 3.73047 7.41797 3.59375C7.28125 3.45703 7.21289 3.29525 7.21289 3.1084V1.10547C7.21289 0.914062 7.28125 0.752279 7.41797 0.620117C7.55469 0.483398 7.71419 0.415039 7.89648 0.415039C8.08789 0.415039 8.24967 0.483398 8.38184 0.620117C8.51855 0.752279 8.58691 0.914062 8.58691 1.10547V3.1084C8.58691 3.29525 8.51855 3.45703 8.38184 3.59375C8.24967 3.73047 8.08789 3.79883 7.89648 3.79883ZM10.9043 5.04297C10.7721 4.91081 10.7038 4.74902 10.6992 4.55762C10.6992 4.36621 10.7653 4.20443 10.8975 4.07227L12.3057 2.66406C12.4378 2.53646 12.5996 2.47266 12.791 2.47266C12.9824 2.4681 13.1419 2.5319 13.2695 2.66406C13.4017 2.79622 13.4678 2.96029 13.4678 3.15625C13.4723 3.34766 13.4085 3.50944 13.2764 3.6416L11.875 5.04297C11.7474 5.17513 11.5856 5.24121 11.3896 5.24121C11.1937 5.24121 11.0319 5.17513 10.9043 5.04297ZM12.1416 8.03711C12.1416 7.85026 12.21 7.69076 12.3467 7.55859C12.4834 7.42188 12.6452 7.35352 12.832 7.35352H14.835C15.0264 7.35352 15.1904 7.42188 15.3271 7.55859C15.4639 7.69076 15.5322 7.85026 15.5322 8.03711C15.5322 8.22396 15.4639 8.38574 15.3271 8.52246C15.1904 8.65462 15.0264 8.7207 14.835 8.7207H12.832C12.6452 8.7207 12.4834 8.65462 12.3467 8.52246C12.21 8.38574 12.1416 8.22396 12.1416 8.03711Z"
            fill="currentColor">
        </path>
    </svg>
</template>
<script setup lang="ts">
</script>


================================================
FILE: frontend/src/components/login/LoginForm.vue
================================================
<template>
  <div class="w-full max-w-[384px] py-[24px] pt-0 px-[12px] relative" style="z-index:1">
    <div class="flex flex-col justify-center gap-[40px] text-[var(--text-primary)] max-sm:gap-[12px]">
      <form @submit.prevent="handleSubmit" class="flex flex-col items-stretch gap-[20px]">
        <div class="relative">
          <div class="transition-all duration-500 ease-out opacity-100 scale-100">
            <div class="flex flex-col gap-[12px]">
              <!-- Email field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="email"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Email') }}</span>
                  </label>
                </div>
                <input v-model="formData.email"
                  class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-1.5 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                  :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.email }" id="email"
                  placeholder="mail@domain.com" type="email" :disabled="isLoading" @input="validateField('email')"
                  @blur="validateField('email')">
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.email ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.email }}
                </div>
              </div>

              <!-- Password field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="password"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Password') }}</span>
                  </label>
                  <span
                    class="underline text-[var(--text-tertiary)] text-[13px] leading-[18px] transition-opacity cursor-pointer select-none hover:opacity-80 active:opacity-80"
                    @click="emits('switchToReset')">{{ t('Forgot Password?') }}</span>
                </div>
                <div class="relative w-full">
                  <input v-model="formData.password"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] pr-[40px]"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.password }"
                    :placeholder="t('Enter password')" :type="showPassword ? 'text' : 'password'"
                    :disabled="isLoading" @input="validateField('password')" @blur="validateField('password')">
                  <div
                    class="text-[var(--icon-tertiary)] absolute z-30 right-[6px] top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all"
                    @click="showPassword = !showPassword">
                    <Eye v-if="showPassword" :size="16" />
                    <EyeOff v-else :size="16" />
                  </div>
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.password ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.password }}
                </div>
              </div>

              <!-- Submit button -->
              <button type="submit"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors h-[40px] px-[16px] rounded-[10px] gap-[6px] text-sm min-w-16 w-full"
                :class="isFormValid && !isLoading
                  ? 'bg-[var(--Button-primary-black)] text-[var(--text-onblack)] hover:opacity-90 active:opacity-80'
                  : 'bg-[#898988] dark:bg-[#939393] text-[var(--text-onblack)] opacity-50 cursor-not-allowed'"
                :disabled="!isFormValid || isLoading">
                <LoaderCircle v-if="isLoading" :size="16" class="animate-spin" />
                <span>{{ isLoading ? t('Processing...') : t('Login') }}</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Toggle to register -->
        <div v-if="hasRegister" class="text-center text-[13px] leading-[18px] text-[var(--text-tertiary)] mt-[8px]">
          <span>{{ t('Don\'t have an account?') }}</span>
          <span
            class="ms-[8px] text-[var(--text-secondary)] cursor-pointer select-none hover:opacity-80 active:opacity-70 transition-all underline"
            @click="emits('switchToRegister')">
            {{ t('Register') }}
          </span>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useI18n } from 'vue-i18n'
import { Eye, EyeOff, LoaderCircle } from 'lucide-vue-next'
import { useAuth } from '@/api'
import { validateUserInput } from '@/utils/auth'
import { showErrorToast, showSuccessToast } from '@/utils/toast'
import { getCachedAuthProvider } from '@/api/auth'

const { t } = useI18n()

// Emits
const emits = defineEmits<{
  success: []
  switchToRegister: []
  switchToReset: []
}>()

const { login, isLoading, authError } = useAuth()
const hasRegister = ref(false)

// Form state
const showPassword = ref(false)

// Form data
const formData = ref({
  email: '',
  password: ''
})

// Validation errors
const validationErrors = ref<Record<string, string>>({})

// Clear form
const clearForm = () => {
  formData.value = {
    email: '',
    password: ''
  }
  validationErrors.value = {}
}

// Validate single field
const validateField = (field: string) => {
  const errors: Record<string, string> = {}

  if (field === 'email') {
    const result = validateUserInput({ email: formData.value.email })
    if (result.errors.email) {
      errors.email = result.errors.email
    }
  }

  if (field === 'password') {
    const result = validateUserInput({ password: formData.value.password })
    if (result.errors.password) {
      errors.password = result.errors.password
    }
  }

  // Update error state
  Object.keys(errors).forEach(key => {
    validationErrors.value[key] = errors[key]
  })

  // Clear fixed errors
  if (!errors[field]) {
    delete validationErrors.value[field]
  }
}

// Validate entire form
const validateForm = () => {
  const data = {
    email: formData.value.email,
    password: formData.value.password
  }

  const result = validateUserInput(data)
  validationErrors.value = { ...result.errors }

  return Object.keys(validationErrors.value).length === 0
}

// Check if form is valid
const isFormValid = computed(() => {
  const hasRequiredFields = formData.value.email.trim() && formData.value.password.trim()
  const hasNoErrors = Object.keys(validationErrors.value).length === 0
  return hasRequiredFields && hasNoErrors
})

// Submit form
const handleSubmit = async () => {
  if (!validateForm()) {
    return
  }

  try {
    await login({
      email: formData.value.email,
      password: formData.value.password
    })
    
    // Login success message
    showSuccessToast(t('Login successful! Welcome back'))
    
    // Emit success event
    emits('success')
  } catch (error: any) {
    console.error('Login failed:', error)
    // Display error message using toast
    showErrorToast(authError.value || t('Login failed, please try again'))
  }
}

onMounted(async () => {
  const authProvider = await getCachedAuthProvider()
  hasRegister.value = authProvider === 'password'
})

// Expose clearForm method for parent component
defineExpose({
  clearForm
})
</script>


================================================
FILE: frontend/src/components/login/RegisterForm.vue
================================================
<template>
  <div class="w-full max-w-[384px] py-[24px] pt-0 px-[12px] relative" style="z-index:1">
    <div class="flex flex-col justify-center gap-[40px] text-[var(--text-primary)] max-sm:gap-[12px]">
      <form @submit.prevent="handleSubmit" class="flex flex-col items-stretch gap-[20px]">
        <div class="relative">
          <div class="transition-all duration-500 ease-out opacity-100 scale-100">
            <div class="flex flex-col gap-[12px]">
              <!-- Full name field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="fullname"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Full Name') }}</span>
                  </label>
                </div>
                <input v-model="formData.fullname"
                  class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-1.5 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                  :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.fullname }" id="fullname"
                  :placeholder="t('Enter your full name')" :disabled="isLoading" @input="validateField('fullname')"
                  @blur="validateField('fullname')">
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.fullname ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.fullname }}
                </div>
              </div>

              <!-- Email field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="email"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Email') }}</span>
                  </label>
                </div>
                <input v-model="formData.email"
                  class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-1.5 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                  :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.email }" id="email"
                  placeholder="mail@domain.com" type="email" :disabled="isLoading" @input="validateField('email')"
                  @blur="validateField('email')">
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.email ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.email }}
                </div>
              </div>

              <!-- Password field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="password"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Password') }}</span>
                  </label>
                </div>
                <div class="relative w-full">
                  <input v-model="formData.password"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] pr-[40px]"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.password }"
                    :placeholder="t('Enter password')" :type="showPassword ? 'text' : 'password'"
                    :disabled="isLoading" @input="validateField('password')" @blur="validateField('password')">
                  <div
                    class="text-[var(--icon-tertiary)] absolute z-30 right-[6px] top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all"
                    @click="showPassword = !showPassword">
                    <Eye v-if="showPassword" :size="16" />
                    <EyeOff v-else :size="16" />
                  </div>
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.password ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.password }}
                </div>
              </div>

              <!-- Confirm password field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="confirmPassword"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Confirm Password') }}</span>
                  </label>
                </div>
                <div class="relative w-full">
                  <input v-model="formData.confirmPassword"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] pr-[40px]"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.confirmPassword }"
                    :placeholder="t('Enter password again')" :type="showConfirmPassword ? 'text' : 'password'"
                    :disabled="isLoading" @input="validateField('confirmPassword')"
                    @blur="validateField('confirmPassword')">
                  <div
                    class="text-[var(--icon-tertiary)] absolute z-30 right-[6px] top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all"
                    @click="showConfirmPassword = !showConfirmPassword">
                    <Eye v-if="showConfirmPassword" :size="16" />
                    <EyeOff v-else :size="16" />
                  </div>
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.confirmPassword ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.confirmPassword }}
                </div>
              </div>

              <!-- Submit button -->
              <button type="submit"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors h-[40px] px-[16px] rounded-[10px] gap-[6px] text-sm min-w-16 w-full"
                :class="isFormValid && !isLoading
                  ? 'bg-[var(--Button-primary-black)] text-[var(--text-onblack)] hover:opacity-90 active:opacity-80'
                  : 'bg-[#898988] dark:bg-[#939393] text-[var(--text-onblack)] opacity-50 cursor-not-allowed'"
                :disabled="!isFormValid || isLoading">
                <LoaderCircle v-if="isLoading" :size="16" class="animate-spin" />
                <span>{{ isLoading ? t('Processing...') : t('Register') }}</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Toggle to login -->
        <div class="text-center text-[13px] leading-[18px] text-[var(--text-tertiary)] mt-[8px]">
          <span>{{ t('Already have an account?') }}</span>
          <span
            class="ms-[8px] text-[var(--text-secondary)] cursor-pointer select-none hover:opacity-80 active:opacity-70 transition-all underline"
            @click="emits('switchToLogin')">
            {{ t('Login') }}
          </span>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { useI18n } from 'vue-i18n'
import { Eye, EyeOff, LoaderCircle } from 'lucide-vue-next'
import { useAuth } from '@/api'
import { validateUserInput } from '@/utils/auth'
import { showErrorToast, showSuccessToast } from '@/utils/toast'

const { t } = useI18n()

// Emits
const emits = defineEmits<{
  success: []
  switchToLogin: []
}>()

const { register, isLoading, authError } = useAuth()

// Form state
const showPassword = ref(false)
const showConfirmPassword = ref(false)

// Form data
const formData = ref({
  fullname: '',
  email: '',
  password: '',
  confirmPassword: ''
})

// Validation errors
const validationErrors = ref<Record<string, string>>({})

// Clear form
const clearForm = () => {
  formData.value = {
    fullname: '',
    email: '',
    password: '',
    confirmPassword: ''
  }
  validationErrors.value = {}
}

// Validate single field
const validateField = (field: string) => {
  const errors: Record<string, string> = {}

  if (field === 'fullname') {
    const result = validateUserInput({ fullname: formData.value.fullname })
    if (result.errors.fullname) {
      errors.fullname = result.errors.fullname
    }
  }

  if (field === 'email') {
    const result = validateUserInput({ email: formData.value.email })
    if (result.errors.email) {
      errors.email = result.errors.email
    }
  }

  if (field === 'password') {
    const result = validateUserInput({ password: formData.value.password })
    if (result.errors.password) {
      errors.password = result.errors.password
    }
  }

  if (field === 'confirmPassword') {
    if (formData.value.password !== formData.value.confirmPassword) {
      errors.confirmPassword = t('Passwords do not match')
    }
  }

  // Update error state
  Object.keys(errors).forEach(key => {
    validationErrors.value[key] = errors[key]
  })

  // Clear fixed errors
  if (!errors[field]) {
    delete validationErrors.value[field]
  }
}

// Validate entire form
const validateForm = () => {
  const data = {
    fullname: formData.value.fullname,
    email: formData.value.email,
    password: formData.value.password
  }

  const result = validateUserInput(data)
  validationErrors.value = { ...result.errors }

  // Validate confirm password
  if (formData.value.password !== formData.value.confirmPassword) {
    validationErrors.value.confirmPassword = t('Passwords do not match')
  }

  return Object.keys(validationErrors.value).length === 0
}

// Check if form is valid
const isFormValid = computed(() => {
  const hasRequiredFields = formData.value.fullname.trim() && 
                           formData.value.email.trim() && 
                           formData.value.password.trim() && 
                           formData.value.confirmPassword.trim()

  const hasNoErrors = Object.keys(validationErrors.value).length === 0

  return hasRequiredFields && hasNoErrors
})

// Submit form
const handleSubmit = async () => {
  if (!validateForm()) {
    return
  }

  try {
    await register({
      fullname: formData.value.fullname,
      email: formData.value.email,
      password: formData.value.password
    })
    
    // Registration success message
    showSuccessToast(t('Registration successful! Welcome to Manus'))
    
    // Emit success event
    emits('success')
  } catch (error: any) {
    console.error('Registration failed:', error)
    // Display error message using toast
    showErrorToast(authError.value || t('Registration failed, please try again'))
  }
}

// Re-validate confirm password when original password changes
watch(() => formData.value.password, () => {
  if (formData.value.confirmPassword) {
    validateField('confirmPassword')
  }
})

// Expose clearForm method for parent component
defineExpose({
  clearForm
})
</script>



================================================
FILE: frontend/src/components/login/ResetPasswordEmailForm.vue
================================================
<template>
  <div class="w-full max-w-[384px] py-[24px] pt-0 px-[12px] relative" style="z-index:1">
    <div class="flex flex-col justify-center gap-[40px] text-[var(--text-primary)] max-sm:gap-[12px]">
      <form @submit.prevent="handleSubmit" class="flex flex-col items-stretch gap-[20px]">
        <div class="relative">
          <div class="transition-all duration-500 ease-out opacity-100 scale-100">
            <div class="flex flex-col gap-[12px]">

              <!-- Email field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="email"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Email Address') }}</span>
                  </label>
                </div>
                <div class="w-full relative">
                  <input v-model="formData.email"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pb-1 pl-3 pr-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)]"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.email }"
                    :placeholder="t('Enter your email address')" 
                    id="email" 
                    type="email"
                    :disabled="isLoading"
                    @input="validateField('email')" 
                    @blur="validateField('email')">
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.email ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.email }}
                </div>
              </div>

              <!-- Submit button -->
              <button type="submit"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors h-[40px] px-[16px] rounded-[10px] gap-[6px] text-sm min-w-16 w-full"
                :class="isFormValid && !isLoading
                  ? 'bg-[var(--Button-primary-black)] text-[var(--text-onblack)] hover:opacity-90 active:opacity-80'
                  : 'bg-[#898988] dark:bg-[#939393] text-[var(--text-onblack)] opacity-50 cursor-not-allowed'"
                :disabled="!isFormValid || isLoading">
                <LoaderCircle v-if="isLoading" :size="16" class="animate-spin" />
                <span>{{ isLoading ? t('Sending...') : t('Send Verification Code') }}</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div
          class="flex flex-col gap-[8px] text-center text-[13px] leading-[18px] text-[var(--text-tertiary)] mt-[8px]">

          <!-- Back to login -->
          <div>
            <span>{{ t('Remember your password?') }}</span>
            <span
              class="ms-[8px] text-[var(--text-secondary)] cursor-pointer select-none hover:opacity-80 active:opacity-70 transition-all underline"
              @click="emits('backToLogin')">
              {{ t('Back to Login') }}
            </span>
          </div>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { LoaderCircle } from 'lucide-vue-next'
import { showErrorToast, showSuccessToast } from '@/utils/toast'

const { t } = useI18n()

// Emits
const emits = defineEmits<{
  success: [email: string]
  backToLogin: []
}>()

// Form state
const isLoading = ref(false)

// Form data
const formData = ref({
  email: ''
})

// Validation errors
const validationErrors = ref<Record<string, string>>({})

// Validate single field
const validateField = (field: string) => {
  const errors: Record<string, string> = {}

  if (field === 'email') {
    if (!formData.value.email.trim()) {
      errors.email = t('Email is required')
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.value.email.trim())) {
      errors.email = t('Please enter a valid email address')
    }
  }

  // Update error state
  Object.keys(errors).forEach(key => {
    validationErrors.value[key] = errors[key]
  })

  // Clear fixed errors
  if (!errors[field]) {
    delete validationErrors.value[field]
  }
}

// Validate entire form
const validateForm = () => {
  validateField('email')
  return Object.keys(validationErrors.value).length === 0
}

// Check if form is valid
const isFormValid = computed(() => {
  const hasRequiredFields = formData.value.email.trim()
  const hasNoErrors = Object.keys(validationErrors.value).length === 0
  return hasRequiredFields && hasNoErrors
})

// Submit form
const handleSubmit = async () => {
  if (!validateForm()) {
    return
  }

  isLoading.value = true

  try {
    // Simply emit success with email - the verification will be sent in the next component
    emits('success', formData.value.email.trim().toLowerCase())
    
    console.log('Email submitted for password reset:', formData.value.email)

  } catch (error: any) {
    console.error('Email submission failed:', error)
    showErrorToast(t('An error occurred. Please try again.'))
  } finally {
    isLoading.value = false
  }
}

// Clear form
const clearForm = () => {
  formData.value = {
    email: ''
  }
  validationErrors.value = {}
}

// Expose methods for parent component
defineExpose({
  clearForm
})
</script>



================================================
FILE: frontend/src/components/login/ResetPasswordForm.vue
================================================
<template>
  <div class="w-full max-w-[384px] py-[24px] pt-0 px-[12px] relative" style="z-index:1">
    <!-- Step 1: Email input for sending verification code -->
    <div v-if="currentStep === 'email'" class="flex flex-col justify-center gap-[40px] text-[var(--text-primary)] max-sm:gap-[12px]">
      <form @submit.prevent="handleSendCode" class="flex flex-col items-stretch gap-[20px]">
        <div class="relative">
          <div class="transition-all duration-500 ease-out opacity-100 scale-100">
            <div class="flex flex-col gap-[12px]">

              <!-- Email field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="reset-email"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Email') }}</span>
                  </label>
                </div>
                <input v-model="formData.email"
                  class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-1.5 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                  :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.email }" id="reset-email"
                  placeholder="mail@domain.com" type="email" :disabled="isLoading" @input="validateField('email')"
                  @blur="validateField('email')">
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.email ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.email }}
                </div>
              </div>

              <!-- Submit button -->
              <button type="submit"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors h-[40px] px-[16px] rounded-[10px] gap-[6px] text-sm min-w-16 w-full"
                :class="isFormValid && !isLoading
                  ? 'bg-[var(--Button-primary-black)] text-[var(--text-onblack)] hover:opacity-90 active:opacity-80'
                  : 'bg-[#898988] dark:bg-[#939393] text-[var(--text-onblack)] opacity-50 cursor-not-allowed'"
                :disabled="!isFormValid || isLoading">
                <LoaderCircle v-if="isLoading" :size="16" class="animate-spin" />
                <span>{{ isLoading ? t('Sending Code...') : t('Send Verification Code') }}</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Back to login -->
        <div class="text-center text-[13px] leading-[18px] text-[var(--text-tertiary)] mt-[8px]">
          <span>{{ t('Remember your password?') }}</span>
          <span
            class="ms-[8px] text-[var(--text-secondary)] cursor-pointer select-none hover:opacity-80 active:opacity-70 transition-all underline"
            @click="emits('backToLogin')">
            {{ t('Back to Login') }}
          </span>
        </div>
      </form>
    </div>

    <!-- Step 2: Verification code and password reset -->
    <ResetPasswordVerificationForm 
      v-else-if="currentStep === 'verification'"
      :email="formData.email"
      @success="handleResetSuccess"
      @back-to-email="backToEmailStep"
      @back-to-login="emits('backToLogin')" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { LoaderCircle } from 'lucide-vue-next'
import { validateUserInput } from '@/utils/auth'
import { showErrorToast, showSuccessToast } from '@/utils/toast'
import { sendVerificationCode } from '@/api/auth'
import ResetPasswordVerificationForm from './ResetPasswordVerificationForm.vue'

const { t } = useI18n()

// Emits
const emits = defineEmits<{
  backToLogin: []
}>()

// Form state
const isLoading = ref(false)
const currentStep = ref<'email' | 'verification'>('email')

// Form data
const formData = ref({
  email: ''
})

// Validation errors
const validationErrors = ref<Record<string, string>>({})

// Clear form
const clearForm = () => {
  formData.value = {
    email: ''
  }
  validationErrors.value = {}
  currentStep.value = 'email'
}

// Validate single field
const validateField = (field: string) => {
  const errors: Record<string, string> = {}

  if (field === 'email') {
    const result = validateUserInput({ email: formData.value.email })
    if (result.errors.email) {
      errors.email = result.errors.email
    }
  }

  // Update error state
  Object.keys(errors).forEach(key => {
    validationErrors.value[key] = errors[key]
  })

  // Clear fixed errors
  if (!errors[field]) {
    delete validationErrors.value[field]
  }
}

// Validate entire form
const validateForm = () => {
  const data = {
    email: formData.value.email
  }

  const result = validateUserInput(data)
  validationErrors.value = { ...result.errors }

  return Object.keys(validationErrors.value).length === 0
}

// Check if form is valid
const isFormValid = computed(() => {
  const hasRequiredFields = formData.value.email.trim()
  const hasNoErrors = Object.keys(validationErrors.value).length === 0
  return hasRequiredFields && hasNoErrors
})

// Send verification code
const handleSendCode = async () => {
  if (!validateForm()) {
    return
  }

  isLoading.value = true

  try {
    // Call the API to send verification code
    await sendVerificationCode({ email: formData.value.email })
    
    // Switch to verification step
    currentStep.value = 'verification'
    showSuccessToast(t('Verification code sent to your email'))
    
    console.log('Verification code sent to:', formData.value.email)
  } catch (error: any) {
    console.error('Send verification code failed:', error)
    showErrorToast(t('Failed to send verification code. Please try again.'))
  } finally {
    isLoading.value = false
  }
}

// Handle successful password reset
const handleResetSuccess = () => {
  // Reset form and go back to login
  clearForm()
  emits('backToLogin')
}

// Go back to email step
const backToEmailStep = () => {
  currentStep.value = 'email'
  validationErrors.value = {}
}

// Expose methods for parent component
defineExpose({
  clearForm
})
</script>



================================================
FILE: frontend/src/components/login/ResetPasswordVerificationForm.vue
================================================
<template>
  <div class="w-full max-w-[384px] py-[24px] pt-0 px-[12px] relative" style="z-index:1">
    <div class="flex flex-col justify-center gap-[40px] text-[var(--text-primary)] max-sm:gap-[12px]">
      <form @submit.prevent="handleSubmit" class="flex flex-col items-stretch gap-[20px]">
        <div class="relative">
          <div class="transition-all duration-500 ease-out opacity-100 scale-100">
            <div class="flex flex-col gap-[12px]">

              <!-- Verification code field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="verifyCode"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Verification code sent to') }}<b>{{ props.email }}</b></span>
                  </label>
                </div>
                <div class="w-full relative">
                  <input v-model="formData.verificationCode"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] pr-[128px]"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.verificationCode }"
                    :placeholder="t('Enter 6-digit verification code')" id="verifyCode" type="text" maxlength="6" pattern="[0-9]{6}"
                    inputmode="numeric"
                    :disabled="isLoading"
                    @input="handleVerificationCodeInput" 
                    @blur="validateField('verificationCode')"
                    @paste="handlePaste">
                  <!-- Resend button or countdown -->
                  <div
                    class="absolute w-[120px] z-[30] top-1/2 right-0 -translate-y-1/2 text-center border-l-[1px] border-l-color-[var(--border-main)] leading-[0px]">
                    <!-- Show resend button when countdown is 0 -->
                    <div v-if="resendCooldown === 0"
                      class="inline-flex min-w-[60px] justify-center items-center gap-[4px] text-[var(--text-blue)] text-[14px] font-[400] tracking-[0px] leading-[22px] select-none flex-1 cursor-pointer hover:opacity-80 active:opacity-70 duration-150"
                      @click="handleResendCode">
                      {{ t('Resend') }}
                    </div>
                    <!-- Show countdown when resending is on cooldown -->
                    <span v-else
                      class="inline-block min-w-[60px] text-[var(--text-blue)] text-center text-[14px] leading-[18px] select-none opacity-50 transition-opacity">
                      {{ resendCooldown }}s
                    </span>
                  </div>
                </div>
                <!-- Error message for verification code -->
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.verificationCode ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.verificationCode }}
                </div>
              </div>

              <!-- New password field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="new-password"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('New Password') }}</span>
                  </label>
                </div>
                <div class="relative w-full">
                  <input v-model="formData.newPassword"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-10 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.newPassword }" id="new-password"
                    :placeholder="t('Enter your new password')" :type="showNewPassword ? 'text' : 'password'"
                    :disabled="isLoading" @input="validateField('newPassword')" @blur="validateField('newPassword')">
                  <button type="button" @click="showNewPassword = !showNewPassword"
                    class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-[var(--text-tertiary)] hover:text-[var(--text-secondary)] transition-colors">
                    <Eye v-if="showNewPassword" :size="16" />
                    <EyeOff v-else :size="16" />
                  </button>
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.newPassword ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.newPassword }}
                </div>
              </div>

              <!-- Confirm password field -->
              <div class="flex flex-col items-start">
                <div class="w-full flex items-center justify-between gap-[12px] mb-[8px]">
                  <label for="confirm-password"
                    class="text-[13px] text-[var(--text-primary)] font-medium after:content-[&quot;*&quot;] after:text-[var(--function-error)] after:ml-[4px]">
                    <span>{{ t('Confirm Password') }}</span>
                  </label>
                </div>
                <div class="relative w-full">
                  <input v-model="formData.confirmPassword"
                    class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] bg-[var(--fill-input-chat)] pt-1 pr-10 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] w-full"
                    :class="{ 'ring-1 ring-[var(--function-error)]': validationErrors.confirmPassword }"
                    id="confirm-password" :placeholder="t('Confirm your new password')"
                    :type="showConfirmPassword ? 'text' : 'password'" :disabled="isLoading"
                    @input="validateField('confirmPassword')" @blur="validateField('confirmPassword')">
                  <button type="button" @click="showConfirmPassword = !showConfirmPassword"
                    class="absolute right-2 top-1/2 transform -translate-y-1/2 p-1 text-[var(--text-tertiary)] hover:text-[var(--text-secondary)] transition-colors">
                    <Eye v-if="showConfirmPassword" :size="16" />
                    <EyeOff v-else :size="16" />
                  </button>
                </div>
                <div
                  class="text-[13px] text-[var(--function-error)] leading-[18px] overflow-hidden transition-all duration-300 ease-out"
                  :class="validationErrors.confirmPassword ? 'opacity-100 max-h-[60px] mt-[2px]' : 'opacity-0 max-h-0 mt-0'">
                  {{ validationErrors.confirmPassword }}
                </div>
              </div>

              <!-- Submit button -->
              <button type="submit"
                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors h-[40px] px-[16px] rounded-[10px] gap-[6px] text-sm min-w-16 w-full"
                :class="isFormValid && !isLoading
                  ? 'bg-[var(--Button-primary-black)] text-[var(--text-onblack)] hover:opacity-90 active:opacity-80'
                  : 'bg-[#898988] dark:bg-[#939393] text-[var(--text-onblack)] opacity-50 cursor-not-allowed'"
                :disabled="!isFormValid || isLoading">
                <LoaderCircle v-if="isLoading" :size="16" class="animate-spin" />
                <span>{{ isLoading ? t('Updating...') : t('Update Password') }}</span>
              </button>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div
          class="flex flex-col gap-[8px] text-center text-[13px] leading-[18px] text-[var(--text-tertiary)] mt-[8px]">

          <!-- Back to login -->
          <div>
            <span>{{ isPasswordUpdated ? t('Ready to login?') : t('Want to try a different email?') }}</span>
            <span
              class="ms-[8px] text-[var(--text-secondary)] cursor-pointer select-none hover:opacity-80 active:opacity-70 transition-all underline"
              @click="handleBackAction">
              {{ isPasswordUpdated ? t('Back to Login') : t('Go Back') }}
            </span>
          </div>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useI18n } from 'vue-i18n'
import { LoaderCircle, Eye, EyeOff } from 'lucide-vue-next'
import { validateUserInput } from '@/utils/auth'
import { showErrorToast, showSuccessToast } from '@/utils/toast'
import { sendVerificationCode, resetPassword } from '@/api/auth'

const { t } = useI18n()

// Props
interface Props {
  email: string
}

const props = defineProps<Props>()

// Emits
const emits = defineEmits<{
  success: []
  backToEmail: []
  backToLogin: []
}>()

// Form state
const isLoading = ref(false)
const isPasswordUpdated = ref(false)
const showNewPassword = ref(false)
const showConfirmPassword = ref(false)

// Resend cooldown
const resendCooldown = ref(0)
let resendTimer: NodeJS.Timeout | null = null

// Form data
const formData = ref({
  verificationCode: '',
  newPassword: '',
  confirmPassword: ''
})

// Format verification code input (only allow digits)
const formatVerificationCode = (value: string) => {
  return value.replace(/\D/g, '').slice(0, 6)
}

// Handle verification code input
const handleVerificationCodeInput = (event: Event) => {
  const target = event.target as HTMLInputElement
  const formatted = formatVerificationCode(target.value)
  formData.value.verificationCode = formatted
  validateField('verificationCode')
}

// Handle paste event for verification code
const handlePaste = (event: ClipboardEvent) => {
  event.preventDefault()
  const paste = event.clipboardData?.getData('text') || ''
  formData.value.verificationCode = formatVerificationCode(paste)
  validateField('verificationCode')
}

// Validation errors
const validationErrors = ref<Record<string, string>>({})

// Clear form
const clearForm = () => {
  formData.value = {
    verificationCode: '',
    newPassword: '',
    confirmPassword: ''
  }
  validationErrors.value = {}
  isPasswordUpdated.value = false
  showNewPassword.value = false
  showConfirmPassword.value = false
}

// Validate single field
const validateField = (field: string) => {
  const errors: Record<string, string> = {}

  if (field === 'verificationCode') {
    if (!formData.value.verificationCode.trim()) {
      errors.verificationCode = t('Verification code is required')
    } else if (!/^\d{6}$/.test(formData.value.verificationCode.trim())) {
      errors.verificationCode = t('Verification code must be 6 digits')
    }
  }

  if (field === 'newPassword') {
    const result = validateUserInput({ password: formData.value.newPassword })
    if (result.errors.password) {
      errors.newPassword = result.errors.password
    }
  }

  if (field === 'confirmPassword') {
    if (!formData.value.confirmPassword.trim()) {
      errors.confirmPassword = t('Please confirm your password')
    } else if (formData.value.newPassword !== formData.value.confirmPassword) {
      errors.confirmPassword = t('Passwords do not match')
    }
  }

  // Update error state
  Object.keys(errors).forEach(key => {
    validationErrors.value[key] = errors[key]
  })

  // Clear fixed errors
  if (!errors[field]) {
    delete validationErrors.value[field]
  }
}

// Validate entire form
const validateForm = () => {
  // Validate all fields
  validateField('verificationCode')
  validateField('newPassword')
  validateField('confirmPassword')

  return Object.keys(validationErrors.value).length === 0
}

// Check if form is valid
const isFormValid = computed(() => {
  const hasRequiredFields = formData.value.verificationCode.trim() &&
    formData.value.newPassword.trim() &&
    formData.value.confirmPassword.trim()
  const hasNoErrors = Object.keys(validationErrors.value).length === 0
  return hasRequiredFields && hasNoErrors && !isPasswordUpdated.value
})

// Start resend cooldown
const startResendCooldown = () => {
  resendCooldown.value = 60
  resendTimer = setInterval(() => {
    resendCooldown.value--
    if (resendCooldown.value <= 0) {
      clearInterval(resendTimer!)
      resendTimer = null
    }
  }, 1000)
}

// Handle resend verification code
const handleResendCode = async () => {
  if (resendCooldown.value > 0) return

    // Call the real API to send verification code
    sendVerificationCode({ email: props.email }).then(() => {
      showSuccessToast(t('Verification code sent again'))
      console.log('Resend verification code to:', props.email)
    }).catch((error: any) => {
      console.error('Resend verification code failed:', error)
      showErrorToast(t('Failed to resend verification code. Please try again.') + ': ' + error.response?.data?.message || error.message || 'Unknown error')
    })
    startResendCooldown()
}

// Submit form
const handleSubmit = async () => {
  if (!validateForm()) {
    return
  }

  isLoading.value = true

  try {
    // Call the real API to reset password
    await resetPassword({
      email: props.email,
      verification_code: formData.value.verificationCode,
      new_password: formData.value.newPassword
    })

    // Show success state
    isPasswordUpdated.value = true
    showSuccessToast(t('Password updated successfully'))

    console.log('Password reset completed for:', props.email)

    // Auto redirect to login after 3 seconds
    setTimeout(() => {
      if (isPasswordUpdated.value) {
        emits('success')
      }
    }, 500)

  } catch (error: any) {
    console.error('Password reset verification failed:', error)
    const errorMessage = error.response?.data?.message || error.message || 'Unknown error'
    
    // Handle specific error cases
    if (error.response?.status === 401) {
      showErrorToast(t('Invalid or expired verification code. Please try again.'))
    } else if (error.response?.status === 404) {
      showErrorToast(t('User not found. Please check your email address.'))
    } else if (error.response?.status === 400) {
      showErrorToast(t('Invalid request. Please check your input and try again.'))
    } else {
      showErrorToast(t('Failed to update password. Please try again.') + ': ' + errorMessage)
    }
  } finally {
    isLoading.value = false
  }
}

// Handle back actions
const handleBackAction = () => {
  if (isPasswordUpdated.value) {
    emits('backToLogin')
  } else {
    emits('backToEmail')
  }
}

// Send initial verification code and start resend cooldown on mount
onMounted(async () => {
  // Start cooldown timer
  startResendCooldown()
})

// Cleanup timer on unmount
onUnmounted(() => {
  if (resendTimer) {
    clearInterval(resendTimer)
    resendTimer = null
  }
})

// Expose methods for parent component
defineExpose({
  clearForm
})
</script>



================================================
FILE: frontend/src/components/settings/AccountSettings.vue
================================================
<template>
    <div class="pt-4 flex justify-between items-center self-stretch gap-[12px]">
        <div class="flex items-center gap-4 flex-auto overflow-y-visible min-w-0">
            <div
                class="relative flex items-center justify-center font-bold cursor-pointer flex-shrink-0 flex-shrink-0 flex-grow-0">
                <div class="relative flex items-center justify-center font-bold flex-shrink-0 rounded-full overflow-hidden"
                    style="width: 64px; height: 64px; font-size: 32px; color: rgba(255, 255, 255, 0.9); background-color: rgb(59, 130, 246);">
                    {{ avatarLetter }}</div>
            </div>
            <div class="flex flex-col content-center items-start flex-auto overflow-hidden">
                <div class="flex items-center gap-1 w-full"><span
                        class="text-[var(--text-primary)] text-[20px] font-semibold leading-[26px] truncate">{{ currentUser?.fullname || t('Unknown User') }}</span></div>
                <div
                    class="text-[14px] font-normal leading-[22px] text-[var(--text-tertiary)] whitespace-nowrap overflow-hidden text-ellipsis">
                    {{ currentUser?.email || t('No email') }}</div>
            </div>
        </div>
        <div class="self-start md:self-center flex gap-2">
            <div
                class="flex items-center justify-center cursor-pointer bg-[var(--Button-primary-white)] shadow-[0px_0.5px_3px_0px_var(--shadow-S)] hover:opacity-80 active:opacity-70 transition-opacity size-9 rounded-[10px]"
                @click="handleProfileClick">
                <UserCog class="size-4 md:size-5 text-[var(--icon-secondary)]" />
            </div>
            <div v-if="authProvider !== 'none'"
                class="flex items-center justify-center cursor-pointer bg-[var(--Button-primary-white)] shadow-[0px_0.5px_3px_0px_var(--shadow-S)] hover:opacity-80 active:opacity-70 transition-opacity size-9 rounded-[10px]"
                @click="handleLogout">
                <LogOut class="size-4 md:size-5 text-[var(--function-error)]" />
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { computed, onMounted, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useI18n } from 'vue-i18n';
import { UserCog, LogOut } from 'lucide-vue-next';
import { useAuth } from '../../composables/useAuth';
import { getCachedAuthProvider } from '../../api/auth';

const router = useRouter();
const { t } = useI18n();
const { currentUser, logout } = useAuth();
const authProvider = ref<string | null>(null);

// Emit events for parent components
const emit = defineEmits<{
  navigateToProfile: []
}>();

// Get first letter of user's fullname for avatar display
const avatarLetter = computed(() => {
  return currentUser.value?.fullname?.charAt(0)?.toUpperCase() || 'M';
});

// Handle profile icon click
const handleProfileClick = () => {
  emit('navigateToProfile');
};

// Handle logout action
const handleLogout = async () => {
  try {
    await logout();
    router.push('/login');
  } catch (error) {
    console.error('Logout failed:', error);
  }
};

onMounted(async () => {
   authProvider.value = await getCachedAuthProvider();
});
</script>



================================================
FILE: frontend/src/components/settings/ChangePasswordDialog.vue
================================================
<template>
    <Dialog v-model:open="open">
        <DialogContent class="bg-[var(--background-menu-white)] w-[480px]">
            <DialogHeader>
                <DialogTitle>
                    {{ t('Update Password') }}
                </DialogTitle>
            </DialogHeader>
            <div class="pt-[12px] px-[24px] pb-[24px]">
                <form class="flex flex-col items-stretch gap-[4px]">
                    <label class="flex flex-col gap-[8px]">
                        <div class="text-[16px] text-[var(--text-secondary)] leading-[24px]">{{ t('Current Password') }}</div>
                        <div class="relative w-full">
                            <input
                                v-model="currentPassword"
                                class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] min-h-[48px] bg-[var(--fill-tsp-white-dark)] pr-[48px]"
                                :placeholder="t('Enter current password')" 
                                :type="showCurrentPassword ? 'text' : 'password'">
                            <div
                                @click="toggleCurrentPasswordVisibility"
                                class="text-[var(--icon-tertiary)] absolute z-30 top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all right-[10px]">
                                <!-- Eye closed icon (password is hidden) -->
                                <svg v-if="!showCurrentPassword" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd"
                                        d="M2.29331 2.29289C2.68383 1.90237 3.317 1.90237 3.70752 2.29289L7.34625 5.93162C7.40455 5.97793 7.45837 6.03139 7.50637 6.09174L17.8974 16.4828C17.9652 16.5347 18.0272 16.5962 18.0813 16.6667L21.7075 20.2929C22.098 20.6834 22.098 21.3166 21.7075 21.7071C21.317 22.0976 20.6838 22.0976 20.2933 21.7071L17.1396 18.5534C15.6947 19.3988 13.972 20 12.0004 20C9.13874 20 6.80576 18.7353 5.07716 17.2926C3.35091 15.8518 2.16738 14.1857 1.57463 13.2472C1.5668 13.2348 1.55876 13.2221 1.55055 13.2092C1.43291 13.024 1.28018 12.7836 1.20298 12.4467C1.14065 12.1748 1.14067 11.825 1.20303 11.553C1.28028 11.2161 1.43344 10.9751 1.55139 10.7895C1.55967 10.7765 1.56777 10.7637 1.57567 10.7512C2.17804 9.79766 3.40132 8.07525 5.19576 6.60955L2.29331 3.70711C1.90278 3.31658 1.90278 2.68342 2.29331 2.29289ZM6.61828 8.03208C4.97911 9.32619 3.83406 10.921 3.26654 11.8194C3.23105 11.8755 3.20617 11.915 3.18537 11.9492C3.17149 11.9721 3.16235 11.9878 3.15625 11.9988C3.15625 11.9992 3.15625 11.9996 3.15625 12C3.15625 12.0004 3.15625 12.0008 3.15625 12.0012C3.16227 12.012 3.17127 12.0276 3.1849 12.05C3.20556 12.084 3.23029 12.1232 3.26563 12.1792C3.7983 13.0226 4.8524 14.4999 6.35869 15.7571C7.86263 17.0123 9.75708 18 12.0004 18C13.3533 18 14.5778 17.6414 15.6674 17.0812L14.0322 15.446C13.4368 15.7977 12.7418 16 12.0004 16C9.79128 16 8.00042 14.2091 8.00042 12C8.00042 11.2586 8.20271 10.5636 8.55438 9.96818L6.61828 8.03208ZM10.068 11.4818C10.0239 11.647 10.0004 11.8207 10.0004 12C10.0004 13.1046 10.8958 14 12.0004 14C12.1798 14 12.3534 13.9765 12.5186 13.9324L10.068 11.4818ZM12.0004 6C11.6186 6 11.2482 6.02849 10.8892 6.08156C10.3429 6.16234 9.83448 5.78492 9.7537 5.23858C9.67292 4.69223 10.0503 4.18385 10.5967 4.10307C11.0505 4.03597 11.5187 4 12.0004 4C14.8621 4 17.1951 5.26472 18.9237 6.70743C20.6499 8.14818 21.8335 9.81429 22.4262 10.7528C22.434 10.7652 22.4421 10.7779 22.4503 10.7908C22.5679 10.976 22.7207 11.2164 22.7979 11.5533C22.8602 11.8253 22.8602 12.1751 22.7978 12.4471C22.7205 12.7841 22.5671 13.0254 22.449 13.2113C22.4407 13.2243 22.4325 13.2371 22.4246 13.2497C22.1063 13.7536 21.6232 14.4581 20.9832 15.2224C20.6287 15.6459 19.998 15.7017 19.5745 15.3472C19.1511 14.9926 19.0952 14.3619 19.4498 13.9385C20.0211 13.2561 20.4524 12.6267 20.7338 12.1814C20.7694 12.1251 20.7943 12.0855 20.8152 12.0512C20.8292 12.0281 20.8384 12.0122 20.8446 12.0012C20.8446 12.0008 20.8446 12.0004 20.8446 12C20.8446 11.9996 20.8446 11.9992 20.8446 11.9988C20.8386 11.988 20.8296 11.9725 20.8159 11.95C20.7953 11.916 20.7705 11.8768 20.7352 11.8208C20.2025 10.9774 19.1484 9.50007 17.6421 8.24291C16.1382 6.9877 14.2437 6 12.0004 6Z"
                                        fill="currentColor"></path>
                                </svg>
                                <!-- Eye open icon (password is visible) -->
                                <svg v-else width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 4C7 4 2.73 7.11 1 12c1.73 4.89 6 8 11 8s9.27-3.11 11-8c-1.73-4.89-6-8-11-8zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" fill="currentColor"/>
                                </svg>
                            </div>
                        </div>
                        <div class="text-[13px] text-[var(--function-error)] leading-[18px] mt-[-2px] min-h-[18px]"></div>
                    </label>
                    <label class="flex flex-col gap-[8px]">
                        <div class="text-[16px] text-[var(--text-secondary)] leading-[24px]">{{ t('New Password') }}</div>
                        <div class="relative w-full">
                            <input
                                v-model="newPassword"
                                class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] min-h-[48px] bg-[var(--fill-tsp-white-dark)] pr-[48px]"
                                :placeholder="t('Enter new password')" 
                                :type="showNewPassword ? 'text' : 'password'">
                            <div
                                @click="toggleNewPasswordVisibility"
                                class="text-[var(--icon-tertiary)] absolute z-30 top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all right-[10px]">
                                <!-- Eye closed icon (password is hidden) -->
                                <svg v-if="!showNewPassword" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd"
                                        d="M2.29331 2.29289C2.68383 1.90237 3.317 1.90237 3.70752 2.29289L7.34625 5.93162C7.40455 5.97793 7.45837 6.03139 7.50637 6.09174L17.8974 16.4828C17.9652 16.5347 18.0272 16.5962 18.0813 16.6667L21.7075 20.2929C22.098 20.6834 22.098 21.3166 21.7075 21.7071C21.317 22.0976 20.6838 22.0976 20.2933 21.7071L17.1396 18.5534C15.6947 19.3988 13.972 20 12.0004 20C9.13874 20 6.80576 18.7353 5.07716 17.2926C3.35091 15.8518 2.16738 14.1857 1.57463 13.2472C1.5668 13.2348 1.55876 13.2221 1.55055 13.2092C1.43291 13.024 1.28018 12.7836 1.20298 12.4467C1.14065 12.1748 1.14067 11.825 1.20303 11.553C1.28028 11.2161 1.43344 10.9751 1.55139 10.7895C1.55967 10.7765 1.56777 10.7637 1.57567 10.7512C2.17804 9.79766 3.40132 8.07525 5.19576 6.60955L2.29331 3.70711C1.90278 3.31658 1.90278 2.68342 2.29331 2.29289ZM6.61828 8.03208C4.97911 9.32619 3.83406 10.921 3.26654 11.8194C3.23105 11.8755 3.20617 11.915 3.18537 11.9492C3.17149 11.9721 3.16235 11.9878 3.15625 11.9988C3.15625 11.9992 3.15625 11.9996 3.15625 12C3.15625 12.0004 3.15625 12.0008 3.15625 12.0012C3.16227 12.012 3.17127 12.0276 3.1849 12.05C3.20556 12.084 3.23029 12.1232 3.26563 12.1792C3.7983 13.0226 4.8524 14.4999 6.35869 15.7571C7.86263 17.0123 9.75708 18 12.0004 18C13.3533 18 14.5778 17.6414 15.6674 17.0812L14.0322 15.446C13.4368 15.7977 12.7418 16 12.0004 16C9.79128 16 8.00042 14.2091 8.00042 12C8.00042 11.2586 8.20271 10.5636 8.55438 9.96818L6.61828 8.03208ZM10.068 11.4818C10.0239 11.647 10.0004 11.8207 10.0004 12C10.0004 13.1046 10.8958 14 12.0004 14C12.1798 14 12.3534 13.9765 12.5186 13.9324L10.068 11.4818ZM12.0004 6C11.6186 6 11.2482 6.02849 10.8892 6.08156C10.3429 6.16234 9.83448 5.78492 9.7537 5.23858C9.67292 4.69223 10.0503 4.18385 10.5967 4.10307C11.0505 4.03597 11.5187 4 12.0004 4C14.8621 4 17.1951 5.26472 18.9237 6.70743C20.6499 8.14818 21.8335 9.81429 22.4262 10.7528C22.434 10.7652 22.4421 10.7779 22.4503 10.7908C22.5679 10.976 22.7207 11.2164 22.7979 11.5533C22.8602 11.8253 22.8602 12.1751 22.7978 12.4471C22.7205 12.7841 22.5671 13.0254 22.449 13.2113C22.4407 13.2243 22.4325 13.2371 22.4246 13.2497C22.1063 13.7536 21.6232 14.4581 20.9832 15.2224C20.6287 15.6459 19.998 15.7017 19.5745 15.3472C19.1511 14.9926 19.0952 14.3619 19.4498 13.9385C20.0211 13.2561 20.4524 12.6267 20.7338 12.1814C20.7694 12.1251 20.7943 12.0855 20.8152 12.0512C20.8292 12.0281 20.8384 12.0122 20.8446 12.0012C20.8446 12.0008 20.8446 12.0004 20.8446 12C20.8446 11.9996 20.8446 11.9992 20.8446 11.9988C20.8386 11.988 20.8296 11.9725 20.8159 11.95C20.7953 11.916 20.7705 11.8768 20.7352 11.8208C20.2025 10.9774 19.1484 9.50007 17.6421 8.24291C16.1382 6.9877 14.2437 6 12.0004 6Z"
                                        fill="currentColor"></path>
                                </svg>
                                <!-- Eye open icon (password is visible) -->
                                <svg v-else width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 4C7 4 2.73 7.11 1 12c1.73 4.89 6 8 11 8s9.27-3.11 11-8c-1.73-4.89-6-8-11-8zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" fill="currentColor"/>
                                </svg>
                            </div>
                        </div>
                        <div class="text-[13px] text-[var(--function-error)] leading-[18px] mt-[-2px] min-h-[18px]"></div>
                    </label>
                    <label class="flex flex-col gap-[8px]">
                        <div class="text-[16px] text-[var(--text-secondary)] leading-[24px]">{{ t('Confirm New Password') }}</div>
                        <div class="relative w-full">
                            <input
                                v-model="confirmPassword"
                                class="rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] h-10 w-full disabled:cursor-not-allowed placeholder:text-[var(--text-disable)] pt-1 pb-1 pl-3 focus:ring-[1.5px] focus:ring-[var(--border-dark)] min-h-[48px] bg-[var(--fill-tsp-white-dark)] pr-[48px]"
                                :placeholder="t('Enter new password again')" 
                                :type="showConfirmPassword ? 'text' : 'password'">
                            <div
                                @click="toggleConfirmPasswordVisibility"
                                class="text-[var(--icon-tertiary)] absolute z-30 top-[50%] p-[6px] rounded-md transform -translate-y-1/2 cursor-pointer hover:text-[--icon-primary] active:opacity-90 transition-all right-[10px]">
                                <!-- Eye closed icon (password is hidden) -->
                                <svg v-if="!showConfirmPassword" width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" clip-rule="evenodd"
                                        d="M2.29331 2.29289C2.68383 1.90237 3.317 1.90237 3.70752 2.29289L7.34625 5.93162C7.40455 5.97793 7.45837 6.03139 7.50637 6.09174L17.8974 16.4828C17.9652 16.5347 18.0272 16.5962 18.0813 16.6667L21.7075 20.2929C22.098 20.6834 22.098 21.3166 21.7075 21.7071C21.317 22.0976 20.6838 22.0976 20.2933 21.7071L17.1396 18.5534C15.6947 19.3988 13.972 20 12.0004 20C9.13874 20 6.80576 18.7353 5.07716 17.2926C3.35091 15.8518 2.16738 14.1857 1.57463 13.2472C1.5668 13.2348 1.55876 13.2221 1.55055 13.2092C1.43291 13.024 1.28018 12.7836 1.20298 12.4467C1.14065 12.1748 1.14067 11.825 1.20303 11.553C1.28028 11.2161 1.43344 10.9751 1.55139 10.7895C1.55967 10.7765 1.56777 10.7637 1.57567 10.7512C2.17804 9.79766 3.40132 8.07525 5.19576 6.60955L2.29331 3.70711C1.90278 3.31658 1.90278 2.68342 2.29331 2.29289ZM6.61828 8.03208C4.97911 9.32619 3.83406 10.921 3.26654 11.8194C3.23105 11.8755 3.20617 11.915 3.18537 11.9492C3.17149 11.9721 3.16235 11.9878 3.15625 11.9988C3.15625 11.9992 3.15625 11.9996 3.15625 12C3.15625 12.0004 3.15625 12.0008 3.15625 12.0012C3.16227 12.012 3.17127 12.0276 3.1849 12.05C3.20556 12.084 3.23029 12.1232 3.26563 12.1792C3.7983 13.0226 4.8524 14.4999 6.35869 15.7571C7.86263 17.0123 9.75708 18 12.0004 18C13.3533 18 14.5778 17.6414 15.6674 17.0812L14.0322 15.446C13.4368 15.7977 12.7418 16 12.0004 16C9.79128 16 8.00042 14.2091 8.00042 12C8.00042 11.2586 8.20271 10.5636 8.55438 9.96818L6.61828 8.03208ZM10.068 11.4818C10.0239 11.647 10.0004 11.8207 10.0004 12C10.0004 13.1046 10.8958 14 12.0004 14C12.1798 14 12.3534 13.9765 12.5186 13.9324L10.068 11.4818ZM12.0004 6C11.6186 6 11.2482 6.02849 10.8892 6.08156C10.3429 6.16234 9.83448 5.78492 9.7537 5.23858C9.67292 4.69223 10.0503 4.18385 10.5967 4.10307C11.0505 4.03597 11.5187 4 12.0004 4C14.8621 4 17.1951 5.26472 18.9237 6.70743C20.6499 8.14818 21.8335 9.81429 22.4262 10.7528C22.434 10.7652 22.4421 10.7779 22.4503 10.7908C22.5679 10.976 22.7207 11.2164 22.7979 11.5533C22.8602 11.8253 22.8602 12.1751 22.7978 12.4471C22.7205 12.7841 22.5671 13.0254 22.449 13.2113C22.4407 13.2243 22.4325 13.2371 22.4246 13.2497C22.1063 13.7536 21.6232 14.4581 20.9832 15.2224C20.6287 15.6459 19.998 15.7017 19.5745 15.3472C19.1511 14.9926 19.0952 14.3619 19.4498 13.9385C20.0211 13.2561 20.4524 12.6267 20.7338 12.1814C20.7694 12.1251 20.7943 12.0855 20.8152 12.0512C20.8292 12.0281 20.8384 12.0122 20.8446 12.0012C20.8446 12.0008 20.8446 12.0004 20.8446 12C20.8446 11.9996 20.8446 11.9992 20.8446 11.9988C20.8386 11.988 20.8296 11.9725 20.8159 11.95C20.7953 11.916 20.7705 11.8768 20.7352 11.8208C20.2025 10.9774 19.1484 9.50007 17.6421 8.24291C16.1382 6.9877 14.2437 6 12.0004 6Z"
                                        fill="currentColor"></path>
                                </svg>
                                <!-- Eye open icon (password is visible) -->
                                <svg v-else width="20" height="20" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 4C7 4 2.73 7.11 1 12c1.73 4.89 6 8 11 8s9.27-3.11 11-8c-1.73-4.89-6-8-11-8zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" fill="currentColor"/>
                                </svg>
                            </div>
                        </div>
                        <div class="text-[13px] text-[var(--function-error)] leading-[18px] mt-[-2px] min-h-[18px]" v-if="confirmPassword && newPassword !== confirmPassword">
                            {{ t('Passwords do not match') }}
                        </div>
                        <div class="text-[13px] text-[var(--function-error)] leading-[18px] mt-[-2px] min-h-[18px]" v-else></div>
                    </label>
                </form>
            <DialogFooter>
                <DialogClose as-child>
                    <button
                        class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors hover:opacity-90 active:opacity-80 bg-[var(--Button-secondary-gray)] text-[var(--text-primary)] h-[36px] px-[12px] rounded-[10px] gap-[6px] text-sm min-w-[100px] min-h-[40px]"
                        type="button">
                        {{ t('Cancel') }}
                    </button>
                </DialogClose>
                <button
                    class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors bg-[var(--Button-primary-black)] text-[var(--text-onblack)] h-[36px] px-[12px] rounded-[10px] gap-[6px] text-sm min-w-[100px] min-h-[40px]"
                    :class="{ 'opacity-50 cursor-not-allowed hover:opacity-50 active:opacity-50': !isFormValid }"
                    :disabled="!isFormValid"
                    @click="handleSubmit"
                    type="button">
                    <div v-if="isLoading" class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    <span v-if="!isLoading">{{ t('Confirm') }}</span>
                    <span v-else>{{ t('Processing...') }}</span>
                </button>
            </DialogFooter>
        </div>
        </DialogContent>
    </Dialog>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogClose
} from '@/components/ui/dialog'
import { changePassword } from '@/api/auth'
import { showSuccessToast, showErrorToast } from '@/utils/toast'

// Use i18n for translations
const { t } = useI18n()

// Dialog state
const open = ref(false)
const isLoading = ref(false)

// Form data
const currentPassword = ref('')
const newPassword = ref('')
const confirmPassword = ref('')

// Password visibility state
const showCurrentPassword = ref(false)
const showNewPassword = ref(false)
const showConfirmPassword = ref(false)

// Form validation
const isFormValid = computed(() => {
  return !isLoading.value &&
         currentPassword.value.trim() !== '' && 
         newPassword.value.trim() !== '' && 
         newPassword.value.length >= 6 &&
         confirmPassword.value.trim() !== '' &&
         newPassword.value === confirmPassword.value
})

// Toggle password visibility
const toggleCurrentPasswordVisibility = () => {
  showCurrentPassword.value = !showCurrentPassword.value
}

const toggleNewPasswordVisibility = () => {
  showNewPassword.value = !showNewPassword.value
}

const toggleConfirmPasswordVisibility = () => {
  showConfirmPassword.value = !showConfirmPassword.value
}



// Reset form when dialog closes
const resetForm = () => {
  currentPassword.value = ''
  newPassword.value = ''
  confirmPassword.value = ''
  showCurrentPassword.value = false
  showNewPassword.value = false
  showConfirmPassword.value = false
  isLoading.value = false
}

// Handle form submission
const handleSubmit = async () => {
  if (!isFormValid.value) {
    return
  }

  isLoading.value = true

  try {
    await changePassword({
      old_password: currentPassword.value,
      new_password: newPassword.value
    })
    
    showSuccessToast(t('Password change successful'))
    resetForm()
    open.value = false
  } catch (error: any) {
    console.error('Change password error:', error)
    
    // Extract error message from response
    let errorMessage = t('Password change failed')
    if (error?.response?.data?.message) {
      errorMessage = error.response.data.message
    } else if (error?.message) {
      errorMessage = error.message
    }
    
    showErrorToast(errorMessage)
  } finally {
    isLoading.value = false
  }
}

// Expose methods to parent component
defineExpose({
  open: () => { 
    resetForm()
    open.value = true 
  },
  close: () => { 
    resetForm()
    open.value = false 
  }
})
</script>


================================================
FILE: frontend/src/components/settings/GeneralSettings.vue
================================================
<template>
  <div
    class="pb-[32px] last:pb-0 border-b border-[var(--border-light)] last-of-type:border-transparent w-full">
    <div class="text-[13px] font-medium text-[var(--text-tertiary)] mb-1 w-full">{{ t('General') }}</div>
    <div class="mb-[24px] last:mb-[0] w-full">
      <div class="text-sm font-medium text-[var(--text-primary)] mb-[12px]">{{ t('Language') }}</div>
      <Select v-model="selectedLanguage" @update:modelValue="onLanguageChange">
        <SelectTrigger class="w-[208px] h-[36px]">
          <SelectValue :placeholder="t('Select language')" />
        </SelectTrigger>
        <SelectContent :side-offset="5">
          <SelectItem
            v-for="option in languageOptions"
            :key="option.value"
            :value="option.value"
          >
            {{ option.label }}
          </SelectItem>
        </SelectContent>
      </Select>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { useI18n } from 'vue-i18n'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import type { SelectOption } from '@/types/select'
import { useLocale } from '@/composables/useI18n'
import type { Locale } from '@/locales'

// Use i18n for translations
const { t } = useI18n()

// Use the project's i18n composable
const { currentLocale, setLocale } = useLocale()

// Language selection
const selectedLanguage = ref<Locale>(currentLocale.value)

const languageOptions: SelectOption[] = [
  { value: 'zh', label: t('Simplified Chinese') },
  { value: 'en', label: t('English') },
]

const onLanguageChange = (value: any) => {
  if (value && typeof value === 'string') {
    const locale = value as Locale
    setLocale(locale)
    console.log('Language changed to:', locale)
  }
}
</script>



================================================
FILE: frontend/src/components/settings/ProfileSettings.vue
================================================
<template>
    <div class="flex flex-col items-start self-stretch flex-1 overflow-hidden">
        <div class="flex flex-col items-center relative w-full max-sm:px-4 max-sm:pb-4 px-4 pt-4 pb-4 md:px-6 md:pt-4">
            <div class="flex items-center gap-6 w-full p5-4 pb-8">
                <div
                    class="flex-shrink-0 rounded-full overflow-hidden border border-[var(--border-main)]">
                    <div class="relative flex items-center justify-center font-bold flex-shrink-0"
                        style="width: 80px; height: 80px; font-size: 40px; color: rgba(255, 255, 255, 0.9); background-color: rgb(59, 130, 246);">
                        {{ avatarLetter }}</div>
                </div>
                <div class="flex flex-col gap-[6px]"><span
                        class="text-[var(--text-secondary)] text-sm leading-[22px]">{{ t('Name') }}</span>
                    <div
                        class="group rounded-[10px] overflow-hidden text-sm leading-[22px] text-[var(--text-primary)] placeholder:text-[var(--text-disable)] h-10 flex items-center gap-[10px] bg-[var(--fill-tsp-white-main)] pt-2 pr-3 pb-2 pl-4 focus-within:ring-[1.5px] focus-within:ring-[var(--border-dark)] w-full sm:w-[300px]">
                        <input 
                            maxlength="20"
                            class="h-full min-w-1 flex-1 bg-transparent disabled:cursor-not-allowed placeholder:text-[var(--text-disable)]"
                            v-model="localFullname"
                            @blur="handleFullnameSubmit"
                            @keyup.enter="handleFullnameSubmit"
                            :placeholder="t('Unknown User')" />
                        <ClearIcon 
                            :size="16" 
                            class="cursor-pointer opacity-0 hover:opacity-90 group-hover:opacity-100 group-focus-within:opacity-100" 
                            @click="clearFullname"
                        />
                    </div>
                </div>
            </div>
            <div class="w-full flex flex-col">
                <div class="w-full py-3 border-b border-[var(--border-light)]">
                    <div class="flex items-center justify-between gap-3 max-sm:flex-col max-sm:items-stretch">
                        <div class="flex flex-col gap-1">
                            <div class="flex items-center justify-start gap-[6px] text-[var(--text-primary)]"><span
                                    class="text-[var(--text-primary)] text-sm leading-[22px]">{{ t('Email') }}</span></div>
                            <div class="text-[var(--text-tertiary)] text-xs">{{ currentUser?.email || t('No email') }}</div>
                        </div>
                    </div>
                </div>
                <div class="w-full py-3 border-b border-[var(--border-light)]">
                    <div class="flex items-center justify-between gap-3 max-sm:flex-col max-sm:items-stretch">
                        <div class="flex flex-col gap-1">
                            <div class="flex items-center justify-start gap-[6px] text-[var(--text-primary)]"><span
                                    class="text-[var(--text-primary)] text-sm leading-[22px]">{{ t('Password') }}</span></div>
                            <div class="text-[var(--text-tertiary)] text-xs">
                                <div class="inline-flex items-center gap-[4px]"><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span><span
                                        class="rounded-[50%] w-[8px] h-[8px] bg-[var(--icon-tertiary)]"></span></div>
                            </div>
                        </div>
                        <div class="flex gap-[6px] max-sm:justify-end"><button
                                class="inline-flex items-center justify-center whitespace-nowrap font-medium transition-colors hover:opacity-90 active:opacity-80 px-[12px] rounded-[10px] gap-[6px] text-sm min-w-16 outline outline-1 -outline-offset-1 hover:bg-[var(--fill-tsp-white-light)] text-[var(--text-primary)] outline-[var(--border-btn-main)] bg-transparent h-[32px] focus:outline focus:outline-1 focus:-outline-offset-1 focus:outline-[var(--border-btn-main)]"
                                @click="openChangePasswordDialog">{{ t('Update Password') }}</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Change Password Dialog -->
    <ChangePasswordDialog ref="changePasswordDialogRef" />
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { useAuth } from '../../composables/useAuth';
import { changeFullname } from '../../api/auth';
import { showSuccessToast, showErrorToast } from '../../utils/toast';
import ClearIcon from '../icons/ClearIcon.vue';
import ChangePasswordDialog from './ChangePasswordDialog.vue';

const { t } = useI18n();
const { currentUser, loadCurrentUser } = useAuth();

// Dialog refs
const changePasswordDialogRef = ref<InstanceType<typeof ChangePasswordDialog>>();

// Local fullname state
const localFullname = ref(currentUser.value?.fullname || '');

// Watch for currentUser changes to sync localFullname
watch(currentUser, (newUser) => {
  if (newUser) {
    localFullname.value = newUser.fullname || '';
  }
}, { immediate: true });



// Update fullname function
const updateFullname = async (newFullname: string) => {
  // Skip if empty or same as current
  if (!newFullname.trim() || newFullname === currentUser.value?.fullname) {
    return;
  }

  try {
    await changeFullname({ fullname: newFullname.trim() });
    // Refresh current user data to get updated info
    await loadCurrentUser();
    showSuccessToast(t('Full name updated successfully'));
  } catch (error: any) {
    console.error('Failed to update fullname:', error);
    // Reset local state to original value
    localFullname.value = currentUser.value?.fullname || '';
    
    // Show error message
    const errorMessage = error?.response?.data?.message || error?.message || t('Failed to update full name');
    showErrorToast(errorMessage);
  }
};

// Handle input change on blur or Enter
const handleFullnameSubmit = () => {
  updateFullname(localFullname.value);
};

// Clear fullname input
const clearFullname = () => {
  localFullname.value = '';
};

// Get first letter of user's fullname for avatar display
const avatarLetter = computed(() => {
  return currentUser.value?.fullname?.charAt(0)?.toUpperCase() || 'M';
});

// Open change password dialog
const openChangePasswordDialog = () => {
  changePasswordDialogRef.value?.open();
};
</script>



================================================
FILE: frontend/src/components/settings/SettingsDialog.vue
================================================
<template>
  <Dialog v-model:open="isSettingsDialogOpen">
    <DialogContent class="w-[380px] md:w-[95vw] md:max-w-[920px]">
      <DialogTitle></DialogTitle>
      <DialogDescription></DialogDescription>
      
      <SettingsTabs 
        :tabs="tabs" 
        :default-tab="defaultTab"
        :current-sub-page="currentSubPage"
        :sub-page-configs="subPageConfigs"
        @tab-change="onTabChange"
        @navigate-to-profile="navigateToProfile"
        @back="goBack">
        
        <template #account>
          <AccountSettings @navigate-to-profile="navigateToProfile" />
        </template>
        
        <template #account-profile>
          <ProfileSettings @back="goBack" />
        </template>
        
        <template #settings>
          <GeneralSettings />
        </template>
        
      </SettingsTabs>
      
    </DialogContent>
  </Dialog>
</template>

<script setup lang="ts">
import { ref } from 'vue'
import { UserRound, Settings2 } from 'lucide-vue-next'
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog'
import { useSettingsDialog } from '@/composables/useSettingsDialog'
import SettingsTabs from './SettingsTabs.vue'
import AccountSettings from './AccountSettings.vue'
import GeneralSettings from './GeneralSettings.vue'
import ProfileSettings from './ProfileSettings.vue'
import type { TabItem, SubPageConfig } from './SettingsTabs.vue'

// Use global settings dialog state
const { isSettingsDialogOpen, defaultTab } = useSettingsDialog()

// Navigation state for sub-pages
const currentSubPage = ref<string | null>(null)

// Tab configuration
const tabs: TabItem[] = [
  {
    id: 'account',
    label: 'Account',
    icon: UserRound
  },
  {
    id: 'settings',
    label: 'Settings',
    icon: Settings2
  }
]

// Sub-page configuration
const subPageConfigs: SubPageConfig[] = [
  {
    id: 'profile',
    title: 'Profile',
    parentTabId: 'account'
  }
]

// Handle tab change
const onTabChange = (tabId: string) => {
  console.log('Tab changed to:', tabId)
  // Reset sub-page when changing tabs
  currentSubPage.value = null
}

// Navigate to profile sub-page
const navigateToProfile = () => {
  currentSubPage.value = 'profile'
}

// Go back to main view
const goBack = () => {
  currentSubPage.value = null
}
</script>


================================================
FILE: frontend/src/components/settings/SettingsTabs.vue
================================================
<template>
  <div class="flex flex-col md:flex-row h-[580px] md:h-[672px] max-h-[90vh]">
    <!-- Tab Sidebar -->
    <div
      class="md:w-[221px] overflow-x-auto md:overflow-x-visible border-r border-[var(--border-main)] pb-2 md:pb-0 relative">
      <div class="items-center hidden px-5 pt-5 pb-3 md:flex">
        <div class="flex">
          <Bot :size="30" />
          <ManusLogoTextIcon width="69.47368421052632" height="30" />
        </div>
      </div>
      <h3
        class="block md:hidden self-stretch pt-4 md:pt-5 px-4 md:px-5 pb-2 text-[18px] font-semibold leading-7 text-[var(--text-primary)] sticky left-0">
        {{ t('Settings') }}
      </h3>
      <div class="relative flex w-full max-md:pe-3">
        <div
          class="flex-1 flex-shrink-0 flex items-start self-stretch px-3 overflow-auto w-max md:w-full pb-0e border-b border-[var(--border-main)] md:border-b-0 md:flex-col md:gap-3 md:px-2 max-md:gap-[10px]">
          <div class="flex md:gap-[2px] gap-[10px] md:flex-col items-start self-stretch">
            <button
              v-for="tab in tabs"
              :key="tab.id"
              @click="setActiveTab(tab.id)"
              :class="[
                'flex px-1 py-2 items-center text-[14px] leading-5 text-[var(--text-primary)] max-md:whitespace-nowrap md:h-8 md:gap-2 md:self-stretch md:px-4 md:rounded-lg hover:bg-[var(--fill-tsp-white-main)]',
                {
                  'md:bg-[var(--fill-tsp-white-main)] font-medium max-md:border-b-[2px] max-md:border-[var(--Button-primray-black)]': activeTab === tab.id
                }
              ]">
              <span class="hidden md:block" :class="activeTab === tab.id ? 'text-[var(--icon-primary)]' : 'text-[var(--icon-secondary)]'">
                <component :is="tab.icon" class="w-4 h-4" />
              </span>
              <span class="truncate">{{ t(tab.label) }}</span>
            </button>
          </div>
          <div class="hidden md:block self-stretch px-2.5">
            <div class="h-[1px] bg-[var(--border-primary)]"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab Content -->
    <div class="flex flex-col items-start self-stretch flex-1 overflow-hidden">
      <div
        class="gap-1 items-center px-6 py-5 hidden md:flex self-stretch border-b border-[var(--border-main)]">
        <!-- Show back button for sub-pages -->
        <ChevronLeft
          v-if="currentSubPage"
          :size="24"
          stroke="var(--icon-tertiary)"
          :stroke-width="2"
          class="clickable hover:opacity-80 cursor-pointer mr-1"
          @click="handleBack" />
        <h3 class="text-[18px] font-semibold leading-7 text-[var(--text-primary)]">
          {{ activeTabTitle }}
        </h3>
      </div>
      <div
        class="flex-1 self-stretch items-start overflow-y-auto flex flex-col gap-[32px] px-4 pt-4 pb-4 md:px-6 md:pt-4">
        <slot :name="currentSlotName" :active-tab="activeTab" />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { Bot, ChevronLeft } from 'lucide-vue-next'
import ManusLogoTextIcon from '@/components/icons/ManusLogoTextIcon.vue'

export interface TabItem {
  id: string
  label: string
  icon: any
}

export interface SubPageConfig {
  id: string
  title: string
  parentTabId?: string
}

interface Props {
  tabs: TabItem[]
  defaultTab?: string
  currentSubPage?: string | null
  subPageConfigs?: SubPageConfig[]
}

const props = withDefaults(defineProps<Props>(), {
  defaultTab: undefined,
  currentSubPage: null,
  subPageConfigs: () => []
})

const emit = defineEmits<{
  tabChange: [tabId: string]
  navigateToProfile: []
  back: []
}>()

const { t } = useI18n()

// Active tab state
const activeTab = ref<string>(props.defaultTab || props.tabs[0]?.id || '')

// Computed active tab title
const activeTabTitle = computed(() => {
  // Show sub-page title if in sub-page
  if (props.currentSubPage) {
    const subPageConfig = props.subPageConfigs.find(config => config.id === props.currentSubPage)
    if (subPageConfig) {
      return t(subPageConfig.title)
    }
  }
  
  const currentTab = props.tabs.find(tab => tab.id === activeTab.value)
  return currentTab ? t(currentTab.label) : ''
})

// Computed slot name based on current view
const currentSlotName = computed(() => {
  if (props.currentSubPage) {
    const subPageConfig = props.subPageConfigs.find(config => config.id === props.currentSubPage)
    if (subPageConfig && subPageConfig.parentTabId) {
      return `${subPageConfig.parentTabId}-${props.currentSubPage}`
    }
    return props.currentSubPage
  }
  return activeTab.value
})

// Set active tab
const setActiveTab = (tabId: string) => {
  activeTab.value = tabId
  emit('tabChange', tabId)
}

// Handle back button click
const handleBack = () => {
  emit('back')
}

// Expose active tab for parent component
defineExpose({
  activeTab
})
</script>



================================================
FILE: frontend/src/components/toolViews/BrowserToolView.vue
================================================
<template>
  <div
    class="h-[36px] flex items-center px-3 w-full bg-[var(--background-gray-main)] border-b border-[var(--border-main)] rounded-t-[12px] shadow-[inset_0px_1px_0px_0px_#FFFFFF] dark:shadow-[inset_0px_1px_0px_0px_#FFFFFF30]">
    <div class="flex-1 flex items-center justify-center">
      <div class="max-w-[250px] truncate text-[var(--text-tertiary)] text-sm font-medium text-center">
        {{ toolContent?.args?.url || 'Browser' }}
      </div>
    </div>
  </div>
  <div class="flex-1 min-h-0 w-full overflow-y-auto">
    <div class="px-0 py-0 flex flex-col relative h-full">
      <div class="w-full h-full object-cover flex items-center justify-center bg-[var(--fill-white)] relative">
        <div class="w-full h-full">
          <VNCViewer 
            v-if="props.live" 
            :session-id="props.sessionId"
            :enabled="props.live"
            :view-only="true"
            @connected="onVNCConnected"
            @disconnected="onVNCDisconnected"
            @credentials-required="onVNCCredentialsRequired"
          />
          <img v-else alt="Image Preview" class="cursor-pointer w-full" referrerpolicy="no-referrer" :src="imageUrl">
        </div>
        <button
          @click="takeOver"
          class="absolute right-[10px] bottom-[10px] z-10 min-w-10 h-10 flex items-center justify-center rounded-full bg-[var(--background-white-main)] text-[var(--text-primary)] border border-[var(--border-main)] shadow-[0px_5px_16px_0px_var(--shadow-S),0px_0px_1.25px_0px_var(--shadow-S)] backdrop-blur-3xl cursor-pointer hover:bg-[var(--text-brand)] hover:px-4 hover:text-[var(--text-white)] group transition-width duration-300">
          <TakeOverIcon />
          <span
            class="text-sm max-w-0 overflow-hidden whitespace-nowrap opacity-0 transition-all duration-300 group-hover:max-w-[200px] group-hover:opacity-100 group-hover:ml-1 group-hover:text-[var(--text-white)]">{{ t('Take Over') }}</span></button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ToolContent } from '@/types/message';
import { ref, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { getFileDownloadUrl } from '@/api/file';
import VNCViewer from '@/components/VNCViewer.vue';
import TakeOverIcon from '@/components/icons/TakeOverIcon.vue';

const props = defineProps<{
  sessionId: string;
  toolContent: ToolContent;
  live: boolean;
}>();

const { t } = useI18n();
const imageUrl = ref('');

// VNC event handlers
const onVNCConnected = () => {
  console.log('VNC connection successful');
};

const onVNCDisconnected = (reason?: any) => {
  console.log('VNC connection disconnected', reason);
};

const onVNCCredentialsRequired = () => {
  console.log('VNC credentials required');
};



watch(() => props.toolContent?.content?.screenshot, async () => {
  console.log('live', props.live);
  if (!props.toolContent?.content?.screenshot) {
    return;
  }
  imageUrl.value = await getFileDownloadUrl(props.toolContent?.content?.screenshot);
}, { immediate: true });





const takeOver = () => {
  window.dispatchEvent(new CustomEvent('takeover', {
    detail: {
      sessionId: props.sessionId,
      active: true
    }
  }));
};
</script>

<style scoped>
</style>



================================================
FILE: frontend/src/components/toolViews/FileToolView.vue
================================================
<template>
  <div
    class="h-[36px] flex items-center px-3 w-full bg-[var(--background-gray-main)] border-b border-[var(--border-main)] rounded-t-[12px] shadow-[inset_0px_1px_0px_0px_#FFFFFF] dark:shadow-[inset_0px_1px_0px_0px_#FFFFFF30]"
  >
    <div class="flex-1 flex items-center justify-center">
      <div
        class="max-w-[250px] truncate text-[var(--text-tertiary)] text-sm font-medium text-center"
      >
        {{ fileName }}
      </div>
    </div>
  </div>
  <div class="flex-1 min-h-0 w-full overflow-y-auto">
    <div
      dir="ltr"
      data-orientation="horizontal"
      class="flex flex-col min-h-0 h-full relative"
    >
      <div
        data-state="active"
        data-orientation="horizontal"
        role="tabpanel"
        id="radix-:r2ke:-content-/home/ubuntu/llm_papers/todo.md"
        tabindex="0"
        class="focus-visible:outline-none data-[state=inactive]:hidden flex-1 min-h-0 h-full text-sm flex flex-col py-0 outline-none overflow-auto"
      >
        <section
          style="
            display: flex;
            position: relative;
            text-align: initial;
            width: 100%;
            height: 100%;
          "
        >
          <MonacoEditor
            :value="fileContent"
            :filename="fileName"
            :read-only="true"
            theme="vs"
            :line-numbers="'off'"
            :word-wrap="'on'"
            :minimap="false"
            :scroll-beyond-last-line="false"
            :automatic-layout="true"
          />
        </section>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted, ref, computed, watch, onUnmounted } from "vue";
import { ToolContent } from "@/types/message";
import { viewFile } from "@/api/agent";
import MonacoEditor from "@/components/ui/MonacoEditor.vue";
//import { showErrorToast } from "../utils/toast";
//import { useI18n } from "vue-i18n";

//const { t } = useI18n();

const props = defineProps<{
  sessionId: string;
  toolContent: ToolContent;
  live: boolean;
}>();

defineExpose({
  loadContent: () => {
    loadFileContent();
  },
});

const fileContent = ref("");
const refreshTimer = ref<NodeJS.Timeout | null>(null);

const filePath = computed(() => {
  if (props.toolContent && props.toolContent.args.file) {
    return props.toolContent.args.file;
  }
  return "";
});

const fileName = computed(() => {
  if (filePath.value) {
    return filePath.value.split("/").pop() || "";
  }
  return "";
});

// Load file content
const loadFileContent = async () => {
  if (!props.live) {
    fileContent.value = props.toolContent.content?.content || "";
    return;
  }
  
  if (!filePath.value) return;
  
  try {
    const response = await viewFile(props.sessionId, filePath.value);
    fileContent.value = response.content;
  } catch (error) {
    console.error("Failed to load file content:", error);
  }
};

// Start auto-refresh timer
const startAutoRefresh = () => {
  if (refreshTimer.value) {
    clearInterval(refreshTimer.value);
  }
  
  if (props.live && filePath.value) {
    refreshTimer.value = setInterval(() => {
      loadFileContent();
    }, 5000);
  }
};

// Stop auto-refresh timer
const stopAutoRefresh = () => {
  if (refreshTimer.value) {
    clearInterval(refreshTimer.value);
    refreshTimer.value = null;
  }
};

// Watch for filename changes to reload content
watch(filePath, (newVal: string) => {
  if (newVal) {
    loadFileContent();
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
});

watch(() => props.toolContent.timestamp, () => {
  loadFileContent();
});

// Watch for live prop changes
watch(() => props.live, (live: boolean) => {
  if (live) {
    loadFileContent();
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
});

// Load content when component is mounted
onMounted(() => {
  loadFileContent();
  startAutoRefresh();
});

onUnmounted(() => {
  stopAutoRefresh();
});
</script>



================================================
FILE: frontend/src/components/toolViews/McpToolView.vue
================================================
<template>
  <div
    class="h-[36px] flex items-center px-3 w-full bg-[var(--background-gray-main)] border-b border-[var(--border-main)] rounded-t-[12px] shadow-[inset_0px_1px_0px_0px_#FFFFFF] dark:shadow-[inset_0px_1px_0px_0px_#FFFFFF30]">
    <div class="flex-1 flex items-center justify-center">
      <div class="max-w-[250px] truncate text-[var(--text-tertiary)] text-sm font-medium text-center">
        MCP Tool
      </div>
    </div>
  </div>
  <div class="flex-1 min-h-0 w-full overflow-y-auto">
    <div class="flex-1 min-h-0 max-w-[640px] mx-auto">
      <div class="flex flex-col overflow-auto h-full px-4 py-3">
        <div class="py-3 pt-0">
          <div class="text-[var(--text-primary)] text-sm font-medium mb-2">
            {{ t('Tool') }}: {{ toolContent.function }}
          </div>
          
          <div v-if="toolContent.args && Object.keys(toolContent.args).length > 0" class="mb-4">
            <div class="text-[var(--text-primary)] text-sm font-medium mb-2">{{ t('Arguments') }}:</div>
            <pre class="bg-[var(--fill-tsp-gray-main)] rounded-lg p-3 text-xs text-[var(--text-secondary)] overflow-x-auto"><code>{{ JSON.stringify(toolContent.args, null, 2) }}</code></pre>
          </div>
          
          <div v-if="toolContent.content?.result" class="mb-4">
            <div class="text-[var(--text-primary)] text-sm font-medium mb-2">{{ t('Result') }}:</div>
            <div class="bg-[var(--fill-tsp-gray-main)] rounded-lg p-3 text-sm text-[var(--text-secondary)] whitespace-pre-wrap">
              {{ toolContent.content.result }}
            </div>
          </div>
          
          <div v-else class="text-[var(--text-tertiary)] text-sm">
            {{ toolContent.status === 'calling' ? t('Tool is executing...') : t('Waiting for result...') }}
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useI18n } from 'vue-i18n'
import { ToolContent } from '@/types/message';

const { t } = useI18n()

defineProps<{
  sessionId: string;
  toolContent: ToolContent;
  live: boolean;
}>();
</script> 


================================================
FILE: frontend/src/components/toolViews/SearchToolView.vue
================================================
<template>
  <div
    class="h-[36px] flex items-center px-3 w-full bg-[var(--background-gray-main)] border-b border-[var(--border-main)] rounded-t-[12px] shadow-[inset_0px_1px_0px_0px_#FFFFFF] dark:shadow-[inset_0px_1px_0px_0px_#FFFFFF30]">
    <div class="flex-1 flex items-center justify-center">
      <div class="max-w-[250px] truncate text-[var(--text-tertiary)] text-sm font-medium text-center">
      Search
      </div>
    </div>
  </div>
  <div class="flex-1 min-h-0 w-full overflow-y-auto">
    <div class="flex-1 min-h-0 max-w-[640] mx-auto">
      <div class="flex flex-col overflow-auto h-full px-4 py-3">
        <div v-for="result in toolContent.content?.results" class="py-3 pt-0 border-b border-[var(--border-light)]">
          <a :href="result.link" target="_blank"
            class="block text-[var(--text-primary)] text-sm font-medium hover:underline line-clamp-2 cursor-pointer">
            {{ result.title }}
          </a>
          <div class="text-[var(--text-tertiary)] text-xs mt-0.5 line-clamp-3">{{ result.snippet }}</div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ToolContent } from '@/types/message';

defineProps<{
  sessionId: string;
  toolContent: ToolContent;
  live: boolean;
}>();

</script>



================================================
FILE: frontend/src/components/toolViews/ShellToolView.vue
================================================
<template>
  <div
    class="h-[36px] flex items-center px-3 w-full bg-[var(--background-gray-main)] border-b border-[var(--border-main)] rounded-t-[12px] shadow-[inset_0px_1px_0px_0px_#FFFFFF] dark:shadow-[inset_0px_1px_0px_0px_#FFFFFF30]">
    <div class="flex-1 flex items-center justify-center">
      <div class="max-w-[250px] truncate text-[var(--text-tertiary)] text-sm font-medium text-center">{{
        shellSessionId }}
      </div>
    </div>
  </div>
  <div class="flex-1 min-h-0 w-full overflow-y-auto">
    <div dir="ltr" data-orientation="horizontal" class="flex flex-col flex-1 min-h-0">
      <div data-state="active" data-orientation="horizontal" role="tabpanel"
        id="radix-:r5m:-content-setup" tabindex="0"
        class="py-2 focus-visible:outline-none data-[state=inactive]:hidden flex-1 font-mono text-sm leading-relaxed px-3 outline-none overflow-auto whitespace-pre-wrap break-all"
        style="animation-duration: 0s;">
        <code v-html="shell"></code>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { onMounted, ref, computed, watch, onUnmounted } from 'vue';
import { viewShellSession } from '@/api/agent';
import { ToolContent } from '@/types/message';
//import { showErrorToast } from '@/utils/toast';

const props = defineProps<{
  sessionId: string;
  toolContent: ToolContent;
  live: boolean;
}>();

defineExpose({
  loadContent: () => {
    loadShellContent();
  }
});

const shell = ref('');
const refreshTimer = ref<number | null>(null);

// Get shellSessionId from toolContent
const shellSessionId = computed(() => {
  if (props.toolContent && props.toolContent.args.id) {
    return props.toolContent.args.id;
  }
  return '';
});

const updateShellContent = (console: any) => {
  if (!console) return;
  let newShell = '';
  for (const e of console) {
    newShell += `<span style="color: rgb(0, 187, 0);">${e.ps1}</span><span> ${e.command}</span>\n`;
    newShell += `<span>${e.output}</span>\n`;
  }
  if (newShell !== shell.value) {
    shell.value = newShell;
  }
}

// Function to load Shell session content
const loadShellContent = async () => {
  if (!props.live) {
    updateShellContent(props.toolContent.content?.console);
    return;
  }
  
  if (!shellSessionId.value) return;

  try {
    const response = await viewShellSession(props.sessionId, shellSessionId.value);
    updateShellContent(response.console);
  } catch (error) {
    console.error("Failed to load shell content:", error);
  }
};

// Start auto-refresh timer
const startAutoRefresh = () => {
  if (refreshTimer.value) {
    clearInterval(refreshTimer.value);
  }
  
  if (props.live && shellSessionId.value) {
    refreshTimer.value = setInterval(() => {
      loadShellContent();
    }, 5000);
  }
};

// Stop auto-refresh timer
const stopAutoRefresh = () => {
  if (refreshTimer.value) {
    clearInterval(refreshTimer.value);
    refreshTimer.value = null;
  }
};

watch(() => props.toolContent.timestamp, () => {
  loadShellContent();
});

// Watch for live prop changes
watch(() => props.live, (live: boolean) => {
  if (live) {
    loadShellContent();
    startAutoRefresh();
  } else {
    stopAutoRefresh();
  }
});

// Load content and set up refresh timer when component is mounted
onMounted(() => {
  loadShellContent();
  startAutoRefresh();
});

// Clear timer when component is unmounted
onUnmounted(() => {
  stopAutoRefresh();
});
</script>



================================================
FILE: frontend/src/components/ui/ContextMenu.vue
================================================
<template>
    <div id="context-menu-portal" data-floating-ui-portal="">
        <div v-if="contextMenuVisible" ref="menuRef" data-bottom=""
            class="min-w-max inline-block transition-[transform,opacity,scale] duration-150 data-[starting-style]:opacity-0 data-[ending-style]:opacity-0 data-[starting-style]:-translate-y-2 data-[ending-style]:-translate-y-2"
            tabindex="-1" data-floating-ui-focusable="" role="dialog" :style="{
                position: 'absolute',
                left: calculatedPosition.x + 'px',
                top: calculatedPosition.y + 'px',
                '--available-width': '554px',
                '--available-height': '649px',
                '--anchor-width': '22px',
                '--anchor-height': '22px'
            }">
            <div
                class="bg-[var(--background-menu-white)] shadow-[0_4px_11px_0px_var(--shadow-S)] rounded-xl border border-[var(--border-dark)] dark:border-[var(--border-light)] min-w-[126px]">
                <div class="p-1">
                    <div v-for="item in menuItems" :key="item.key" @click="handleMenuItemClick(item)"
                        class="flex items-center gap-3 w-full px-3 py-2 rounded-[8px] hover:bg-[var(--fill-tsp-white-main)] cursor-pointer text-sm"
                        :class="[
                            item.variant === 'danger' ? 'text-[var(--function-error)]' : 'text-[var(--text-primary)]',
                            item.disabled ? 'opacity-50 cursor-not-allowed' : ''
                        ]">
                        <div class="flex-1 flex items-center gap-3">
                            <component v-if="item.icon" :is="item.icon" 
                                class="w-4 h-4" 
                                :stroke="item.variant === 'danger' ? 'var(--function-error)' : 'var(--icon-primary)'"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            {{ item.label }}
                            <svg v-if="item.checked" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
                                fill="none" stroke="var(--icon-primary)" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="lucide lucide-check ml-auto">
                                <path d="M20 6 9 17l-5-5"></path>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed, watch } from 'vue';
import { useContextMenu } from '@/composables/useContextMenu';

const { 
    contextMenuVisible, 
    menuPosition, 
    menuItems, 
    targetElement,
    hideContextMenu, 
    handleMenuItemClick 
} = useContextMenu();

const menuRef = ref<HTMLElement>();

// Calculate menu position based on target element
const calculatedPosition = computed(() => {
    if (!targetElement.value) {
        return menuPosition.value;
    }
    
    const rect = targetElement.value.getBoundingClientRect();
    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
    const scrollTop = window.scrollY || document.documentElement.scrollTop;
    
    // Calculate center position and adjust for menu width
    const centerX = rect.left + scrollLeft + rect.width / 2;
    const menuWidth = menuRef.value?.offsetWidth || 126; // fallback to min-width
    
    return {
        x: centerX - menuWidth / 2,
        y: rect.bottom + scrollTop + 4 // 4px offset below the element
    };
});

// Update menuPosition when target element changes
watch(targetElement, () => {
    if (targetElement.value) {
        menuPosition.value = calculatedPosition.value;
    }
}, { immediate: true });

// Handle click outside to close menu
const handleClickOutside = (event: MouseEvent) => {
    if (contextMenuVisible.value && menuRef.value && !menuRef.value.contains(event.target as Node)) {
        hideContextMenu();
    }
};

onMounted(() => {
    document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
    document.removeEventListener('click', handleClickOutside);
});
</script> 


================================================
FILE: frontend/src/components/ui/CustomDialog.vue
================================================
<template>
    <div v-if="dialogVisible" class="absolute z-[1000] pointer-events-auto">
        <div class="w-full h-full bg-black/60 backdrop-blur-[4px] fixed inset-0 data-[state=open]:animate-dialog-bg-fade-in data-[state=closed]:animate-dialog-bg-fade-out"
            style="position: fixed; overflow: auto; inset: 0px;" @click="handleBackdropClick"></div>
        <div role="dialog"
            class="bg-[var(--background-menu-white)] rounded-[20px] border border-white/5 fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 max-w-[95%] max-h-[95%] overflow-auto data-[state=open]:animate-dialog-slide-in-from-bottom data-[state=closed]:animate-dialog-slide-out-to-bottom w-[440px]">
            <div class="pt-5 pb-[10px] px-5">
                <h3 class="text-[var(--text-primary)] text-[18px] leading-[24px] font-semibold flex items-center">
                    {{ dialogConfig.title }}</h3>
                <div
                    class="flex h-7 w-7 items-center justify-center cursor-pointer hover:bg-[var(--fill-tsp-gray-main)] rounded-md absolute top-[20px] ltr:right-[12px] rtl:left-[12px]"
                    @click="handleCancel"
                    :aria-label="$t('Close Dialog')">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-x h-5 w-5 text-[var(--icon-tertiary)]">
                        <path d="M18 6 6 18"></path>
                        <path d="m6 6 12 12"></path>
                    </svg>
                </div>
            </div>
            <div v-if="dialogConfig.content" class="px-5 py-3 text-[var(--text-tertiary)] text-sm">
                {{ dialogConfig.content }}
            </div>
            <div class="flex justify-end gap-2 p-5">
                <button
                    class="rounded-[10px] px-3 py-2 text-sm border border-[var(--border-btn-main)] bg-[var(--button-secondary)] text-[var(--text-secondary)] hover:bg-[var(--fill-tsp-white-dark)] cursor-pointer transition-colors"
                    @click="handleCancel">{{ dialogConfig.cancelText }}</button>
                <button
                    :class="[
                        'rounded-[10px] px-3 py-2 text-sm flex flex-row gap-1 items-center cursor-pointer transition-colors',
                        dialogConfig.confirmType === 'danger' 
                            ? 'border border-[var(--Button-secondary-error-border)] bg-[var(--Button-secondary-error-fill)] text-[var(--function-error)] enabled:hover:bg-[var(--function-error)] enabled:hover:text-[var(--text-white)]'
                            : 'border border-[var(--border-btn-primary)] bg-[var(--button-primary)] text-[var(--text-white)] hover:bg-[var(--button-primary-hover)]'
                    ]"
                    @click="handleConfirm">{{ dialogConfig.confirmText }}</button>
            </div>
        </div>
    </div>
</template>

<script setup lang="ts">
import { useDialog } from '@/composables/useDialog'

// Use dialog composable directly
const { dialogVisible, dialogConfig, handleConfirm, handleCancel } = useDialog()

// Handle backdrop click
const handleBackdropClick = () => {
    handleCancel()
}
</script>


================================================
FILE: frontend/src/components/ui/MonacoEditor.vue
================================================
<template>
  <div ref="monacoContainer" style="width: 100%; height: 100%"></div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, watch, computed } from "vue";
import * as monaco from "monaco-editor/esm/vs/editor/editor.api";

// Import language contributions
import "monaco-editor/esm/vs/language/json/monaco.contribution";
import "monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution";
import "monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution";
import "monaco-editor/esm/vs/basic-languages/html/html.contribution";
import "monaco-editor/esm/vs/basic-languages/css/css.contribution";
import "monaco-editor/esm/vs/basic-languages/python/python.contribution";
import "monaco-editor/esm/vs/basic-languages/java/java.contribution";
import "monaco-editor/esm/vs/basic-languages/go/go.contribution";
import "monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution";

interface MonacoEditorProps {
  value?: string;
  language?: string;
  filename?: string;
  readOnly?: boolean;
  theme?: string;
  lineNumbers?: 'on' | 'off' | 'relative' | 'interval';
  wordWrap?: 'on' | 'off' | 'wordWrapColumn' | 'bounded';
  minimap?: boolean;
  scrollBeyondLastLine?: boolean;
  automaticLayout?: boolean;
}

const props = withDefaults(defineProps<MonacoEditorProps>(), {
  value: "",
  language: "",
  filename: "",
  readOnly: true,
  theme: "vs",
  lineNumbers: "off",
  wordWrap: "on",
  minimap: false,
  scrollBeyondLastLine: false,
  automaticLayout: true,
});

const emit = defineEmits<{
  ready: [editor: monaco.editor.IStandaloneCodeEditor];
  change: [value: string];
}>();

const monacoContainer = ref<HTMLElement | null>(null);
let editor: monaco.editor.IStandaloneCodeEditor | null = null;

// Language mapping based on filename or explicit language
const languageFromFilename = (filename: string): string => {
  const extension = filename.split(".").pop()?.toLowerCase() || "";
  const languageMap: Record<string, string> = {
    js: "javascript",
    ts: "typescript",
    html: "html",
    css: "css",
    json: "json",
    py: "python",
    java: "java",
    c: "c",
    cpp: "cpp",
    go: "go",
    md: "markdown",
    txt: "plaintext",
    vue: "html",
    jsx: "javascript",
    tsx: "typescript",
  };
  return languageMap[extension] || "plaintext";
};

const computedLanguage = computed(() => {
  if (props.language) {
    return props.language;
  }
  if (props.filename) {
    return languageFromFilename(props.filename);
  }
  return "plaintext";
});

// Initialize Monaco editor
const initEditor = () => {
  if (!monacoContainer.value || editor) {
    return;
  }

  editor = monaco.editor.create(monacoContainer.value, {
    value: props.value,
    language: computedLanguage.value,
    theme: props.theme,
    readOnly: props.readOnly,
    minimap: { enabled: props.minimap },
    scrollBeyondLastLine: props.scrollBeyondLastLine,
    automaticLayout: props.automaticLayout,
    lineNumbers: props.lineNumbers,
    wordWrap: props.wordWrap,
    scrollbar: {
      vertical: "auto",
      horizontal: "auto",
    },
  });

  // Emit ready event
  emit("ready", editor);

  // Listen for content changes
  if (!props.readOnly) {
    editor.onDidChangeModelContent(() => {
      if (editor) {
        emit("change", editor.getValue());
      }
    });
  }
};

// Update editor content
const updateContent = (newValue: string) => {
  if (editor) {
    const model = editor.getModel();
    if (model) {
      model.setValue(newValue);
    } else {
      editor.setValue(newValue);
    }
  }
};

// Update editor language
const updateLanguage = (newLanguage: string) => {
  if (editor) {
    const model = editor.getModel();
    if (model) {
      monaco.editor.setModelLanguage(model, newLanguage);
    }
  }
};

// Expose methods to parent component
defineExpose({
  editor: () => editor,
  updateContent,
  updateLanguage,
  getValue: () => editor?.getValue() || "",
});

// Watch for value changes
watch(() => props.value, (newValue) => {
  if (newValue !== editor?.getValue()) {
    updateContent(newValue);
  }
});

// Watch for language changes
watch(computedLanguage, (newLanguage) => {
  updateLanguage(newLanguage);
});

onMounted(() => {
  initEditor();
});

onBeforeUnmount(() => {
  if (editor) {
    editor.dispose();
    editor = null;
  }
});
</script> 


================================================
FILE: frontend/src/components/ui/Toast.vue
================================================
<template>
  <div role="region" aria-label="Notifications (F8)" tabindex="-1" style="">
    <span 
      aria-hidden="true" 
      tabindex="0"
      style="position: fixed; border: 0px; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; overflow-wrap: normal;"
    ></span>
    <ol 
      tabindex="-1"
      class="fixed top-[28px] left-1/2 -translate-x-1/2 z-[1050] flex max-h-screen flex-col-reverse p-4 max-w-[90%] gap-2.5"
    >
      <li 
        v-for="toast in toasts" 
        :key="toast.id" 
        role="status" 
        aria-live="off" 
        aria-atomic="true" 
        tabindex="0" 
        data-state="open" 
        data-swipe-direction="right"
        class="w-max max-w-full px-4 py-2 flex items-center gap-2.5 flex-shrink-0 bg-[var(--background-white-main)] rounded-xl shadow-[0px_4px_11px_0px_var(--shadow-M)] border border-[var(--border-white)] backdrop-blur-3xl data-[swipe=cancel]:translate-y-0 data-[swipe=end]:translate-y-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-y-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=open]:slide-in-from-top-full"
        data-radix-collection-item="" 
        style="user-select: none; touch-action: none;"
      >
        <div>
          <div v-if="toast.type === 'error'" class="me-2.5 inline-flex relative top-1">
            <ErrorIcon />
          </div>
          <div v-else-if="toast.type === 'info'" class="me-2.5 inline-flex relative top-1">
            <InfoIcon />
          </div>
          <div v-else-if="toast.type === 'success'" class="me-2.5 inline-flex relative top-1">
            <SuccessIcon />
          </div>
          {{ toast.message }}
        </div>
      </li>
    </ol>
    <span 
      aria-hidden="true" 
      tabindex="0"
      style="position: fixed; border: 0px; width: 1px; height: 1px; padding: 0px; margin: -1px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); white-space: nowrap; overflow-wrap: normal;"
    ></span>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import ErrorIcon from '@/components/icons/ErrorIcon.vue';
import InfoIcon from '@/components/icons/InfoIcon.vue';
import SuccessIcon from '@/components/icons/SuccessIcon.vue';

interface Toast {
  id: number;
  message: string;
  type: 'error' | 'info' | 'success';
  duration?: number;
}

const toasts = ref<Toast[]>([]);
let toastCounter = 0;

// Add toast
const addToast = (message: string, type: 'error' | 'info' | 'success' = 'info', duration: number = 3000) => {
  const id = toastCounter++;
  const toast: Toast = { id, message, type, duration };
  toasts.value.push(toast);
  
  // Set automatic removal
  if (duration > 0) {
    setTimeout(() => {
      removeToast(id);
    }, duration);
  }
  
  return id;
};

// Remove toast
const removeToast = (id: number) => {
  const index = toasts.value.findIndex(toast => toast.id === id);
  if (index !== -1) {
    toasts.value.splice(index, 1);
  }
};

// Create custom event bus
const handleToastEvent = (event: CustomEvent) => {
  const { message, type, duration } = event.detail;
  addToast(message, type, duration);
};

// Listen for custom events
onMounted(() => {
  window.addEventListener('toast', handleToastEvent as EventListener);
});

onUnmounted(() => {
  window.removeEventListener('toast', handleToastEvent as EventListener);
});

// Expose methods for external use
defineExpose({
  addToast,
  removeToast
});
</script> 


================================================
FILE: frontend/src/components/ui/dialog/Dialog.vue
================================================
<script setup lang="ts">
import type { DialogRootEmits, DialogRootProps } from "reka-ui"
import { DialogRoot, useForwardPropsEmits } from "reka-ui"

const props = defineProps<DialogRootProps>()
const emits = defineEmits<DialogRootEmits>()

const forwarded = useForwardPropsEmits(props, emits)
</script>

<template>
  <DialogRoot
    data-slot="dialog"
    v-bind="forwarded"
  >
    <slot />
  </DialogRoot>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogClose.vue
================================================
<script setup lang="ts">
import type { DialogCloseProps } from "reka-ui"
import { DialogClose } from "reka-ui"

const props = defineProps<DialogCloseProps>()
</script>

<template>
  <DialogClose
    data-slot="dialog-close"
    v-bind="props"
  >
    <slot />
  </DialogClose>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogContent.vue
================================================
<script setup lang="ts">
import type { DialogContentEmits, DialogContentProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { X } from "lucide-vue-next"
import {
  DialogClose,
  DialogContent,

  DialogPortal,
  useForwardPropsEmits,
} from "reka-ui"
import { cn } from "@/lib/utils"
import DialogOverlay from "./DialogOverlay.vue"

const props = defineProps<DialogContentProps & { class?: HTMLAttributes["class"] }>()
const emits = defineEmits<DialogContentEmits>()

const delegatedProps = reactiveOmit(props, "class")

const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <DialogPortal>
    <DialogOverlay />
    <DialogContent
      data-slot="dialog-content"
      v-bind="forwarded"
      :class="
        cn(
          'data-[state=open]:animate-dialog-slide-in-from-bottom data-[state=closed]:animate-dialog-slide-out-to-bottom fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 max-h-[95%] max-w-[98%] overflow-auto rounded-[20px] border border-[var(--border-main)] bg-[var(--background-gray-main)] p-0 z-[1000]',
          props.class,
        )"
    >
      <slot />

      <DialogClose
        class="flex h-7 w-7 items-center justify-center cursor-pointer rounded-md hover:bg-[var(--fill-tsp-gray-main)] absolute top-[18px] ltr:right-[20px] rtl:left-[20px] !right-3 !md:right-4"
      >
        <X class="size-5 text-[var(--icon-tertiary)]" />
        <span class="sr-only">Close</span>
      </DialogClose>
    </DialogContent>
  </DialogPortal>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogDescription.vue
================================================
<script setup lang="ts">
import type { DialogDescriptionProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { DialogDescription, useForwardProps } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<DialogDescriptionProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")

const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <DialogDescription
    data-slot="dialog-description"
    v-bind="forwardedProps"
    :class="cn('text-muted-foreground text-sm', props.class)"
  >
    <slot />
  </DialogDescription>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogFooter.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from "vue"
import { cn } from "@/lib/utils"

const props = defineProps<{ class?: HTMLAttributes["class"] }>()
</script>

<template>
  <div
    data-slot="dialog-footer"
    :class="cn('mt-[12px] flex justify-end gap-[12px]', props.class)"
  >
    <slot />
  </div>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogHeader.vue
================================================
<script setup lang="ts">
import type { HTMLAttributes } from "vue"
import { cn } from "@/lib/utils"

const props = defineProps<{
  class?: HTMLAttributes["class"]
}>()
</script>

<template>
  <div
    data-slot="dialog-header"
    :class="cn('pt-5 px-[24px] pb-[10px] pe-8', props.class)"
  >
    <slot />
  </div>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogOverlay.vue
================================================
<script setup lang="ts">
import type { DialogOverlayProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { DialogOverlay } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<DialogOverlayProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")
</script>

<template>
  <DialogOverlay
    data-slot="dialog-overlay"
    v-bind="delegatedProps"
    :class="cn('data-[state=open]:animate-dialog-bg-fade-in data-[state=closed]:animate-dialog-bg-fade-out fixed inset-0 z-[1000] bg-black/60 backdrop-blur-[4px] overflow-auto', props.class)"
  >
    <slot />
  </DialogOverlay>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogScrollContent.vue
================================================
<script setup lang="ts">
import type { DialogContentEmits, DialogContentProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { X } from "lucide-vue-next"
import {
  DialogClose,
  DialogContent,

  DialogOverlay,
  DialogPortal,
  useForwardPropsEmits,
} from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<DialogContentProps & { class?: HTMLAttributes["class"] }>()
const emits = defineEmits<DialogContentEmits>()

const delegatedProps = reactiveOmit(props, "class")

const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <DialogPortal>
    <DialogOverlay
      class="fixed inset-0 z-50 grid place-items-center overflow-y-auto bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
    >
      <DialogContent
        :class="
          cn(
            'relative z-50 grid w-full max-w-lg my-8 gap-4 border border-border bg-background p-6 shadow-lg duration-200 sm:rounded-lg md:w-full',
            props.class,
          )
        "
        v-bind="forwarded"
        @pointer-down-outside="(event) => {
          const originalEvent = event.detail.originalEvent;
          const target = originalEvent.target as HTMLElement;
          if (originalEvent.offsetX > target.clientWidth || originalEvent.offsetY > target.clientHeight) {
            event.preventDefault();
          }
        }"
      >
        <slot />

        <DialogClose
          class="absolute top-4 right-4 p-0.5 transition-colors rounded-md hover:bg-secondary"
        >
          <X class="w-4 h-4" />
          <span class="sr-only">Close</span>
        </DialogClose>
      </DialogContent>
    </DialogOverlay>
  </DialogPortal>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogTitle.vue
================================================
<script setup lang="ts">
import type { DialogTitleProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { DialogTitle, useForwardProps } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<DialogTitleProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")

const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <DialogTitle
    data-slot="dialog-title"
    v-bind="forwardedProps"
    :class="cn('text-[var(--text-primary)] text-[18px] leading-[24px] font-semibold', props.class)"
  >
    <slot />
  </DialogTitle>
</template>



================================================
FILE: frontend/src/components/ui/dialog/DialogTrigger.vue
================================================
<script setup lang="ts">
import type { DialogTriggerProps } from "reka-ui"
import { DialogTrigger } from "reka-ui"

const props = defineProps<DialogTriggerProps>()
</script>

<template>
  <DialogTrigger
    data-slot="dialog-trigger"
    v-bind="props"
  >
    <slot />
  </DialogTrigger>
</template>



================================================
FILE: frontend/src/components/ui/dialog/index.ts
================================================
export { default as Dialog } from "./Dialog.vue"
export { default as DialogClose } from "./DialogClose.vue"
export { default as DialogContent } from "./DialogContent.vue"
export { default as DialogDescription } from "./DialogDescription.vue"
export { default as DialogFooter } from "./DialogFooter.vue"
export { default as DialogHeader } from "./DialogHeader.vue"
export { default as DialogOverlay } from "./DialogOverlay.vue"
export { default as DialogScrollContent } from "./DialogScrollContent.vue"
export { default as DialogTitle } from "./DialogTitle.vue"
export { default as DialogTrigger } from "./DialogTrigger.vue"



================================================
FILE: frontend/src/components/ui/select/index.ts
================================================
export { default as Select } from "./Select.vue"
export { default as SelectContent } from "./SelectContent.vue"
export { default as SelectGroup } from "./SelectGroup.vue"
export { default as SelectItem } from "./SelectItem.vue"
export { default as SelectItemText } from "./SelectItemText.vue"
export { default as SelectLabel } from "./SelectLabel.vue"
export { default as SelectScrollDownButton } from "./SelectScrollDownButton.vue"
export { default as SelectScrollUpButton } from "./SelectScrollUpButton.vue"
export { default as SelectSeparator } from "./SelectSeparator.vue"
export { default as SelectTrigger } from "./SelectTrigger.vue"
export { default as SelectValue } from "./SelectValue.vue"



================================================
FILE: frontend/src/components/ui/select/Select.vue
================================================
<script setup lang="ts">
import type { SelectRootEmits, SelectRootProps } from "reka-ui"
import { SelectRoot, useForwardPropsEmits } from "reka-ui"

const props = defineProps<SelectRootProps>()
const emits = defineEmits<SelectRootEmits>()

const forwarded = useForwardPropsEmits(props, emits)
</script>

<template>
  <SelectRoot
    data-slot="select"
    v-bind="forwarded"
  >
    <slot />
  </SelectRoot>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectContent.vue
================================================
<script setup lang="ts">
import type { SelectContentEmits, SelectContentProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import {
  SelectContent,

  SelectPortal,
  SelectViewport,
  useForwardPropsEmits,
} from "reka-ui"
import { cn } from "@/lib/utils"
import { SelectScrollDownButton, SelectScrollUpButton } from "."

defineOptions({
  inheritAttrs: false,
})

const props = withDefaults(
  defineProps<SelectContentProps & { class?: HTMLAttributes["class"] }>(),
  {
    position: "popper",
  },
)
const emits = defineEmits<SelectContentEmits>()

const delegatedProps = reactiveOmit(props, "class")

const forwarded = useForwardPropsEmits(delegatedProps, emits)
</script>

<template>
  <SelectPortal>
    <SelectContent
      data-slot="select-content"
      v-bind="{ ...forwarded, ...$attrs }"
      :class="cn(
        'bg-[var(--background-menu-white)] text-[var(--text-primary)] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-[1100] max-h-60 min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-xl border border-[var(--border-dark)] dark:border-[var(--border-light)] shadow-[0_4px_11px_0px_var(--shadow-S)]',
        position === 'popper'
          && 'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        props.class,
      )
      "
    >
      <SelectScrollUpButton />
      <SelectViewport :class="cn('p-1', position === 'popper' && 'h-[var(--reka-select-trigger-height)] w-full min-w-[var(--reka-select-trigger-width)] scroll-my-1')">
        <slot />
      </SelectViewport>
      <SelectScrollDownButton />
    </SelectContent>
  </SelectPortal>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectGroup.vue
================================================
<script setup lang="ts">
import type { SelectGroupProps } from "reka-ui"
import { SelectGroup } from "reka-ui"

const props = defineProps<SelectGroupProps>()
</script>

<template>
  <SelectGroup
    data-slot="select-group"
    v-bind="props"
  >
    <slot />
  </SelectGroup>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectItem.vue
================================================
<script setup lang="ts">
import type { SelectItemProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { Check } from "lucide-vue-next"
import {
  SelectItem,
  SelectItemIndicator,

  SelectItemText,
  useForwardProps,
} from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<SelectItemProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")

const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <SelectItem
    data-slot="select-item"
    v-bind="forwardedProps"
    :class="
      cn(
        `flex items-center gap-3 w-full px-3 py-2 rounded-[8px] hover:bg-[var(--fill-tsp-white-main)] cursor-pointer text-sm transition-colors text-[var(--text-primary)] data-[highlighted]:bg-[var(--fill-tsp-white-main)] data-[state=checked]:bg-[var(--fill-tsp-white-main)] data-[state=checked]:font-medium outline-none border-none select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2`,
        props.class,
      )
    "
  >
    <span class="absolute right-2 flex size-3.5 items-center justify-center">
      <SelectItemIndicator>
        <Check class="size-4" style="stroke: var(--icon-primary)" />
      </SelectItemIndicator>
    </span>

    <SelectItemText>
      <slot />
    </SelectItemText>
  </SelectItem>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectItemText.vue
================================================
<script setup lang="ts">
import type { SelectItemTextProps } from "reka-ui"
import { SelectItemText } from "reka-ui"

const props = defineProps<SelectItemTextProps>()
</script>

<template>
  <SelectItemText
    data-slot="select-item-text"
    v-bind="props"
  >
    <slot />
  </SelectItemText>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectLabel.vue
================================================
<script setup lang="ts">
import type { SelectLabelProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { SelectLabel } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<SelectLabelProps & { class?: HTMLAttributes["class"] }>()
</script>

<template>
  <SelectLabel
    data-slot="select-label"
    :class="cn('px-2 py-1.5 text-sm font-medium', props.class)"
  >
    <slot />
  </SelectLabel>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectScrollDownButton.vue
================================================
<script setup lang="ts">
import type { SelectScrollDownButtonProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { ChevronDown } from "lucide-vue-next"
import { SelectScrollDownButton, useForwardProps } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<SelectScrollDownButtonProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")

const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <SelectScrollDownButton
    data-slot="select-scroll-down-button"
    v-bind="forwardedProps"
    :class="cn('flex cursor-default items-center justify-center py-1', props.class)"
  >
    <slot>
      <ChevronDown class="size-4" />
    </slot>
  </SelectScrollDownButton>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectScrollUpButton.vue
================================================
<script setup lang="ts">
import type { SelectScrollUpButtonProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { ChevronUp } from "lucide-vue-next"
import { SelectScrollUpButton, useForwardProps } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<SelectScrollUpButtonProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")

const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <SelectScrollUpButton
    data-slot="select-scroll-up-button"
    v-bind="forwardedProps"
    :class="cn('flex cursor-default items-center justify-center py-1', props.class)"
  >
    <slot>
      <ChevronUp class="size-4" />
    </slot>
  </SelectScrollUpButton>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectSeparator.vue
================================================
<script setup lang="ts">
import type { SelectSeparatorProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { SelectSeparator } from "reka-ui"
import { cn } from "@/lib/utils"

const props = defineProps<SelectSeparatorProps & { class?: HTMLAttributes["class"] }>()

const delegatedProps = reactiveOmit(props, "class")
</script>

<template>
  <SelectSeparator
    data-slot="select-separator"
    v-bind="delegatedProps"
    :class="cn('bg-border pointer-events-none -mx-1 my-1 h-px', props.class)"
  />
</template>



================================================
FILE: frontend/src/components/ui/select/SelectTrigger.vue
================================================
<script setup lang="ts">
import type { SelectTriggerProps } from "reka-ui"
import type { HTMLAttributes } from "vue"
import { reactiveOmit } from "@vueuse/core"
import { ChevronDown } from "lucide-vue-next"
import { SelectIcon, SelectTrigger, useForwardProps } from "reka-ui"
import { cn } from "@/lib/utils"

const props = withDefaults(
  defineProps<SelectTriggerProps & { class?: HTMLAttributes["class"], size?: "sm" | "default" }>(),
  { size: "default" },
)

const delegatedProps = reactiveOmit(props, "class", "size")
const forwardedProps = useForwardProps(delegatedProps)
</script>

<template>
  <SelectTrigger
    data-slot="select-trigger"
    :data-size="size"
    v-bind="forwardedProps"
    :class="cn(
      `group flex items-center justify-between px-3 rounded-lg border cursor-pointer transition-colors bg-[var(--fill-tsp-gray-main)] border-[var(--border-white)] hover:bg-[var(--fill-tsp-gray-main)] hover:border-[var(--border-white)] text-[var(--text-primary)] text-sm whitespace-nowrap focus:ring-0 focus:ring-transparent focus:shadow-none focus:border-[var(--border-white)] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 [&:focus]:outline-[0px] [&:focus]:outline-transparent`,
      props.class,
    )"
    style="outline: none !important; box-shadow: none !important;"
  >
    <slot />
    <SelectIcon as-child>
      <ChevronDown class="size-4 transition-transform group-data-[state=open]:rotate-180" style="stroke: var(--text-primary)" />
    </SelectIcon>
  </SelectTrigger>
</template>



================================================
FILE: frontend/src/components/ui/select/SelectValue.vue
================================================
<script setup lang="ts">
import type { SelectValueProps } from "reka-ui"
import { SelectValue } from "reka-ui"

const props = defineProps<SelectValueProps>()
</script>

<template>
  <SelectValue
    data-slot="select-value"
    v-bind="props"
  >
    <slot />
  </SelectValue>
</template>



================================================
FILE: frontend/src/composables/useAuth.ts
================================================
import { ref, computed, onMounted } from 'vue'
import { 
  login as apiLogin, 
  register as apiRegister, 
  logout as apiLogout,
  getCurrentUser,
  refreshToken as apiRefreshToken,
  setAuthToken,
  clearAuthToken,
  storeToken,
  storeRefreshToken,
  getStoredToken,
  getStoredRefreshToken,
  clearStoredTokens,
  getCachedAuthProvider,
  type User,
  type LoginRequest,
  type RegisterRequest,
  type LoginResponse,
  type RegisterResponse
} from '../api/auth'

// Global auth state
const currentUser = ref<User | null>(null)
const isAuthenticated = ref<boolean>(false)
const isLoading = ref<boolean>(false)
const authError = ref<string | null>(null)

export function useAuth() {
  /**
   * Initialize authentication state
   */
  const initAuth = async () => {
    // Get auth provider configuration (cached after first call)
    const authProvider = await getCachedAuthProvider()
    
    if (authProvider === 'none') {
      // No authentication required, set as authenticated with anonymous user
      currentUser.value = {
        id: 'anonymous',
        fullname: 'Anonymous User',
        email: 'anonymous@localhost',
        role: 'user',
        is_active: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }
      isAuthenticated.value = true
      return
    }
    
    // For other auth providers, check token
    const token = getStoredToken()
    if (token) {
      setAuthToken(token)
      await loadCurrentUser()
    }
  }

  /**
   * Load current user information
   */
  const loadCurrentUser = async () => {
    try {
      isLoading.value = true
      authError.value = null
      const user = await getCurrentUser()
      currentUser.value = user
      isAuthenticated.value = true
    } catch (error: any) {
      console.error('Failed to load current user:', error)
      // If token is invalid, clear auth state
      clearAuth()
      authError.value = error.message || 'Failed to load user information'
    } finally {
      isLoading.value = false
    }
  }

  /**
   * User login
   */
  const login = async (credentials: LoginRequest): Promise<LoginResponse> => {
    try {
      isLoading.value = true
      authError.value = null
      
      const response = await apiLogin(credentials)
      
      // Store tokens
      storeToken(response.access_token)
      storeRefreshToken(response.refresh_token)
      setAuthToken(response.access_token)
      
      // Update user state
      currentUser.value = response.user
      isAuthenticated.value = true
      
      return response
    } catch (error: any) {
      authError.value = error.message || 'Login failed'
      throw error
    } finally {
      isLoading.value = false
    }
  }

  /**
   * User registration
   */
  const register = async (data: RegisterRequest): Promise<RegisterResponse> => {
    try {
      isLoading.value = true
      authError.value = null
      
      const response = await apiRegister(data)
      
      // Store tokens
      storeToken(response.access_token)
      storeRefreshToken(response.refresh_token)
      setAuthToken(response.access_token)
      
      // Update user state
      currentUser.value = response.user
      isAuthenticated.value = true
      
      return response
    } catch (error: any) {
      authError.value = error.message || 'Registration failed'
      throw error
    } finally {
      isLoading.value = false
    }
  }

  /**
   * User logout
   */
  const logout = async (silent: boolean = false) => {
    try {
      if (!silent) {
        isLoading.value = true
        authError.value = null
        
        // Call logout API
        await apiLogout()
      }
    } catch (error: any) {
      console.error('Logout API failed:', error)
      // Continue with local logout even if API fails
    } finally {
      // Clear local auth state
      clearAuth()
      isLoading.value = false
    }
  }

  /**
   * Clear authentication state
   */
  const clearAuth = () => {
    currentUser.value = null
    isAuthenticated.value = false
    clearAuthToken()
    clearStoredTokens()
    authError.value = null
  }

  /**
   * Refresh authentication token
   */
  const refreshAuthToken = async (): Promise<boolean> => {
    const refreshToken = getStoredRefreshToken()
    if (!refreshToken) {
      clearAuth()
      return false
    }

    try {
      const response = await apiRefreshToken({ refresh_token: refreshToken })
      
      // Store new access token
      storeToken(response.access_token)
      setAuthToken(response.access_token)
      
      return true
    } catch (error: any) {
      console.error('Token refresh failed:', error)
      clearAuth()
      return false
    }
  }

  /**
   * Check if user has specific role
   */
  const hasRole = (role: string): boolean => {
    return currentUser.value?.role === role
  }

  /**
   * Check if user is admin
   */
  const isAdmin = computed(() => hasRole('admin'))

  /**
   * Check if user account is active
   */
  const isActive = computed(() => currentUser.value?.is_active === true)

  /**
   * Clear authentication error
   */
  const clearError = () => {
    authError.value = null
  }

  // Listen for logout events from token refresh interceptor
  onMounted(() => {
    window.addEventListener('auth:logout', () => {
      logout(true) // Silent logout
    })
  })

  // Auto-initialize auth state when composable is first used
  if (!isAuthenticated.value && !isLoading.value) {
    initAuth()
  }

  return {
    // State
    currentUser: computed(() => currentUser.value),
    isAuthenticated: computed(() => isAuthenticated.value),
    isLoading: computed(() => isLoading.value),
    authError: computed(() => authError.value),
    isAdmin,
    isActive,
    
    // Actions
    login,
    register,
    logout,
    initAuth,
    loadCurrentUser,
    refreshAuthToken,
    hasRole,
    clearError,
    clearAuth
  }
} 


================================================
FILE: frontend/src/composables/useContextMenu.ts
================================================
import { ref, markRaw } from 'vue'

export interface MenuItem {
    key: string;
    label: string;
    icon?: any; // Vue component or SVG
    variant?: 'default' | 'danger';
    checked?: boolean;
    disabled?: boolean;
    action?: (itemId: string) => void;
}

// Global state for context menu
const contextMenuVisible = ref(false)
const selectedItemId = ref<string>()
const menuPosition = ref({ x: 0, y: 0 })
const menuItems = ref<MenuItem[]>([])
const menuItemClickHandler = ref<((itemKey: string, itemId: string) => void) | null>(null)
const onCloseHandler = ref<((itemId: string) => void) | null>(null)
const targetElement = ref<HTMLElement | null>(null)

export function useContextMenu() {
  // Show context menu with specific menu items
  const showContextMenu = (
    itemId: string, 
    element: HTMLElement,
    items: MenuItem[],
    onMenuItemClick?: (itemKey: string, itemId: string) => void,
    onClose?: (itemId: string) => void
  ) => {
    hideContextMenu()
    selectedItemId.value = itemId
    targetElement.value = element
    menuItems.value = items
    menuItemClickHandler.value = onMenuItemClick || null
    onCloseHandler.value = onClose || null
    contextMenuVisible.value = true
  }

  // Hide context menu
  const hideContextMenu = () => {
    const currentItemId = selectedItemId.value
    const currentOnCloseHandler = onCloseHandler.value
    
    contextMenuVisible.value = false
    selectedItemId.value = undefined
    menuItems.value = []
    menuItemClickHandler.value = null
    onCloseHandler.value = null
    targetElement.value = null
    
    // Call onClose callback if provided
    if (currentOnCloseHandler && currentItemId) {
      currentOnCloseHandler(currentItemId)
    }
  }

  // Handle menu item click (called from ContextMenu component)
  const handleMenuItemClick = (item: MenuItem) => {
    if (item.disabled) return;
    
    if (selectedItemId.value) {
      // Call the provided handler
      if (menuItemClickHandler.value) {
        menuItemClickHandler.value(item.key, selectedItemId.value);
      }
      
      // Execute action if provided
      if (item.action) {
        item.action(selectedItemId.value);
      }
    }
    
    hideContextMenu();
  }

  return {
    // Reactive state
    contextMenuVisible,
    selectedItemId,
    menuPosition,
    menuItems,
    targetElement,
    
    // Actions
    showContextMenu,
    hideContextMenu,
    handleMenuItemClick
  }
}

// Utility functions for creating common menu items
export const createMenuItem = (
  key: string,
  label: string,
  options: Partial<Omit<MenuItem, 'key' | 'label'>> = {}
): MenuItem => ({
  key,
  label,
  variant: 'default',
  ...options,
  icon: options.icon ? markRaw(options.icon) : options.icon
})

export const createDangerMenuItem = (
  key: string,
  label: string,
  options: Partial<Omit<MenuItem, 'key' | 'label' | 'variant'>> = {}
): MenuItem => ({
  key,
  label,
  variant: 'danger',
  ...options,
  icon: options.icon ? markRaw(options.icon) : options.icon
})

export const createSeparator = (): MenuItem => ({
  key: 'separator',
  label: '',
  disabled: true,
}) 


================================================
FILE: frontend/src/composables/useDialog.ts
================================================
import { ref, reactive, readonly } from 'vue'
import { useI18n } from 'vue-i18n'

// Dialog state
interface DialogState {
  title: string
  content: string
  confirmText: string
  cancelText: string
  confirmType: 'primary' | 'danger'
  onConfirm?: () => void | Promise<void>
  onCancel?: () => void
}

// Global state
const dialogVisible = ref(false)
const dialogConfig = reactive<DialogState>({
  title: '',
  content: '',
  confirmText: '',
  cancelText: '',
  confirmType: 'primary',
  onConfirm: undefined,
  onCancel: undefined
})

export function useDialog() {
  const { t } = useI18n()

  // Handle confirm
  const handleConfirm = async () => {
    if (dialogConfig.onConfirm) {
      await dialogConfig.onConfirm()
    }
    dialogVisible.value = false
  }

  // Handle cancel
  const handleCancel = () => {
    if (dialogConfig.onCancel) {
      dialogConfig.onCancel()
    }
    dialogVisible.value = false
  }

  // Show general confirm dialog
  const showConfirmDialog = (options: {
    title: string
    content: string
    confirmText?: string
    cancelText?: string
    confirmType?: 'primary' | 'danger'
    onConfirm?: () => void | Promise<void>
    onCancel?: () => void
  }) => {
    Object.assign(dialogConfig, {
      title: options.title,
      content: options.content,
      confirmText: options.confirmText || t('Confirm'),
      cancelText: options.cancelText || t('Cancel'),
      confirmType: options.confirmType || 'primary',
      onConfirm: options.onConfirm,
      onCancel: options.onCancel
    })
    dialogVisible.value = true
  }

  // Show delete session dialog
  const showDeleteSessionDialog = (onConfirm?: () => void | Promise<void>) => {
    showConfirmDialog({
      title: t('Are you sure you want to delete this session?'),
      content: t('The chat history of this session cannot be recovered after deletion.'),
      confirmText: t('Delete'),
      cancelText: t('Cancel'),
      confirmType: 'danger',
      onConfirm
    })
  }

  return {
    dialogVisible: readonly(dialogVisible),
    dialogConfig: readonly(dialogConfig),
    handleConfirm,
    handleCancel,
    showConfirmDialog,
    showDeleteSessionDialog
  }
} 


================================================
FILE: frontend/src/composables/useFilePanel.ts
================================================
import { ref } from 'vue'
import type { FileInfo } from '../api/file'
import { eventBus } from '../utils/eventBus'
import { EVENT_SHOW_FILE_PANEL } from '../constants/event'

const isShow = ref(false)
const visible = ref(true)
const fileInfo = ref<FileInfo>()

export function useFilePanel() {
  const showFilePanel = (file: FileInfo) => {
    eventBus.emit(EVENT_SHOW_FILE_PANEL)
    visible.value = true
    fileInfo.value = file
    isShow.value = true
  }

  const hideFilePanel = () => {
    isShow.value = false
  }

  return {
    isShow,
    fileInfo,
    visible,
    showFilePanel,
    hideFilePanel
  }
} 


================================================
FILE: frontend/src/composables/useI18n.ts
================================================
import { createI18n } from 'vue-i18n'
import { ref, watch } from 'vue'
import messages from '../locales'
import type { Locale } from '../locales'

const STORAGE_KEY = 'manus-locale'

// Get browser language and map to supported locale
const getBrowserLocale = (): Locale => {
  const browserLang = navigator.language || navigator.languages?.[0]
  // Check if browser language starts with any supported locale
  if (browserLang?.startsWith('zh')) {
    return 'zh'
  }
  if (browserLang?.startsWith('en')) {
    return 'en'
  }
  // Default to Chinese if no match
  return 'en'
}

// Get current language from localStorage, default to browser language
const getStoredLocale = (): Locale => {
  const storedLocale = localStorage.getItem(STORAGE_KEY)
  return (storedLocale as Locale) || getBrowserLocale()
}

// Create i18n instance
export const i18n = createI18n({
  legacy: false, // Use Composition API mode
  locale: getStoredLocale(),
  fallbackLocale: 'en',
  messages,
  silentTranslationWarn: true,    // Disable translation warnings
  silentFallbackWarn: true,       // Disable fallback warnings
  missingWarn: false,             // Disable missing key warnings
  fallbackWarn: false,            // Disable fallback warnings
  warnHtmlMessage: false          // Disable HTML in message warnings
})

// Create a composable to use in components
export function useLocale() {
  const currentLocale = ref(getStoredLocale())

  // Switch language
  const setLocale = (locale: Locale) => {
    i18n.global.locale.value = locale
    currentLocale.value = locale
    localStorage.setItem(STORAGE_KEY, locale)
    document.querySelector('html')?.setAttribute('lang', locale)
  }

  // Watch language change
  watch(currentLocale, (val) => {
    setLocale(val)
  })

  return {
    currentLocale,
    setLocale
  }
}

export default i18n 


================================================
FILE: frontend/src/composables/useLeftPanel.ts
================================================
import { ref, watch } from 'vue'
import type { LeftPanelState } from '../types/panel'

// Local storage key for left panel state
const LEFT_PANEL_STATE_KEY = 'manus-left-panel-state'

// Read initial state from localStorage
const getInitialLeftPanelState = (): boolean => {
  try {
    const saved = localStorage.getItem(LEFT_PANEL_STATE_KEY)
    return saved ? JSON.parse(saved) : false
  } catch (error) {
    console.error('Failed to read left panel state from localStorage:', error)
    return false
  }
}

// Global left panel state management
const isLeftPanelShow = ref(getInitialLeftPanelState())

// Save left panel state to localStorage
const saveLeftPanelState = (state: boolean) => {
  try {
    localStorage.setItem(LEFT_PANEL_STATE_KEY, JSON.stringify(state))
  } catch (error) {
    console.error('Failed to save left panel state to localStorage:', error)
  }
}

// Watch for left panel state changes and save to localStorage
watch(isLeftPanelShow, (newValue) => {
  saveLeftPanelState(newValue)
}, { immediate: false })

export function useLeftPanel(): LeftPanelState {
  // Toggle left panel visibility
  const toggleLeftPanel = () => {
    isLeftPanelShow.value = !isLeftPanelShow.value
  }

  // Set left panel visibility
  const setLeftPanel = (visible: boolean) => {
    isLeftPanelShow.value = visible
  }

  // Show left panel
  const showLeftPanel = () => {
    isLeftPanelShow.value = true
  }

  // Hide left panel
  const hideLeftPanel = () => {
    isLeftPanelShow.value = false
  }

  return {
    isLeftPanelShow,
    toggleLeftPanel,
    setLeftPanel,
    showLeftPanel,
    hideLeftPanel
  }
} 


================================================
FILE: frontend/src/composables/useResizeObserver.ts
================================================
import { ref, onMounted, onUnmounted, nextTick } from 'vue'
import { getParentElement } from '../utils/dom'

export function useResizeObserver(
  targetRef: any,
  options: {
    target?: 'self' | 'parent'
    callback?: (size: number) => void
    property?: 'width' | 'height'
  } = {}
) {
  const {
    target = 'parent',
    callback,
    property = 'width'
  } = options

  const size = ref(0)
  let resizeObserver: ResizeObserver | null = null

  const updateSize = (element: HTMLElement) => {
    const newSize = property === 'width' ? element.offsetWidth : element.offsetHeight
    size.value = newSize
    callback?.(newSize)
  }

  onMounted(async () => {
    // Wait for DOM to be ready
    await nextTick()
    
    // Get the current component's DOM element using ref
    const currentElement = targetRef.value
    if (!currentElement) {
      console.warn('Could not find target element')
      return
    }
    
    // Determine which element to observe
    let observeElement: HTMLElement
    if (target === 'parent') {
      const parentElement = getParentElement(currentElement)
      if (!parentElement) {
        console.warn('Could not find parent element')
        return
      }
      observeElement = parentElement
    } else {
      observeElement = currentElement
    }
    
    // Set initial size immediately for instant response
    updateSize(observeElement)
    
    // Create ResizeObserver to watch size changes with immediate updates
    resizeObserver = new ResizeObserver(() => {
      updateSize(observeElement)
    })
    
    try {
      // Start observing
      resizeObserver.observe(observeElement)
    } catch (error) {
      console.error('Failed to observe element:', error)
    }
  })

  onUnmounted(() => {
    if (resizeObserver) {
      resizeObserver.disconnect()
    }
  })

  return {
    size
  }
} 


================================================
FILE: frontend/src/composables/useRightPanel.ts
================================================
import { ref } from 'vue'
import type { ToolContent } from '../types/message'
import type { FileInfo } from '../api/file'

const isShow = ref(false)
const live = ref(false)
const toolContent = ref<ToolContent>()
const fileInfo = ref<FileInfo>()
const panelType = ref<'tool' | 'file'>('tool')

export function useRightPanel() {
  const showTool = (content: ToolContent, isLive: boolean = false) => {
    panelType.value = 'tool'
    toolContent.value = content
    isShow.value = true
    live.value = isLive
  }

  const showFile = (file: FileInfo) => {
    panelType.value = 'file'
    fileInfo.value = file
    isShow.value = true
  }

  const hide = () => {
    isShow.value = false
  }

  return {
    isShow,
    live,
    toolContent,
    fileInfo,
    panelType,
    showTool,
    showFile,
    hide
  }
} 


================================================
FILE: frontend/src/composables/useSessionFileList.ts
================================================
import { ref } from 'vue';

const visible = ref(false);

export function useSessionFileList() {
    const showSessionFileList = () => {
        visible.value = true;
    }

    const hideSessionFileList = () => {
        visible.value = false;
    }

    return {
        visible,
        showSessionFileList,
        hideSessionFileList
    }
} 


================================================
FILE: frontend/src/composables/useSettingsDialog.ts
================================================
import { ref } from 'vue'

// Global state for settings dialog
const isSettingsDialogOpen = ref(false)
const defaultTab = ref<string>('settings')

export function useSettingsDialog() {
  const openSettingsDialog = (tabId?: string) => {
    if (tabId) {
      defaultTab.value = tabId
    }
    isSettingsDialogOpen.value = true
  }

  const closeSettingsDialog = () => {
    isSettingsDialogOpen.value = false
  }

  const toggleSettingsDialog = () => {
    isSettingsDialogOpen.value = !isSettingsDialogOpen.value
  }

  const setDefaultTab = (tabId: string) => {
    defaultTab.value = tabId
  }

  return {
    isSettingsDialogOpen,
    defaultTab,
    openSettingsDialog,
    closeSettingsDialog,
    toggleSettingsDialog,
    setDefaultTab
  }
}



================================================
FILE: frontend/src/composables/useTime.ts
================================================
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { formatRelativeTime, formatCustomTime } from '../utils/time';
import { useI18n } from 'vue-i18n';

export function useRelativeTime() {
  // Create a reactive current time variable to trigger re-rendering
  const currentTime = ref(Date.now());

  // Set a timer to update the time every minute
  let timer: number | null = null;

  onMounted(() => {
    timer = window.setInterval(() => {
      currentTime.value = Date.now();
    }, 60000); // Update every minute
  });

  onUnmounted(() => {
    if (timer !== null) {
      clearInterval(timer);
      timer = null;
    }
  });

  // Calculate relative time, depends on currentTime for automatic updates
  const relativeTime = computed(() => {
    currentTime.value; // Depends on currentTime, recalculate when currentTime updates
    return (timestamp: number) => formatRelativeTime(timestamp);
  });

  return {
    relativeTime
  };
}

export function useCustomTime() {
  const { t, locale } = useI18n();
  
  // Create a reactive current time variable to trigger re-rendering
  const currentTime = ref(Date.now());

  // Set a timer to update the time every minute
  let timer: number | null = null;

  onMounted(() => {
    timer = window.setInterval(() => {
      currentTime.value = Date.now();
    }, 60000); // Update every minute
  });

  onUnmounted(() => {
    if (timer !== null) {
      clearInterval(timer);
      timer = null;
    }
  });

  // Calculate custom formatted time, depends on currentTime for automatic updates
  const customTime = computed(() => {
    currentTime.value; // Depends on currentTime, recalculate when currentTime updates
    return (timestamp: number) => formatCustomTime(timestamp, t, locale.value);
  });

  return {
    customTime
  };
} 


================================================
FILE: frontend/src/composables/useTool.ts
================================================
import { computed, Ref } from 'vue';
import type { ToolContent } from '../types/message';
import { useI18n } from 'vue-i18n';
import { TOOL_ICON_MAP, TOOL_NAME_MAP, TOOL_FUNCTION_MAP, TOOL_FUNCTION_ARG_MAP, TOOL_COMPONENT_MAP } from '../constants/tool';

export function useToolInfo(tool?: Ref<ToolContent | undefined>) {
  const { t } = useI18n();

  const toolInfo = computed(() => {
    if (!tool || !tool.value) return null;
    
    // MCP tool
    if (tool.value.function.startsWith('mcp_')) {
      const mcpToolName = tool.value.function.replace(/^mcp_/, '');
      let functionArg = '';
      
      const args = tool.value.args;
      if (args && Object.keys(args).length > 0) {
        const firstKey = Object.keys(args)[0];
        const firstValue = args[firstKey];
        if (typeof firstValue === 'string' && firstValue.length < 50) {
          functionArg = firstValue;
        } else if (firstValue !== undefined) {
          functionArg = JSON.stringify(firstValue).substring(0, 30) + '...';
        }
      }
      
      return {
        icon: TOOL_ICON_MAP['mcp'] || null,
        name: t(TOOL_NAME_MAP['mcp'] || 'MCP Tool'),
        function: mcpToolName,
        functionArg: functionArg,
        view: TOOL_COMPONENT_MAP['mcp'] || null
      };
    }
    
    let functionArg = tool.value.args[TOOL_FUNCTION_ARG_MAP[tool.value.function]] || '';
    if (TOOL_FUNCTION_ARG_MAP[tool.value.function] === 'file') {
      functionArg = functionArg.replace(/^\/home\/ubuntu\//, '');
    }
    
    return {
      icon: TOOL_ICON_MAP[tool.value.name] || null,
      name: t(TOOL_NAME_MAP[tool.value.name] || ''),
      function: t(TOOL_FUNCTION_MAP[tool.value.function] || tool.value.function),
      functionArg: functionArg,
      view: TOOL_COMPONENT_MAP[tool.value.name] || null
    };
  });

  return {
    toolInfo
  };
} 


================================================
FILE: frontend/src/constants/event.ts
================================================
export const EVENT_SHOW_TOOL_PANEL = 'EVENT_SHOW_TOOL_PANEL'
export const EVENT_SHOW_FILE_PANEL = 'EVENT_SHOW_FILE_PANEL'


================================================
FILE: frontend/src/constants/tool.ts
================================================
/**
 * Tool function mapping
 */
export const TOOL_FUNCTION_MAP: {[key: string]: string} = {
  // Shell tools
  "shell_exec": "Executing command",
  "shell_view": "Viewing command output",
  "shell_wait": "Waiting for command completion",
  "shell_write_to_process": "Writing data to process",
  "shell_kill_process": "Terminating process",
  
  // File tools
  "file_read": "Reading file",
  "file_write": "Writing file",
  "file_str_replace": "Replacing file content",
  "file_find_in_content": "Searching file content",
  "file_find_by_name": "Finding file",
  
  // Browser tools
  "browser_view": "Viewing webpage",
  "browser_navigate": "Navigating to webpage",
  "browser_restart": "Restarting browser",
  "browser_click": "Clicking element",
  "browser_input": "Entering text",
  "browser_move_mouse": "Moving mouse",
  "browser_press_key": "Pressing key",
  "browser_select_option": "Selecting option",
  "browser_scroll_up": "Scrolling up",
  "browser_scroll_down": "Scrolling down",
  "browser_console_exec": "Executing JS code",
  "browser_console_view": "Viewing console output",
  
  // Search tools
  "info_search_web": "Searching web",
  
  // Message tools
  "message_notify_user": "Sending notification",
  "message_ask_user": "Asking question"
};

/**
 * Display name mapping for tool function parameters
 */
export const TOOL_FUNCTION_ARG_MAP: {[key: string]: string} = {
  "shell_exec": "command",
  "shell_view": "shell",
  "shell_wait": "shell",
  "shell_write_to_process": "input",
  "shell_kill_process": "shell",
  "file_read": "file",
  "file_write": "file",
  "file_str_replace": "file",
  "file_find_in_content": "file",
  "file_find_by_name": "path",
  "browser_view": "page",
  "browser_navigate": "url",
  "browser_restart": "url",
  "browser_click": "element",
  "browser_input": "text",
  "browser_move_mouse": "position",
  "browser_press_key": "key",
  "browser_select_option": "option",
  "browser_scroll_up": "page",
  "browser_scroll_down": "page",
  "browser_console_exec": "code",
  "browser_console_view": "console",
  "info_search_web": "query",
  "message_notify_user": "message",
  "message_ask_user": "question"
};

/**
 * Tool name mapping
 */
export const TOOL_NAME_MAP: {[key: string]: string} = {
  "shell": "Terminal",
  "file": "File",
  "browser": "Browser",
  "info": "Information",
  "message": "Message",
  "mcp": "MCP Tool"
};

import SearchIcon from '../components/icons/SearchIcon.vue';
import EditIcon from '../components/icons/EditIcon.vue';
import BrowserIcon from '../components/icons/BrowserIcon.vue';
import ShellIcon from '../components/icons/ShellIcon.vue';

/**
 * Tool icon mapping
 */
export const TOOL_ICON_MAP: {[key: string]: any} = {
  "shell": ShellIcon,
  "file": EditIcon,
  "browser": BrowserIcon,
  "search": SearchIcon,
  "message": "",
  "mcp": SearchIcon  // 暂时使用搜索图标，可以后续创建专门的MCP图标
};

import ShellToolView from '@/components/toolViews/ShellToolView.vue';
import FileToolView from '@/components/toolViews/FileToolView.vue';
import SearchToolView from '@/components/toolViews/SearchToolView.vue';
import BrowserToolView from '@/components/toolViews/BrowserToolView.vue';
import McpToolView from '@/components/toolViews/McpToolView.vue';

/**
 * Mapping from tool names to components
 */
export const TOOL_COMPONENT_MAP: {[key: string]: any} = {
  "shell": ShellToolView,
  "file": FileToolView,
  "search": SearchToolView,
  "browser": BrowserToolView,
  "mcp": McpToolView
};



================================================
FILE: frontend/src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


================================================
FILE: frontend/src/locales/en.ts
================================================
export default {
  'Hello': 'Hello',
  'What can I do for you?': 'What can I do for you?',
  'Failed to create agent, please try again later': 'Failed to create agent, please try again later',
  'New Chat': 'New Chat',
  'New Task': 'New Task',
  'Thinking': 'Thinking',
  'Task Progress': 'Task Progress',
  'Task Completed': 'Task Completed',
  'Create a task to get started': 'Create a task to get started',
  'Delete': 'Delete',
  'Just now': 'Just now',
  'minutes ago': 'minutes ago',
  'hours ago': 'hours ago',
  'days ago': 'days ago',
  'months ago': 'months ago',
  'years ago': 'years ago',
  // Weekdays
  'Sunday': 'Sun',
  'Monday': 'Mon',
  'Tuesday': 'Tue',
  'Wednesday': 'Wed',
  'Thursday': 'Thu',
  'Friday': 'Fri',
  'Saturday': 'Sat',
  'Manus Computer': 'Manus Computer',
  'Manus is using': 'Manus is using',
  'Jump to live': 'Jump to live',
  'Failed to load file content': 'Failed to load file content',
  'Give Manus a task to work on...': 'Give Manus a task to work on...',
  // Shell tools
  'Executing command': 'Executing command',
  'Viewing command output': 'Viewing command output',
  'Waiting for command completion': 'Waiting for command completion',
  'Writing data to process': 'Writing data to process',
  'Terminating process': 'Terminating process',
  // File tools
  'Reading file': 'Reading file',
  'Writing file': 'Writing file',
  'Replacing file content': 'Replacing file content',
  'Searching file content': 'Searching file content',
  'Finding file': 'Finding file',
  // Browser tools
  'Viewing webpage': 'Viewing webpage',
  'Navigating to webpage': 'Navigating to webpage',
  'Restarting browser': 'Restarting browser',
  'Clicking element': 'Clicking element',
  'Entering text': 'Entering text',
  'Moving mouse': 'Moving mouse',
  'Pressing key': 'Pressing key',
  'Selecting option': 'Selecting option',
  'Scrolling up': 'Scrolling up',
  'Scrolling down': 'Scrolling down',
  'Executing JS code': 'Executing JS code',
  'Viewing console output': 'Viewing console output',
  // Search tools
  'Searching web': 'Searching web',
  // Message tools
  'Sending notification': 'Sending notification',
  'Asking question': 'Asking question',
  // Tool names
  'Terminal': 'Terminal',
  'File': 'File',
  'Browser': 'Browser',
  'Information': 'Information',
  'Message': 'Message',
  // Dialog
  'Confirm': 'Confirm',
  'Cancel': 'Cancel',
  'Close Dialog': 'Close Dialog',
  'Are you sure you want to delete this session?': 'Are you sure you want to delete this session?',
  'The chat history of this session cannot be recovered after deletion.': 'The chat history of this session cannot be recovered after deletion.',
  'Deleted successfully': 'Deleted successfully',
  'Failed to delete session': 'Failed to delete session',
  'Exit Takeover': 'Exit Takeover',
  'Take Over': 'Take Over',
  // Session File List
  'All Files in This Task': 'All Files in This Task',
  'No Content': 'No Content',
  // File Preview
  'This format cannot be previewed': 'This format cannot be previewed',
  'Please download the file to view its content': 'Please download the file to view its content',
  'Download': 'Download',
  'View all files in this task': 'View all files in this task',
  // File Upload
  'Upload failed': 'Upload failed',
  'Uploading...': 'Uploading...',
  // File Types
  'Text': 'Text',
  'Markdown': 'Markdown',
  'Code': 'Code',
  'Image': 'Image',
  'PDF': 'PDF',
  'Word': 'Word',
  'Excel': 'Excel',
  'PowerPoint': 'PowerPoint',
  'Document': 'Document',
  'Video': 'Video',
  'Audio': 'Audio',
  'Archive': 'Archive',
  // Login/Register Page
  'Login to Manus': 'Login to Manus',
  'Register to Manus': 'Register to Manus',
  'Full Name': 'Full Name',
  'Email': 'Email',
  'Password': 'Password',
  'Confirm Password': 'Confirm Password',
  'Enter your full name': 'Enter your full name',
  'Enter password': 'Enter password',
  'Enter password again': 'Enter password again',
  'Processing...': 'Processing...',
  'Login': 'Login',
  'Register': 'Register',
  'Already have an account?': 'Already have an account?',
  'Don\'t have an account?': 'Don\'t have an account?',
  'Login successful! Welcome back': 'Login successful! Welcome back',
  'Registration successful! Welcome to Manus': 'Registration successful! Welcome to Manus',
  'Authentication failed, please try again': 'Authentication failed, please try again',
  'Passwords do not match': 'Passwords do not match',
  // Validation error messages
  'Full name must be at least 2 characters long': 'Full name must be at least 2 characters long',
  'Full name must be less than 100 characters': 'Full name must be less than 100 characters',
  'Please enter a valid email address': 'Please enter a valid email address',
  'Password must be at least 6 characters long': 'Password must be at least 6 characters long',
  // User Menu
  'Logout': 'Logout',
  'Unknown User': 'Unknown User',
  'No email': 'No email',
  // Settings Dialog
  'Settings': 'Settings',
  'Account': 'Account',
  'General': 'General',
  'Language': 'Language',
  'Profile': 'Profile',
  // Profile Settings
  'Name': 'Name',
  'Full name updated successfully': 'Full name updated successfully',
  'Failed to update full name': 'Failed to update full name',
  'Update Password': 'Update Password',
  // Change Password Dialog
  'Current Password': 'Current Password',
  'New Password': 'New Password',
  'Confirm New Password': 'Confirm New Password',
  'Enter current password': 'Enter current password',
  'Enter new password': 'Enter new password',
  'Enter new password again': 'Enter new password again',
  'Password change successful': 'Password change successful',
  'Password change failed': 'Password change failed',
  'Forgot Password?': 'Forgot Password?',
  'Reset Password': 'Reset Password',
  'Reset link sent!': 'Reset link sent!',
  'Please check your email for further instructions.': 'Please check your email for further instructions.',
  'Remember your password?': 'Remember your password?',
  'Back to Login': 'Back to Login',
  'Reset link sent to your email': 'Reset link sent to your email',
  'Failed to send reset link. Please try again.': 'Failed to send reset link. Please try again.',
  // Language Selection
  'Select language': 'Select language',
  'Simplified Chinese': 'Simplified Chinese',
  'English': 'English',
  // MCP Tool View
  'Tool': 'Tool',
  'Arguments': 'Arguments',
  'Result': 'Result',
  'Tool is executing...': 'Tool is executing...',
  'Waiting for result...': 'Waiting for result...',
  // Reset Password Verification
  'Verification code sent to': 'Verification code sent to',
  'Enter 6-digit verification code': 'Enter 6-digit verification code',
  'Resend': 'Resend',
  'Verification code is required': 'Verification code is required',
  'Verification code must be 6 digits': 'Verification code must be 6 digits',
  'Please confirm your password': 'Please confirm your password',
  'Enter your new password': 'Enter your new password',
  'Confirm your new password': 'Confirm your new password',
  'Updating...': 'Updating...',
  'Password updated successfully!': 'Password updated successfully!',
  'You can now login with your new password.': 'You can now login with your new password.',
  'Didn\'t receive the code?': 'Didn\'t receive the code?',
  'Resend in {seconds}s': 'Resend in {seconds}s',
  'Resend Code': 'Resend Code',
  'Ready to login?': 'Ready to login?',
  'Want to try a different email?': 'Want to try a different email?',
  'Go Back': 'Go Back',
  'Verification code sent again': 'Verification code sent again',
  'Failed to resend verification code. Please try again.': 'Failed to resend verification code. Please try again.',
  'Password updated successfully': 'Password updated successfully',
  'Failed to update password. Please check your verification code and try again.': 'Failed to update password. Please check your verification code and try again.',
  // Reset Password Form
  'Sending Code...': 'Sending Code...',
  'Send Verification Code': 'Send Verification Code',
} 


================================================
FILE: frontend/src/locales/index.ts
================================================
import en from './en'
import zh from './zh'

export default {
  en,
  zh
}

export type Locale = 'en' | 'zh'

export const availableLocales: { label: string; value: Locale }[] = [
  { label: 'English', value: 'en' },
  { label: '中文', value: 'zh' }
] 


================================================
FILE: frontend/src/locales/zh.ts
================================================
export default {
  'Hello': '你好',
  'What can I do for you?': '我能为你做什么？',
  'Failed to create agent, please try again later': '创建Agent失败，请稍后重试',
  'New Chat': '新对话',
  'New Task': '新建任务',
  'Thinking': '思考中',
  'Task Progress': '任务进度',
  'Task Completed': '任务已完成',
  'Create a task to get started': '新建一个任务以开始',
  'Delete': '删除',
  'Just now': '刚刚',
  'minutes ago': '分钟前',
  'hours ago': '小时前',
  'days ago': '天前',
  'months ago': '个月前',
  'years ago': '年前',
  // Weekdays
  'Sunday': '周日',
  'Monday': '周一',
  'Tuesday': '周二',
  'Wednesday': '周三',
  'Thursday': '周四',
  'Friday': '周五',
  'Saturday': '周六',
  'Manus Computer': 'Manus 的电脑',
  'Manus is using': 'Manus 正在使用',
  'Jump to live': '跳到实时',
  'Failed to load file content': '加载文件内容失败',
  'Give Manus a task to work on...': '给 Manus 一个任务...',
  // Shell tools
  'Executing command': '正在执行命令',
  'Viewing command output': '正在查看命令输出',
  'Waiting for command completion': '正在等待命令完成',
  'Writing data to process': '正在向进程写入数据',
  'Terminating process': '正在终止进程',
  // File tools
  'Reading file': '正在读取文件',
  'Writing file': '正在写入文件',
  'Replacing file content': '正在替换文件内容',
  'Searching file content': '正在搜索文件内容',
  'Finding file': '正在查找文件',
  // Browser tools
  'Viewing webpage': '正在查看网页',
  'Navigating to webpage': '正在导航到网页',
  'Restarting browser': '正在重启浏览器',
  'Clicking element': '正在点击元素',
  'Entering text': '正在输入文本',
  'Moving mouse': '正在移动鼠标',
  'Pressing key': '正在按键',
  'Selecting option': '正在选择选项',
  'Scrolling up': '正在向上滚动',
  'Scrolling down': '正在向下滚动',
  'Executing JS code': '正在执行JS代码',
  'Viewing console output': '正在查看控制台输出',
  // Search tools
  'Searching web': '正在搜索网络',
  // Message tools
  'Sending notification': '正在发送通知',
  'Asking question': '正在提问',
  // Tool names
  'Terminal': '终端',
  'File': '文件',
  'Browser': '浏览器',
  'Information': '信息',
  'Message': '消息',
  // Dialog
  'Confirm': '确认',
  'Cancel': '取消',
  'Close Dialog': '关闭对话框',
  'Are you sure you want to delete this session?': '确定要删除该会话吗？',
  'The chat history of this session cannot be recovered after deletion.': '删除后将无法恢复该会话的聊天记录。',
  'Deleted successfully': '删除成功',
  'Failed to delete session': '删除会话失败',
  'Exit Takeover': '退出接管',
  'Take Over': '接管',
  // Session File List
  'All Files in This Task': '此任务中的所有文件',
  'No Content': '暂无内容',
  // File Preview
  'This format cannot be previewed': '此格式无法预览',
  'Please download the file to view its content': '请下载文件以查看其内容',
  'Download': '下载',
  'View all files in this task': '查看此任务中的所有文件',
  // File Upload
  'Upload failed': '上传失败',
  'Uploading...': '上传中...',
  // File Types
  'Text': '文本',
  'Markdown': 'Markdown',
  'Code': '代码',
  'Image': '图片',
  'PDF': 'PDF',
  'Word': 'Word',
  'Excel': 'Excel',
  'PowerPoint': 'PowerPoint',
  'Document': '文档',
  'Video': '视频',
  'Audio': '音频',
  'Archive': '压缩包',
  // Login/Register Page
  'Login to Manus': '登录 Manus',
  'Register to Manus': '注册 Manus',
  'Full Name': '姓名',
  'Email': '邮箱',
  'Password': '密码',
  'Confirm Password': '确认密码',
  'Enter your full name': '输入您的姓名',
  'Enter password': '输入密码',
  'Enter password again': '再次输入密码',
  'Processing...': '处理中...',
  'Login': '登录',
  'Register': '注册',
  'Already have an account?': '已有账户？',
  'Don\'t have an account?': '没有账户？',
  'Login successful! Welcome back': '登录成功！欢迎回来',
  'Registration successful! Welcome to Manus': '注册成功！欢迎使用 Manus',
  'Authentication failed, please try again': '认证失败，请重试',
  'Passwords do not match': '两次密码输入不一致',
  // Validation error messages
  'Full name must be at least 2 characters long': '姓名至少需要2个字符',
  'Full name must be less than 100 characters': '姓名不能超过100个字符',
  'Please enter a valid email address': '请输入有效的邮箱地址',
  'Password must be at least 6 characters long': '密码至少需要6个字符',
  // User Menu
  'Logout': '退出登录',
  'Unknown User': '未知用户',
  'No email': '无邮箱',
  // Settings Dialog
  'Settings': '设置',
  'Account': '账户',
  'General': '通用',
  'Language': '语言',
  'Profile': '个人资料',
  // Profile Settings
  'Name': '名称',
  'Full name updated successfully': '姓名修改成功',
  'Failed to update full name': '姓名修改失败',
  'Update Password': '更新密码',
  // Change Password Dialog
  'Current Password': '当前密码',
  'New Password': '新密码',
  'Confirm New Password': '确认新密码',
  'Enter current password': '请输入当前密码',
  'Enter new password': '请输入新密码',
  'Enter new password again': '请再次输入新密码',
  'Password change successful': '密码修改成功',
  'Password change failed': '密码修改失败',
  'Forgot Password?': '忘记密码？',
  'Reset Password': '重置密码',
  'Reset link sent!': '重置链接已发送！',
  'Please check your email for further instructions.': '请查看您的邮箱以获取进一步说明。',
  'Remember your password?': '记起密码了？',
  'Back to Login': '返回登录',
  'Reset link sent to your email': '重置链接已发送到您的邮箱',
  'Failed to send reset link. Please try again.': '发送重置链接失败，请重试。',
  // Language Selection
  'Select language': '选择语言',
  'Simplified Chinese': '简体中文',
  'English': '英文',
  // MCP Tool View
  'Tool': '工具',
  'Arguments': '参数',
  'Result': '结果',
  'Tool is executing...': '工具执行中...',
  'Waiting for result...': '等待结果...',
  // Reset Password Verification
  'Verification code sent to': '验证码已发送至',
  'Enter 6-digit verification code': '输入6位验证码',
  'Resend': '重发',
  'Verification code is required': '验证码为必填项',
  'Verification code must be 6 digits': '验证码必须为6位数字',
  'Please confirm your password': '请确认您的密码',
  'Enter your new password': '请输入新密码',
  'Confirm your new password': '请确认新密码',
  'Updating...': '更新中...',
  'Password updated successfully!': '密码更新成功！',
  'You can now login with your new password.': '您现在可以使用新密码登录了。',
  'Didn\'t receive the code?': '没有收到验证码？',
  'Resend in {seconds}s': '{seconds}秒后重发',
  'Resend Code': '重发验证码',
  'Ready to login?': '准备登录？',
  'Want to try a different email?': '想换个邮箱？',
  'Go Back': '返回',
  'Verification code sent again': '验证码已重新发送',
  'Failed to resend verification code. Please try again.': '重发验证码失败，请重试。',
  'Password updated successfully': '密码更新成功',
  'Failed to update password. Please check your verification code and try again.': '密码更新失败，请检查验证码后重试。',
  // Reset Password Form
  'Sending Code...': '发送验证码中...',
  'Send Verification Code': '发送验证码',
} 


================================================
FILE: frontend/src/pages/ChatPage.vue
================================================
<template>
  <SimpleBar ref="simpleBarRef" @scroll="handleScroll">
    <div ref="chatContainerRef" class="relative flex flex-col h-full flex-1 min-w-0 px-5">
      <div ref="observerRef"
        class="sm:min-w-[390px] flex flex-row items-center justify-between pt-3 pb-1 gap-1 sticky top-0 z-10 bg-[var(--background-gray-main)] flex-shrink-0">
        <div class="flex items-center flex-1">
          <div class="relative flex items-center">
            <div @click="toggleLeftPanel" v-if="!isLeftPanelShow"
              class="flex h-7 w-7 items-center justify-center cursor-pointer rounded-md hover:bg-[var(--fill-tsp-gray-main)]">
              <PanelLeft class="size-5 text-[var(--icon-secondary)]" />
            </div>
          </div>
        </div>
        <div class="max-w-full sm:max-w-[768px] sm:min-w-[390px] flex w-full flex-col gap-[4px] overflow-hidden">
          <div
            class="text-[var(--text-primary)] text-lg font-medium w-full flex flex-row items-center justify-between flex-1 min-w-0 gap-2">
            <div class="flex flex-row items-center gap-[6px] flex-1 min-w-0">
              <span class="whitespace-nowrap text-ellipsis overflow-hidden">
                {{ title }}
              </span>
            </div>
            <div class="flex items-center gap-2 flex-shrink-0">
              <button @click="handleFileListShow"
                class="p-[5px] flex items-center justify-center hover:bg-[var(--fill-tsp-white-dark)] rounded-lg cursor-pointer">
                <FileSearch class="text-[var(--icon-secondary)]" :size="18" />
              </button>
            </div>
          </div>
          <div class="w-full flex justify-between items-center">
          </div>
        </div>
        <div class="flex-1"></div>
      </div>
      <div class="mx-auto w-full max-w-full sm:max-w-[768px] sm:min-w-[390px] flex flex-col flex-1">
        <div class="flex flex-col w-full gap-[12px] pb-[80px] pt-[12px] flex-1 overflow-y-auto">
          <ChatMessage v-for="(message, index) in messages" :key="index" :message="message"
            @toolClick="handleToolClick" />

          <!-- Loading indicator -->
          <div v-if="isLoading" class="flex items-center gap-1 text-[var(--text-tertiary)] text-sm"><span>{{
            $t('Thinking') }}</span><span class="flex gap-1 relative top-[4px]"><span
                class="w-[3px] h-[3px] rounded animate-bounce-dot bg-[var(--icon-tertiary)]"
                style="animation-delay: 0ms;"></span><span
                class="w-[3px] h-[3px] rounded animate-bounce-dot bg-[var(--icon-tertiary)]"
                style="animation-delay: 200ms;"></span><span
                class="w-[3px] h-[3px] rounded animate-bounce-dot bg-[var(--icon-tertiary)]"
                style="animation-delay: 400ms;"></span></span></div>
        </div>

        <div class="flex flex-col bg-[var(--background-gray-main)] sticky bottom-0">
          <template v-if="plan && plan.steps.length > 0">
            <button @click="handleFollow" v-if="!follow"
              class="flex items-center justify-center w-[36px] h-[36px] rounded-full bg-[var(--background-white-main)] hover:bg-[var(--background-gray-main)] clickable border border-[var(--border-main)] shadow-[0px_5px_16px_0px_var(--shadow-S),0px_0px_1.25px_0px_var(--shadow-S)] absolute -top-20 left-1/2 -translate-x-1/2">
              <ArrowDown class="text-[var(--icon-primary)]" :size="20" />
            </button>
            <PlanPanel :plan="plan" />
          </template>
          <ChatBox v-model="inputMessage" :rows="1" @submit="handleSubmit" :isRunning="isLoading" @stop="handleStop"
            :attachments="attachments" />
        </div>
      </div>
    </div>
    <ToolPanel ref="toolPanel" :size="toolPanelSize" :sessionId="sessionId" :realTime="realTime"
      @jumpToRealTime="jumpToRealTime" />
  </SimpleBar>
</template>

<script setup lang="ts">
import SimpleBar from '../components/SimpleBar.vue';
import { ref, onMounted, watch, nextTick, onUnmounted, reactive, toRefs } from 'vue';
import { useRouter, onBeforeRouteUpdate } from 'vue-router';
import { useI18n } from 'vue-i18n';
import ChatBox from '../components/ChatBox.vue';
import ChatMessage from '../components/ChatMessage.vue';
import * as agentApi from '../api/agent';
import { Message, MessageContent, ToolContent, StepContent, AttachmentsContent } from '../types/message';
import {
  StepEventData,
  ToolEventData,
  MessageEventData,
  ErrorEventData,
  TitleEventData,
  PlanEventData,
  AgentSSEEvent,
} from '../types/event';
import ToolPanel from '../components/ToolPanel.vue'
import PlanPanel from '../components/PlanPanel.vue';
import { ArrowDown, FileSearch, PanelLeft } from 'lucide-vue-next';
import { showErrorToast } from '../utils/toast';
import type { FileInfo } from '../api/file';
import { useLeftPanel } from '../composables/useLeftPanel'
import { useSessionFileList } from '../composables/useSessionFileList'
import { useFilePanel } from '../composables/useFilePanel'
import { SessionStatus } from '../types/response';

const router = useRouter()
const { t } = useI18n()
const { toggleLeftPanel, isLeftPanelShow } = useLeftPanel()
const { showSessionFileList } = useSessionFileList()
const { hideFilePanel } = useFilePanel()

// Create initial state factory
const createInitialState = () => ({
  inputMessage: '',
  isLoading: false,
  sessionId: undefined as string | undefined,
  messages: [] as Message[],
  toolPanelSize: 0,
  realTime: true,
  follow: true,
  title: t('New Chat'),
  plan: undefined as PlanEventData | undefined,
  lastNoMessageTool: undefined as ToolContent | undefined,
  lastMessageTool: undefined as ToolContent | undefined,
  lastTool: undefined as ToolContent | undefined,
  lastEventId: undefined as string | undefined,
  cancelCurrentChat: null as (() => void) | null,
  attachments: [] as FileInfo[]
});

// Create reactive state
const state = reactive(createInitialState());

// Destructure refs from reactive state
const {
  inputMessage,
  isLoading,
  sessionId,
  messages,
  toolPanelSize,
  realTime,
  follow,
  title,
  plan,
  lastNoMessageTool,
  lastTool,
  lastEventId,
  cancelCurrentChat,
  attachments
} = toRefs(state);

// Non-state refs that don't need reset
const toolPanel = ref<InstanceType<typeof ToolPanel>>()
const simpleBarRef = ref<InstanceType<typeof SimpleBar>>();
const observerRef = ref<HTMLDivElement>();
const chatContainerRef = ref<HTMLDivElement>();

// Reset all refs to their initial values
const resetState = () => {
  // Cancel any existing chat connection
  if (cancelCurrentChat.value) {
    cancelCurrentChat.value();
  }

  // Reset reactive state to initial values
  Object.assign(state, createInitialState());
};

// Watch message changes and automatically scroll to bottom
watch(messages, async () => {
  await nextTick();
  if (follow.value) {
    simpleBarRef.value?.scrollToBottom();
  }
}, { deep: true });



const getLastStep = (): StepContent | undefined => {
  return messages.value.filter(message => message.type === 'step').pop()?.content as StepContent;
}

// Handle message event
const handleMessageEvent = (messageData: MessageEventData) => {
  messages.value.push({
    type: messageData.role,
    content: {
      ...messageData
    } as MessageContent,
  });

  if (messageData.attachments?.length > 0) {
    messages.value.push({
      type: 'attachments',
      content: {
        ...messageData
      } as AttachmentsContent,
    });
  }
}

// Handle tool event
const handleToolEvent = (toolData: ToolEventData) => {
  const lastStep = getLastStep();
  let toolContent: ToolContent = {
    ...toolData
  }
  if (lastTool.value && lastTool.value.tool_call_id === toolContent.tool_call_id) {
    Object.assign(lastTool.value, toolContent);
  } else {
    if (lastStep?.status === 'running') {
      lastStep.tools.push(toolContent);
    } else {
      messages.value.push({
        type: 'tool',
        content: toolContent,
      });
    }
    lastTool.value = toolContent;
  }
  if (toolContent.name !== 'message') {
    lastNoMessageTool.value = toolContent;
    if (realTime.value) {
      toolPanel.value?.showToolPanel(toolContent, true);
    }
  }
}

// Handle step event
const handleStepEvent = (stepData: StepEventData) => {
  const lastStep = getLastStep();
  if (stepData.status === 'running') {
    messages.value.push({
      type: 'step',
      content: {
        ...stepData,
        tools: []
      } as StepContent,
    });
  } else if (stepData.status === 'completed') {
    if (lastStep) {
      lastStep.status = stepData.status;
    }
  } else if (stepData.status === 'failed') {
    isLoading.value = false;
  }
}

// Handle error event
const handleErrorEvent = (errorData: ErrorEventData) => {
  isLoading.value = false;
  messages.value.push({
    type: 'assistant',
    content: {
      content: errorData.error,
      timestamp: errorData.timestamp
    } as MessageContent,
  });
}

// Handle title event
const handleTitleEvent = (titleData: TitleEventData) => {
  title.value = titleData.title;
}

// Handle plan event
const handlePlanEvent = (planData: PlanEventData) => {
  plan.value = planData;
}

// Main event handler function
const handleEvent = (event: AgentSSEEvent) => {
  if (event.event === 'message') {
    handleMessageEvent(event.data as MessageEventData);
  } else if (event.event === 'tool') {
    handleToolEvent(event.data as ToolEventData);
  } else if (event.event === 'step') {
    handleStepEvent(event.data as StepEventData);
  } else if (event.event === 'done') {
    //isLoading.value = false;
  } else if (event.event === 'wait') {
    // TODO: handle wait event
  } else if (event.event === 'error') {
    handleErrorEvent(event.data as ErrorEventData);
  } else if (event.event === 'title') {
    handleTitleEvent(event.data as TitleEventData);
  } else if (event.event === 'plan') {
    handlePlanEvent(event.data as PlanEventData);
  }
  lastEventId.value = event.data.event_id;
}

const handleSubmit = () => {
  chat(inputMessage.value, attachments.value);
}

const chat = async (message: string = '', files: FileInfo[] = []) => {
  if (!sessionId.value) return;

  // Cancel any existing chat connection before starting a new one
  if (cancelCurrentChat.value) {
    cancelCurrentChat.value();
    cancelCurrentChat.value = null;
  }

  if (message.trim()) {
    // Add user message to conversation list
    messages.value.push({
      type: 'user',
      content: {
        content: message,
        timestamp: Math.floor(Date.now() / 1000)
      } as MessageContent,
    });
  }

  if (files.length > 0) {
    messages.value.push({
      type: 'attachments',
      content: {
        role: 'user',
        attachments: files
      } as AttachmentsContent,
    });
  }

  // Automatically enable follow mode when sending message
  follow.value = true;

  // Clear input field
  inputMessage.value = '';
  isLoading.value = true;

  try {
    // Use the split event handler function and store the cancel function
    cancelCurrentChat.value = await agentApi.chatWithSession(
      sessionId.value,
      message,
      lastEventId.value,
      files.map((file: FileInfo) => file.file_id),
      {
        onOpen: () => {
          console.log('Chat opened');
          isLoading.value = true;
        },
        onMessage: ({ event, data }) => {
          handleEvent({
            event: event as AgentSSEEvent['event'],
            data: data as AgentSSEEvent['data']
          });
        },
        onClose: () => {
          console.log('Chat closed');
          isLoading.value = false;
          // Clear the cancel function when connection is closed normally
          if (cancelCurrentChat.value) {
            cancelCurrentChat.value = null;
          }
        },
        onError: (error) => {
          console.error('Chat error:', error);
          isLoading.value = false;
          // Clear the cancel function when there's an error
          if (cancelCurrentChat.value) {
            cancelCurrentChat.value = null;
          }
        }
      }
    );
  } catch (error) {
    console.error('Chat error:', error);
    isLoading.value = false;
    cancelCurrentChat.value = null;
  }
}

const restoreSession = async () => {
  if (!sessionId.value) {
    showErrorToast(t('Session not found'));
    return;
  }
  const session = await agentApi.getSession(sessionId.value);
  realTime.value = false;
  for (const event of session.events) {
    handleEvent(event);
  }
  realTime.value = true;
  if (session.status === SessionStatus.RUNNING || session.status === SessionStatus.PENDING) {
    await chat();
  }
  agentApi.clearUnreadMessageCount(sessionId.value);
}



onBeforeRouteUpdate((to, _, next) => {
  toolPanel.value?.hideToolPanel();
  hideFilePanel();
  resetState();
  if (to.params.sessionId) {
    messages.value = [];
    sessionId.value = String(to.params.sessionId) as string;
    restoreSession();
  }
  next();
})

// Initialize active conversation
onMounted(() => {
  hideFilePanel();
  const routeParams = router.currentRoute.value.params;
  if (routeParams.sessionId) {
    // If sessionId is included in URL, use it directly
    sessionId.value = String(routeParams.sessionId) as string;
    // Get initial message from history.state
    const message = history.state?.message;
    const files: FileInfo[] = history.state?.files;
    history.replaceState({}, document.title);
    if (message) {
      chat(message, files);
    } else {
      restoreSession();
    }
  }


});

onUnmounted(() => {
  if (cancelCurrentChat.value) {
    cancelCurrentChat.value();
    cancelCurrentChat.value = null;
  }
})

const isLastNoMessageTool = (tool: ToolContent) => {
  return tool.tool_call_id === lastNoMessageTool.value?.tool_call_id;
}

const isLiveTool = (tool: ToolContent) => {
  if (tool.status === 'calling') {
    return true;
  }
  if (!isLastNoMessageTool(tool)) {
    return false;
  }
  if (tool.timestamp > Date.now() - 5 * 60 * 1000) {
    return true;
  }
  return false;
}

const handleToolClick = (tool: ToolContent) => {
  realTime.value = false;
  if (sessionId.value) {
    toolPanel.value?.showToolPanel(tool, isLiveTool(tool));
  }
}

const jumpToRealTime = () => {
  realTime.value = true;
  if (lastNoMessageTool.value) {
    toolPanel.value?.showToolPanel(lastNoMessageTool.value, isLiveTool(lastNoMessageTool.value));
  }
}

const handleFollow = () => {
  follow.value = true;
  simpleBarRef.value?.scrollToBottom();
}

const handleScroll = (_: Event) => {
  follow.value = simpleBarRef.value?.isScrolledToBottom() ?? false;
}

const handleStop = () => {
  if (sessionId.value) {
    agentApi.stopSession(sessionId.value);
  }
}

const handleFileListShow = () => {
  showSessionFileList()
}
</script>

<style scoped>
.animate-bounce-dot {
  display: inline-block;
  animation: dot-animation 1.5s infinite;
}

@keyframes dot-animation {
  0% {
    transform: translateY(0);
  }

  20% {
    transform: translateY(-4px);
  }

  40% {
    transform: translateY(0);
  }

  100% {
    transform: translateY(0);
  }
}

.\[\&\:not\(\:empty\)\]\:pb-2:not(:empty) {
  padding-bottom: .5rem;
}
</style>



================================================
FILE: frontend/src/pages/HomePage.vue
================================================
<template>
  <SimpleBar>
    <div
      class="flex flex-col h-full flex-1 min-w-0 mx-auto w-full sm:min-w-[390px] px-5 justify-center items-start gap-2 relative max-w-full sm:max-w-full">
      <div class="w-full pt-4 pb-4 px-5 bg-[var(--background-gray-main)] sticky top-0 z-10 mx-[-1.25]">
        <div class="flex justify-between items-center w-full absolute left-0 right-0">
          <div class="h-8 relative z-20 overflow-hidden flex gap-2 items-center flex-shrink-0">
            <div class="relative flex items-center">
              <div @click="toggleLeftPanel" v-if="!isLeftPanelShow"
                class="flex h-7 w-7 items-center justify-center cursor-pointer rounded-md hover:bg-[var(--fill-tsp-gray-main)]">
                <PanelLeft class="size-5 text-[var(--icon-secondary)]" />
              </div>
            </div>
            <div class="flex">
              <Bot :size="30" />
              <ManusLogoTextIcon />
            </div>
          </div>
          <div class="flex items-center gap-2">
            <div class="relative flex items-center" aria-expanded="false" aria-haspopup="dialog"
                 @mouseenter="handleUserMenuEnter" 
                 @mouseleave="handleUserMenuLeave">
              <div class="relative flex items-center justify-center font-bold cursor-pointer flex-shrink-0">
                <div
                  class="relative flex items-center justify-center font-bold flex-shrink-0 rounded-full overflow-hidden"
                  style="width: 32px; height: 32px; font-size: 16px; color: rgba(255, 255, 255, 0.9); background-color: rgb(59, 130, 246);">
                  {{ avatarLetter }}</div>
              </div>
              <!-- User Menu -->
              <div v-if="showUserMenu" 
                   @mouseenter="handleUserMenuEnter" 
                   @mouseleave="handleUserMenuLeave"
                   class="absolute top-full right-0 mt-1 mr-[-15px] z-50">
                <UserMenu />
              </div>
            </div>
          </div>
        </div>
        <div class="h-8"></div>
      </div>
      <div class="w-full max-w-full sm:max-w-[768px] sm:min-w-[390px] mx-auto mt-[180px] mb-auto">
        <div class="w-full flex pl-4 items-center justify-start pb-4">
          <span class="text-[var(--text-primary)] text-start font-serif text-[32px] leading-[40px]" :style="{
            fontFamily:
              'ui-serif, Georgia, Cambria, &quot;Times New Roman&quot;, Times, serif',
          }">
            {{ $t('Hello') }}, {{ currentUser?.fullname }}
            <br />
            <span class="text-[var(--text-tertiary)]">
              {{ $t('What can I do for you?') }}
            </span>
          </span>
        </div>
        <div class="flex flex-col gap-1 w-full">
          <div class="flex flex-col bg-[var(--background-gray-main)] w-full">
            <div class="[&amp;:not(:empty)]:pb-2 bg-[var(--background-gray-main)] rounded-[22px_22px_0px_0px]">
            </div>
            <ChatBox :rows="2" v-model="message" @submit="handleSubmit" :isRunning="false" :attachments="attachments" />
          </div>
        </div>
      </div>
    </div>
  </SimpleBar>
</template>

<script setup lang="ts">
import SimpleBar from '../components/SimpleBar.vue';
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';
import { useI18n } from 'vue-i18n';
import ChatBox from '../components/ChatBox.vue';
import { createSession } from '../api/agent';
import { showErrorToast } from '../utils/toast';
import { Bot, PanelLeft } from 'lucide-vue-next';
import ManusLogoTextIcon from '../components/icons/ManusLogoTextIcon.vue';
import type { FileInfo } from '../api/file';
import { useLeftPanel } from '../composables/useLeftPanel';
import { useFilePanel } from '../composables/useFilePanel';
import { useAuth } from '../composables/useAuth';
import UserMenu from '../components/UserMenu.vue';

const { t } = useI18n();
const router = useRouter();
const message = ref('');
const isSubmitting = ref(false);
const attachments = ref<FileInfo[]>([]);
const { toggleLeftPanel, isLeftPanelShow } = useLeftPanel();
const { hideFilePanel } = useFilePanel();
const { currentUser } = useAuth();

// Get first letter of user's fullname for avatar display
const avatarLetter = computed(() => {
  return currentUser.value?.fullname?.charAt(0)?.toUpperCase() || 'M';
});

// User menu state
const showUserMenu = ref(false);
const userMenuTimeout = ref<NodeJS.Timeout | null>(null);

// Show user menu on hover
const handleUserMenuEnter = () => {
  if (userMenuTimeout.value) {
    clearTimeout(userMenuTimeout.value);
    userMenuTimeout.value = null;
  }
  showUserMenu.value = true;
};

// Hide user menu with delay
const handleUserMenuLeave = () => {
  userMenuTimeout.value = setTimeout(() => {
    showUserMenu.value = false;
  }, 200); // 200ms delay to allow moving to menu
};

onMounted(() => {
  hideFilePanel();
})

const handleSubmit = async () => {
  if (message.value.trim() && !isSubmitting.value) {
    isSubmitting.value = true;

    try {
      // Create new Agent
      const session = await createSession();
      const sessionId = session.session_id;

      // Navigate to new route with session_id, passing initial message via state
      router.push({
        path: `/chat/${sessionId}`,
        state: {
          message: message.value, files: attachments.value.map((file: FileInfo) => ({
            file_id: file.file_id,
            filename: file.filename,
            content_type: file.content_type,
            size: file.size,
            upload_date: file.upload_date
          }))
        }
      });
    } catch (error) {
      console.error('Failed to create session:', error);
      showErrorToast(t('Failed to create session, please try again later'));
      isSubmitting.value = false;
    }
  }
};
</script>



================================================
FILE: frontend/src/pages/LoginPage.vue
================================================
<template>
  <div class="w-full min-h-[100vh] relative bg-[var(--background-gray-main)] dark:bg-[#050505]">
    <div class="sticky top-0 left-0 w-full z-[10] px-[48px] max-sm:px-[12px] max-sm:bg-[var(--background-gray-login)]">
      <div class="w-full h-[60px] mx-auto flex items-center justify-between text-[var(--text-primary)]">
        <a href="/">
          <div class="flex">
            <Bot :size="30" />
            <ManusLogoTextIcon />
          </div>
        </a>
      </div>
    </div>
    <div
      class="relative z-[1] flex flex-col justify-center items-center min-h-[100vh] pt-[20px] pb-[60px] -mt-[60px] max-sm:pt-[80px] max-sm:pb-[80px] max-sm:mt-0 max-sm:min-h-[calc(100vh-60px)] max-sm:justify-start">
      <div class="w-full max-w-[720px] pt-[24px] mb-[40px] max-sm:pt-[0px]">
        <div class="flex flex-col items-center gap-[20px] relative" style="z-index:1">
          <div class="w-[80px] h-[80px] text-[var(--icon-primary)] max-sm:w-[64px] max-sm:h-[64px]">
            <Bot :size="80" />
          </div>
          <h1 class="text-[20px] font-bold text-center text-[var(--text-primary)] max-sm:text-[18px]">
            {{ 
              isResettingPassword ? t('Reset Password') 
              : isRegistering ? t('Register to Manus') 
              : t('Login to Manus') 
            }}
          </h1>
        </div>
      </div>
      <LoginForm v-if="!isRegistering && !isResettingPassword" 
        @success="handleLoginSuccess" 
        @switch-to-register="switchToRegister" 
        @switch-to-reset="switchToReset" />
      <RegisterForm v-else-if="isRegistering && !isResettingPassword" 
        @success="handleLoginSuccess" 
        @switch-to-login="switchToLogin" />
      <ResetPasswordForm v-else-if="isResettingPassword" 
        @back-to-login="switchToLogin" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import { useRouter } from 'vue-router'
import { useI18n } from 'vue-i18n'
import { Bot } from 'lucide-vue-next'
import ManusLogoTextIcon from '@/components/icons/ManusLogoTextIcon.vue'
import LoginForm from '@/components/login/LoginForm.vue'
import RegisterForm from '@/components/login/RegisterForm.vue'
import ResetPasswordForm from '@/components/login/ResetPasswordForm.vue'
import { useAuth } from '@/api'

const { t } = useI18n()

const router = useRouter()
const { isAuthenticated } = useAuth()

// Form state for header display
const isRegistering = ref(false)
const isResettingPassword = ref(false)

// Switch to register mode
const switchToRegister = () => {
  isRegistering.value = true
  isResettingPassword.value = false
}

// Switch to login mode
const switchToLogin = () => {
  isRegistering.value = false
  isResettingPassword.value = false
}

// Switch to reset password mode
const switchToReset = () => {
  isRegistering.value = false
  isResettingPassword.value = true
}

// Handle successful login/registration
const handleLoginSuccess = () => {
    const redirect = router.currentRoute.value.query.redirect as string
    router.push(redirect || '/')
}

// Listen for authentication state changes
watch(isAuthenticated, (authenticated) => {
  if (authenticated) {
    handleLoginSuccess()
  }
})

// Check if already logged in when page loads
onMounted(() => {
  if (isAuthenticated.value) {
    router.push('/')
  }
})
</script>


================================================
FILE: frontend/src/pages/MainLayout.vue
================================================
<template>
  <div className="h-screen flex overflow-hidden bg-white">
    <LeftPanel />
    <div className="flex-1 min-w-0 h-full py-0 pr-0 relative">
      <div className="flex h-full bg-[var(--background-gray-main)]">
        <div class="flex flex-1 min-w-0 min-h-0">
          <router-view />
          <FilePanel />
        </div>
      </div>
    </div>
  </div>
  <TakeOverView />
  <CustomDialog />
  <SessionFileList />
  <SettingsDialog />
  <ContextMenu />
</template>

<script setup lang="ts">
import LeftPanel from '@/components/LeftPanel.vue';
import CustomDialog from '@/components/ui/CustomDialog.vue';
import ContextMenu from '@/components/ui/ContextMenu.vue';
import TakeOverView from '@/components/TakeOverView.vue';
import SessionFileList from '@/components/SessionFileList.vue';
import FilePanel from '@/components/FilePanel.vue';
import SettingsDialog from '@/components/settings/SettingsDialog.vue';
</script>



================================================
FILE: frontend/src/types/event.ts
================================================
import type { FileInfo } from '../api/file';

export type AgentSSEEvent = {
  event: 'tool' | 'step' | 'message' | 'error' | 'done' | 'title' | 'wait' | 'plan' | 'attachments';
  data: ToolEventData | StepEventData | MessageEventData | ErrorEventData | DoneEventData | TitleEventData | WaitEventData | PlanEventData;
}

export interface BaseEventData {
  event_id: string;
  timestamp: number;
}

export interface ToolEventData extends BaseEventData {
  tool_call_id: string;
  name: string;
  status: "calling" | "called";
  function: string;
  args: {[key: string]: any};
  content?: any;
}

export interface StepEventData extends BaseEventData {
  status: "pending" | "running" | "completed" | "failed"
  id: string
  description: string
}

export interface MessageEventData extends BaseEventData {
  content: string;
  role: "user" | "assistant";
  attachments: FileInfo[];
}

export interface ErrorEventData extends BaseEventData {
  error: string;
}

export interface DoneEventData extends BaseEventData {
}

export interface WaitEventData extends BaseEventData {
}

export interface TitleEventData extends BaseEventData {
  title: string;
}

export interface PlanEventData extends BaseEventData {
  steps: StepEventData[];
}


================================================
FILE: frontend/src/types/message.ts
================================================
import type { FileInfo } from '../api/file';

export type MessageType = "user" | "assistant" | "tool" | "step" | "attachments";

export interface Message {
  type: MessageType;
  content: BaseContent;
}

export interface BaseContent {
  timestamp: number;
}

export interface MessageContent extends BaseContent {
  content: string;
}

export interface ToolContent extends BaseContent {
  tool_call_id: string;
  name: string;
  function: string;
  args: any;
  content?: any;
  status: "calling" | "called";
}

export interface StepContent extends BaseContent {
  id: string;
  description: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  tools: ToolContent[];
}

export interface AttachmentsContent extends BaseContent {
  role: "user" | "assistant";
  attachments: FileInfo[];
}


================================================
FILE: frontend/src/types/panel.ts
================================================
import { Ref } from 'vue'

export interface LeftPanelState {
  isLeftPanelShow: Ref<boolean>
  toggleLeftPanel: () => void
  setLeftPanel: (visible: boolean) => void
  showLeftPanel: () => void
  hideLeftPanel: () => void
} 


================================================
FILE: frontend/src/types/response.ts
================================================
import { AgentSSEEvent } from "./event";

export enum SessionStatus {
    PENDING = "pending",
    RUNNING = "running",
    WAITING = "waiting",
    COMPLETED = "completed"
}

export interface CreateSessionResponse {
    session_id: string;
}

export interface GetSessionResponse {
    session_id: string;
    title: string | null;
    status: SessionStatus;
    events: AgentSSEEvent[];
}

export interface ListSessionItem {
    session_id: string;
    title: string | null;
    latest_message: string | null;
    latest_message_at: number | null;
    status: SessionStatus;
    unread_message_count: number;
}

export interface ListSessionResponse {
    sessions: ListSessionItem[];
}

export interface ConsoleRecord {
    ps1: string;
    command: string;
    output: string;
  }
  
  export interface ShellViewResponse {
    output: string;
    session_id: string;
    console: ConsoleRecord[];
  }

export interface FileViewResponse {
    content: string;
    file: string;
}

export interface SignedUrlResponse {
    signed_url: string;
    expires_in: number;
}
  


================================================
FILE: frontend/src/types/router.d.ts
================================================
// Extend Vue Router's type definitions
import 'vue-router'

declare module 'vue-router' {
  interface RouteMeta {
    // Whether login is required to access this route
    requiresAuth?: boolean
  }
} 


================================================
FILE: frontend/src/types/select.ts
================================================
export interface SelectOption {
  value: any
  label: string
  disabled?: boolean
}

export interface SelectProps {
  modelValue?: any
  options: SelectOption[] | string[] | number[]
  width?: string
  height?: string
  placeholder?: string
  placement?: 'top' | 'bottom' // Currently only 'bottom' is implemented
  buttonClass?: string
  selectClass?: string
  textClass?: string
  optionClass?: string
  valueKey?: string
  labelKey?: string
}

export interface SelectEmits {
  'update:modelValue': [value: any]
  'change': [value: any]
}



================================================
FILE: frontend/src/utils/auth.ts
================================================
// Authentication utility functions
import type { User, UserRole } from '../api/auth'
import { i18n } from '../composables/useI18n'


/**
 * Get user display name
 */
export function getUserDisplayName(user: User | null): string {
  if (!user) return 'Guest'
  return user.fullname || user.email || 'Unknown User'
}

/**
 * Get user role display name
 */
export function getRoleDisplayName(role: UserRole): string {
  const roleNames: Record<UserRole, string> = {
    admin: 'Administrator',
    user: 'User'
  }
  return roleNames[role] || role
}

/**
 * Check if user account is expired or needs attention
 */
export function getUserAccountStatus(user: User | null): {
  isValid: boolean
  isActive: boolean
  needsAttention: boolean
  message?: string
} {
  if (!user) {
    return {
      isValid: false,
      isActive: false,
      needsAttention: true,
      message: 'No user data available'
    }
  }
  
  if (!user.is_active) {
    return {
      isValid: false,
      isActive: false,
      needsAttention: true,
      message: 'Account is deactivated'
    }
  }
  
  return {
    isValid: true,
    isActive: true,
    needsAttention: false
  }
}

/**
 * Format user creation date
 */
export function formatUserDate(dateString: string): string {
  try {
    const date = new Date(dateString)
    return date.toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  } catch (error) {
    return 'Invalid date'
  }
}

/**
 * Generate user avatar URL or initials
 */
export function getUserAvatar(user: User | null): {
  type: 'initials' | 'url'
  value: string
} {
  if (!user) {
    return {
      type: 'initials',
      value: 'G'
    }
  }
  
  // Generate initials from fullname or email
  const name = user.fullname || user.email || 'U'
  const initials = name
    .split(/[\s@]/)
    .map((part: string) => part.charAt(0).toUpperCase())
    .slice(0, 2)
    .join('')
  
  return {
    type: 'initials',
    value: initials || 'U'
  }
}

/**
 * Validate user input for registration/profile update
 */
export function validateUserInput(data: {
  fullname?: string
  email?: string
  password?: string
}): {
  isValid: boolean
  errors: Record<string, string>
} {
  const errors: Record<string, string> = {}
  
  // Full name validation
  if (data.fullname !== undefined) {
    if (!data.fullname || data.fullname.trim().length < 2) {
      errors.fullname = i18n.global.t('Full name must be at least 2 characters long')
    } else if (data.fullname.trim().length > 100) {
      errors.fullname = i18n.global.t('Full name must be less than 100 characters')
    }
  }
  
  // Email validation
  if (data.email !== undefined) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!data.email || !emailRegex.test(data.email)) {
      errors.email = i18n.global.t('Please enter a valid email address')
    }
  }
  
  // Password validation
  if (data.password !== undefined) {
    if (!data.password || data.password.length < 6) {
      errors.password = i18n.global.t('Password must be at least 6 characters long')
    }
  }
  
  return {
    isValid: Object.keys(errors).length === 0,
    errors
  }
} 


================================================
FILE: frontend/src/utils/dom.ts
================================================
/**
 * Get parent element by selector or element
 * @param selector - CSS selector or HTMLElement or Element
 * @param parentSelector - Optional parent selector to find specific parent
 * @returns Parent element or null if not found
 */
export function getParentElement(
  selector: string | HTMLElement | Element,
  parentSelector?: string
): HTMLElement | null {
  let element: Element | null = null

  // Handle both string selector and HTMLElement/Element
  if (typeof selector === 'string') {
    element = document.querySelector(selector)
  } else {
    element = selector
  }

  if (!element) {
    console.warn(`Could not find element: ${typeof selector === 'string' ? selector : 'provided element'}`)
    return null
  }

  // If parentSelector is provided, find specific parent
  if (parentSelector) {
    const parent = element.closest(parentSelector)
    if (!parent) {
      console.warn(`Could not find parent element with selector: ${parentSelector}`)
      return null
    }
    return parent as HTMLElement
  }

  // Get immediate parent
  const parent = element.parentElement
  if (!parent) {
    console.warn('Could not find parent element')
    return null
  }

  return parent
}

 


================================================
FILE: frontend/src/utils/eventBus.ts
================================================
import mitt from 'mitt'

export const eventBus = mitt();


================================================
FILE: frontend/src/utils/fileType.ts
================================================
import type { Component } from 'vue';
import { useI18n } from 'vue-i18n';
import FileIcon from '../components/icons/FileIcon.vue';
import CodeFileIcon from '../components/icons/CodeFileIcon.vue';
import UnknownFilePreview from '../components/filePreviews/UnknownFilePreview.vue';
import MarkdownFilePreview from '../components/filePreviews/MarkdownFilePreview.vue';
import CodeFilePreview from '../components/filePreviews/CodeFilePreview.vue';
import ImageFilePreview from '../components/filePreviews/ImageFilePreview.vue';

export interface FileType {
  icon: Component;
  preview: Component;
}

const codeFileExtensions = [
  'py', 'js', 'ts', 'jsx', 'tsx', 'vue',
  'java', 'c', 'cpp', 'h', 'hpp',
  'go', 'rust', 'php', 'ruby', 'swift',
  'kotlin', 'scala', 'haskell', 'erlang', 'elixir',
  'ocaml', 'fsharp', 'dart', 'julia',
  'lua', 'perl', 'r', 'sh', 'bash',
  'css', 'scss', 'sass', 'less', 'txt',
  'html', 'xml', 'json', 'yaml', 'yml',
  'sql', 'dockerfile', 'toml', 'ini', 'conf',
];

const imageFileExtensions = [
  'jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico', 'tiff', 'tif', 'heic', 'heif',
];

const documentFileExtensions = [
  'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'odt', 'ods', 'odp',
];

const videoFileExtensions = [
  'mp4', 'avi', 'mov', 'wmv', 'flv', 'webm', 'mkv', '3gp', 'ogv',
];

const audioFileExtensions = [
  'mp3', 'wav', 'flac', 'aac', 'ogg', 'wma', 'm4a', 'opus',
];

const archiveFileExtensions = [
  'zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz', 'lzma',
];

export const getFileType = (filename: string): FileType => {
  const file_extension = filename.split('.').pop()?.toLowerCase();
  
  if (file_extension === 'md') {
    return {
      icon: FileIcon,
      preview: MarkdownFilePreview,
    };
  }
  
  if (file_extension && codeFileExtensions.includes(file_extension)) {
    return {
      icon: CodeFileIcon,
      preview: CodeFilePreview,
    };
  }

  if (file_extension && imageFileExtensions.includes(file_extension)) {
    return {
      icon: FileIcon,
      preview: ImageFilePreview,
    };
  }
  
  return {
    icon: FileIcon,
    preview: UnknownFilePreview,
  };
};

/**
 * Get file type text based on file extension
 * @param filename - The filename to analyze
 * @returns Localized description of file type
 */
export const getFileTypeText = (filename: string): string => {
  const { t } = useI18n();
  const file_extension = filename.split('.').pop()?.toLowerCase();
  
  if (!file_extension) {
    return t('File');
  }

  // Text files
  if (file_extension === 'txt') {
    return t('Text');
  }

  // Markdown files
  if (file_extension === 'md') {
    return t('Markdown');
  }

  // Code files
  if (codeFileExtensions.includes(file_extension)) {
    return t('Code');
  }

  // Image files
  if (imageFileExtensions.includes(file_extension)) {
    return t('Image');
  }

  // Document files
  if (file_extension === 'pdf') {
    return t('PDF');
  }
  if (['doc', 'docx'].includes(file_extension)) {
    return t('Word');
  }
  if (['xls', 'xlsx'].includes(file_extension)) {
    return t('Excel');
  }
  if (['ppt', 'pptx'].includes(file_extension)) {
    return t('PowerPoint');
  }
  if (documentFileExtensions.includes(file_extension)) {
    return t('Document');
  }

  // Video files
  if (videoFileExtensions.includes(file_extension)) {
    return t('Video');
  }

  // Audio files
  if (audioFileExtensions.includes(file_extension)) {
    return t('Audio');
  }

  // Archive files
  if (archiveFileExtensions.includes(file_extension)) {
    return t('Archive');
  }

  // Default
  return t('File');
};

/**
 * Format file size from bytes to human readable format
 * @param bytes - File size in bytes
 * @param decimals - Number of decimal places (default: 1)
 * @returns Formatted file size string
 */
export function formatFileSize(bytes: number, decimals: number = 1): string {
  if (bytes === 0) return '0 B';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
} 


================================================
FILE: frontend/src/utils/time.ts
================================================
import { useI18n } from 'vue-i18n';

/**
 * Time related utility functions
 */


/**
 * Convert ISO 8601 datetime string to timestamp number
 * @param isoString ISO 8601 datetime string (e.g., "2025-06-22T04:42:11.842000")
 * @returns Timestamp number in seconds
 */
export const parseISODateTime = (isoString: string): number => {
  try {
    const date = new Date(isoString);
    
    if (isNaN(date.getTime())) {
      throw new Error('Invalid ISO datetime string');
    }
    
    return Math.floor(date.getTime() / 1000);
  } catch (error) {
    throw new Error(`Failed to parse ISO datetime string: ${isoString}`);
  }
};

/**
 * Convert timestamp to relative time (e.g., minutes ago, hours ago, days ago)
 * @param timestamp Timestamp (seconds)
 * @returns Formatted relative time string
 */
export const formatRelativeTime = (timestamp: number): string => {
  const { t } = useI18n();
  const now = Math.floor(Date.now() / 1000);
  const diffSec = now - timestamp;
  const diffMin = Math.floor(diffSec / 60);
  const diffHour = Math.floor(diffMin / 60);
  const diffDay = Math.floor(diffHour / 24);
  const diffMonth = Math.floor(diffDay / 30);
  const diffYear = Math.floor(diffMonth / 12);

  if (diffSec < 60) {
    return t('Just now');
  } else if (diffMin < 60) {
    return `${diffMin} ${t('minutes ago')}`;
  } else if (diffHour < 24) {
    return `${diffHour} ${t('hours ago')}`;
  } else if (diffDay < 30) {
    return `${diffDay} ${t('days ago')}`;
  } else if (diffMonth < 12) {
    return `${diffMonth} ${t('months ago')}`;
  } else {
    return `${diffYear} ${t('years ago')}`;
  }
};

/**
 * Format timestamp according to custom requirements:
 * - Today: show time (HH:MM)
 * - This week: show day of week (e.g., 周一)
 * - This year: show date (MM/DD)
 * - Other years: show year/month (YYYY/MM)
 * @param timestamp Timestamp (seconds)
 * @param t Translation function from i18n
 * @param locale Current locale (for date formatting)
 * @returns Formatted time string
 */
export const formatCustomTime = (timestamp: number, t?: (key: string) => string, locale?: string): string => {
  const date = new Date(timestamp * 1000);
  const now = new Date();
  
  // Check if it's today
  const isToday = date.toDateString() === now.toDateString();
  if (isToday) {
    // Use locale-appropriate time format
    const timeFormat = locale?.startsWith('zh') ? 'zh-CN' : 'en-US';
    return date.toLocaleTimeString(timeFormat, {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  }
  
  // Check if it's this week
  const startOfWeek = new Date(now);
  startOfWeek.setDate(now.getDate() - now.getDay() + 1); // Monday as start of week
  startOfWeek.setHours(0, 0, 0, 0);
  
  const endOfWeek = new Date(startOfWeek);
  endOfWeek.setDate(startOfWeek.getDate() + 6);
  endOfWeek.setHours(23, 59, 59, 999);
  
  if (date >= startOfWeek && date <= endOfWeek) {
    const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    if (t) {
      return t(weekdays[date.getDay()]);
    } else {
      return weekdays[date.getDay()];
    }
  }
  
  // Check if it's this year
  const isThisYear = date.getFullYear() === now.getFullYear();
  if (isThisYear) {
    // Use locale-appropriate date format
    if (locale?.startsWith('zh')) {
      return `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
    } else {
      // For English and other locales, use MM/DD format
      return `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
    }
  }
  
  // Other years: show year/month
  return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}`;
}; 


================================================
FILE: frontend/src/utils/toast.ts
================================================
/**
 * Toast service
 * Provide global Toast message notification functionality
 */

type ToastType = 'error' | 'info' | 'success';

interface ToastOptions {
  message: string;
  type?: ToastType;
  duration?: number;
}

/**
 * Show Toast message
 * @param options - Toast configuration or message string
 */
export function showToast(options: ToastOptions | string): void {
  let config: ToastOptions;
  
  if (typeof options === 'string') {
    config = { message: options };
  } else {
    config = options;
  }
  
  // Default configuration
  const detail = {
    message: config.message,
    type: config.type || 'info',
    duration: config.duration === undefined ? 3000 : config.duration
  };
  
  // Create custom event
  const event = new CustomEvent('toast', { detail });
  
  // Trigger event
  window.dispatchEvent(event);
}

// Convenient methods
export function showErrorToast(message: string, duration?: number): void {
  showToast({ message, type: 'error', duration });
}

export function showInfoToast(message: string, duration?: number): void {
  showToast({ message, type: 'info', duration });
}

export function showSuccessToast(message: string, duration?: number): void {
  showToast({ message, type: 'success', duration });
}

// To support non-Vue page calls, add to global window object
declare global {
  interface Window {
    toast: {
      show: typeof showToast;
      error: typeof showErrorToast;
      info: typeof showInfoToast;
      success: typeof showSuccessToast;
    };
  }
}

// Mount to window object
if (typeof window !== 'undefined') {
  window.toast = {
    show: showToast,
    error: showErrorToast,
    info: showInfoToast,
    success: showSuccessToast
  };
} 


================================================
FILE: mockserver/dev.sh
================================================
#!/bin/bash

# Start uvicorn server with hot reload
exec uvicorn main:app --host 0.0.0.0 --port 8090 --reload 


================================================
FILE: mockserver/Dockerfile
================================================
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8090

CMD ["./dev.sh"] 


================================================
FILE: mockserver/main.py
================================================
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import json
import yaml
from typing import List, Optional, Dict, Any
import os
from pathlib import Path
import asyncio
import logging
import sys

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

app = FastAPI()

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class Message(BaseModel):
    role: str
    content: Optional[str] = None
    tool_calls: Optional[List[Dict[str, Any]]] = None

class ChatCompletionRequest(BaseModel):
    model: str
    messages: List[Message]
    temperature: Optional[float] = 0.7
    max_tokens: Optional[int] = None
    stream: Optional[bool] = False

class ChatCompletionResponse(BaseModel):
    #id: str
    #object: str
    #created: int
    #model: str
    choices: List[Dict[str, Any]]

def load_mock_data():
    # Get mock data filename from environment variable, default to default.yaml
    mock_file = os.getenv("MOCK_DATA_FILE", "default.yaml")
    mock_file_path = Path(__file__).parent / "mock_datas" / mock_file

    with open(mock_file_path, 'r', encoding='utf-8') as f:
        logger.info(f"Loading mock data from {mock_file}")
        if mock_file.endswith('.json'):
            return json.load(f)
        else:
            return yaml.safe_load(f)

current_index = 0

@app.post("/v1/chat/completions", response_model=ChatCompletionResponse)
async def chat_completions(request: ChatCompletionRequest):
    global current_index
    mock_data = load_mock_data()
    if not mock_data:
        current_index = 0
        logger.error("No mock data available")
        raise HTTPException(status_code=500, detail="No mock data available")

    if len(request.messages) == 2 and current_index > 1:
        current_index = 0
        logger.info("Reset index to 0")
    
    delay = float(os.getenv("MOCK_DELAY", "1"))
    if delay > 0:
        logger.debug(f"Applying mock delay of {delay} seconds")
        await asyncio.sleep(delay)
    
    response = mock_data[current_index]
    current_index = (current_index + 1) % len(mock_data)
    logger.info(f"Returning mock response {current_index}/{len(mock_data)}")
    return response



================================================
FILE: mockserver/requirements.txt
================================================
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.4.2
PyYAML==6.0.1 


================================================
FILE: mockserver/mock_datas/browser_tools.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test browser tools"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_navigate
              arguments: |
                {
                    "url": "https://www.example.com"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_view
              arguments: |
                {}

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_click
              arguments: |
                {
                    "index": 0
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_input
              arguments: |
                {
                    "text": "search query",
                    "press_enter": true,
                    "index": 0
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_move_mouse
              arguments: |
                {
                    "coordinate_x": 100,
                    "coordinate_y": 200
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_press_key
              arguments: |
                {
                    "key": "Control+A"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_select_option
              arguments: |
                {
                    "index": 0,
                    "option": 2
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_scroll_up
              arguments: |
                {
                    "to_top": true
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_scroll_down
              arguments: |
                {
                    "to_bottom": true
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_console_exec
              arguments: |
                {
                    "javascript": "console.log('Hello from console!')"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_console_view
              arguments: |
                {
                    "max_lines": 10
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          test file end

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }


================================================
FILE: mockserver/mock_datas/default.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test step"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: message_notify_user
              arguments: |
                {
                    "text": "test message tools."
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: info_search_web
              arguments: |
                {
                    "query": "latest AI developments 2024",
                    "date_range": "past_month"
                }
      finish_reason: stop
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_write
              arguments: |
                {
                    "file": "/home/ubuntu/example.txt",
                    "content": "New content\nSecond line",
                    "append": false,
                    "leading_newline": true,
                    "trailing_newline": true
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_write
              arguments: |
                {
                    "file": "/home/ubuntu/example.md",
                    "content": "## Header\n\nThis is a test\n\n### Subheader",
                    "append": false,
                    "leading_newline": true,
                    "trailing_newline": true
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_write
              arguments: |
                {
                    "file": "/home/ubuntu/example.py",
                    "content": "print('Hello, World!')",
                    "append": false,
                    "leading_newline": true,
                    "trailing_newline": true
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_exec
              arguments: |
                {
                    "id": "shell-1",
                    "exec_dir": "/home/ubuntu",
                    "command": "ls -a"
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: browser_navigate
              arguments: |
                {
                    "url": "https://www.example.com"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "success": true,
            "result": "test end",
            "attachments": [
              "/home/ubuntu/example.txt",
              "/home/ubuntu/example.md",
              "/home/ubuntu/example.py"
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }
      finish_reason: stop

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "attachments": [
              "/home/ubuntu/example.txt",
              "/home/ubuntu/example.md",
              "/home/ubuntu/example.py"
            ]
          }



================================================
FILE: mockserver/mock_datas/file_tools.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test file tools"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_write
              arguments: |
                {
                    "file": "/home/ubuntu/example.txt",
                    "content": "New content\nSecond line",
                    "append": false,
                    "leading_newline": true,
                    "trailing_newline": true
                }


- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_read
              arguments: |
                {
                    "file": "/home/ubuntu/example.txt",
                    "start_line": 0,
                    "end_line": 10
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_str_replace
              arguments: |
                {
                    "file": "/home/ubuntu/example.txt",
                    "old_str": "old text",
                    "new_str": "new text"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_find_in_content
              arguments: |
                {
                    "file": "/home/ubuntu/example.txt",
                    "regex": "pattern.*"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: file_find_by_name
              arguments: |
                {
                    "path": "/home/ubuntu",
                    "glob": "*.txt"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          test file end

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }



================================================
FILE: mockserver/mock_datas/message_tools.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test message tools"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: message_notify_user
              arguments: |
                {
                    "text": "Task is in progress, please wait..."
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          test message end

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }



================================================
FILE: mockserver/mock_datas/search_tools.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test search tools"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: info_search_web
              arguments: |
                {
                    "query": "latest AI developments 2024",
                    "date_range": "past_month"
                }
      finish_reason: stop

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          test message end

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }


================================================
FILE: mockserver/mock_datas/shell_tools.yaml
================================================
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "message": "This is a test",
            "goal": "test goal",
            "title": "test title",
            "steps": [
              {
                "id": "1",
                "description": "test shell tools"
              }
            ]
          }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_exec
              arguments: |
                {
                    "id": "shell-1",
                    "exec_dir": "/home/ubuntu",
                    "command": "ls -la"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_view
              arguments: |
                {
                    "id": "shell-1"
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_wait
              arguments: |
                {
                    "id": "shell-1",
                    "seconds": 10
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_write_to_process
              arguments: |
                {
                    "id": "shell-1",
                    "input": "y",
                    "press_enter": true
                }

- choices:
    - index: 0
      message:
        role: assistant
        content: null
        tool_calls:
          - type: function
            function:
              name: shell_kill_process
              arguments: |
                {
                    "id": "shell-1"
                }
- choices:
    - index: 0
      message:
        role: assistant
        content: |
          test file end

- choices:
    - index: 0
      message:
        role: assistant
        content: |
          {
            "steps": []
          }


================================================
FILE: sandbox/README.md
================================================
[Binary file]


================================================
FILE: sandbox/Dockerfile
================================================
FROM ubuntu:22.04

# Avoid interactive prompts during installation
ENV DEBIAN_FRONTEND=noninteractive

# Set hostname to sandbox
ENV HOSTNAME=sandbox

# Configure apt source to use Aliyun mirror
RUN sed -i 's|http://archive.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g' /etc/apt/sources.list && \
    sed -i 's|http://security.ubuntu.com/ubuntu/|http://mirrors.aliyun.com/ubuntu/|g' /etc/apt/sources.list && \
    sed -i 's|http://ports.ubuntu.com/ubuntu-ports/|http://mirrors.aliyun.com/ubuntu-ports/|g' /etc/apt/sources.list

# Update and install basic tools
RUN apt-get update && apt-get install -y \
    sudo \
    bc \
    curl \
    wget \
    gnupg \
    software-properties-common \
    xvfb \
    x11vnc \
    xterm \
    socat \
    supervisor \
    websockify \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Create user ubuntu and grant sudo privileges
RUN useradd -m -d /home/ubuntu -s /bin/bash ubuntu && \
    echo "ubuntu ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/ubuntu

# Install Python 3.10.12
RUN add-apt-repository ppa:deadsnakes/ppa && \
    apt-get update && \
    apt-get install -y python3.10 python3.10-venv python3.10-dev python3-pip && \
    update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 1 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Configure pip to use Aliyun mirror
RUN pip3 config set global.index-url https://mirrors.aliyun.com/pypi/simple/

# Install Node.js 20.18.0
RUN mkdir -p /etc/apt/keyrings && \
    curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg && \
    echo "deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main" | tee /etc/apt/sources.list.d/nodesource.list && \
    apt-get update && \
    apt-get install -y nodejs && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Configure npm to use Aliyun mirror
RUN npm config set registry https://registry.npmmirror.com

# Install Google Chrome
RUN add-apt-repository ppa:xtradeb/apps -y && \
    apt-get update && \
    apt-get install -y chromium  --no-install-recommends && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Install Chinese fonts and language support
RUN apt-get update && apt-get install -y \
    fonts-noto-cjk \
    fonts-noto-color-emoji \
    language-pack-zh-hans \
    locales \
    && locale-gen zh_CN.UTF-8 \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Set default locale
#ENV LANG=zh_CN.UTF-8 \
#    LANGUAGE=zh_CN:zh \
#    LC_ALL=zh_CN.UTF-8

# Set working directory
WORKDIR /app

# Copy project files (copy dependency files first to leverage cache)
COPY requirements.txt .

# Install Python dependencies
RUN pip3 install --no-cache-dir -r requirements.txt

# Copy remaining project files
COPY . .

# Configure supervisor
COPY supervisord.conf /etc/supervisor/conf.d/app.conf

# Expose ports
EXPOSE 8080 9222 5900 5901

ENV UVI_ARGS=""
ENV CHROME_ARGS=""

# Use supervisor to start all services
CMD ["supervisord", "-n", "-c", "/app/supervisord.conf"] 



================================================
FILE: sandbox/pytest.ini
================================================
[pytest]
log_cli = true
log_cli_level = info
log_cli_format = %(asctime)s %(filename)s:%(lineno)s [%(levelname)s]: %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --color=yes
    --durations=10
markers =
    file_api: marks tests for file API
filterwarnings =
    ignore::DeprecationWarning
    ignore::PendingDeprecationWarning 


================================================
FILE: sandbox/README_zh.md
================================================
# AI Manus 沙盒服务

[English](README.md) | 中文

AI Manus 沙盒是一个基于Docker容器的隔离执行环境，为 AI Agent 提供安全的 Shell 命令执行、文件操作和浏览器自动化能力。该服务通过 FastAPI 提供API接口，支持与后端服务交互。

## 技术架构

沙盒服务集成多项技术，提供 AI Agent 操作环境：

```
sandbox/
├── app/                   # 应用主目录
│   ├── api/               # API接口定义
│   │   └── v1/            # API版本 v1
│   │       ├── shell.py   # Shell命令执行接口
│   │       ├── file.py    # 文件操作接口
│   │       └── supervisor.py # 进程管理接口
│   ├── services/          # 服务实现
│   ├── schemas/           # FastAPI 接口模型
│   ├── models/            # 数据模型
│   ├── core/              # 核心配置
│   └── main.py            # 应用入口
├── Dockerfile             # Docker构建文件
├── requirements.txt       # Python依赖
├── supervisord.conf       # Supervisor配置
└── README.md              # 文档
```

## 核心功能

沙盒环境提供以下核心功能：

1. **Shell 命令执行**：安全地执行 Shell 命令，支持会话管理
2. **文件操作**：读取、写入、搜索和操作文件系统
3. **浏览器环境**：
   - 内置 Google Chrome 浏览器
   - 支持 Chrome DevTools Protocol
   - 提供远程调试接口
4. **VNC 远程访问**：
   - VNC 远程桌面服务
   - WebSocket 接口
5. **进程管理**：通过 Supervisor 管理各组件进程

## 运行环境要求

- Python 3.9+
- Docker 20.10+

## 安装配置

### 本地开发环境

1. **创建虚拟环境**：
```bash
python -m venv .venv
source .venv/bin/activate
```

2. **安装依赖**：
```bash
pip install -r requirements.txt
```


3. **启动开发服务器**：
```bash
uvicorn app.main:app --host 0.0.0.0 --port 8080 --reload
```

### Docker部署

```bash
# 构建镜像
docker build -t manus-sandbox .

# 运行容器
docker run -p 8080:8080 -p 9222:9222 -p 5900:5900 -p 5901:5901 manus-sandbox
```

## 端口说明

- **8080**: FastAPI 服务端口
- **9222**: Chrome 远程调试端口
- **5900**: VNC 服务端口
- **5901**: VNC WebSocket 端口

## 配置说明

沙盒服务支持以下配置项，可通过环境变量或`.env`文件设置：

- **ORIGINS**: 允许的CORS源列表，默认为`["*"]`。可设置为逗号分隔的字符串或JSON数组。
- **SERVICE_TIMEOUT_MINUTES**: 服务超时时间（分钟），默认为无限制。设置后服务将在指定时间后自动终止。
- **LOG_LEVEL**: 日志级别，可设置为`DEBUG`、`INFO`、`WARNING`、`ERROR`或`CRITICAL`，默认为`INFO`。

示例`.env`文件：
```
ORIGINS=http://localhost:3000,https://example.com
SERVICE_TIMEOUT_MINUTES=60
LOG_LEVEL=DEBUG
```

## API接口文档

基础URL: `/api/v1`

### 1. Shell相关接口

#### 执行Shell命令

- **接口**: `POST /api/v1/shell/exec`
- **描述**: 在指定的 shell 会话中执行命令
- **请求体**:

  ```json
  {
    "id": "session_id",  /* 可选，不提供则自动创建会话ID */
    "exec_dir": "/path/to/dir",  /* 可选，命令执行的工作目录（必须使用绝对路径） */
    "command": "ls -la"  /* 要执行的命令 */
  }
  ```


- **响应**:
  ```json
  {
    "success": true,
    "message": "Command executed",
    "data": {
      "session_id": "session_id",
      "command": "ls -la",
      "status": "running"
    }
  }
  ```

#### 查看 Shell 会话内容

- **接口**: `POST /api/v1/shell/view`
- **描述**: 查看指定 shell 会话的输出内容
- **请求体**:
  ```json
  {
    "id": "session_id"  /* 目标会话ID */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Session content retrieved successfully",
    "data": {
      "output": "会话输出内容",
      "session_id": "session_id",
      "console": [
        {
          "ps1": "user@host:~/dir $",
          "command": "ls -la",
          "output": "文件列表输出"
        }
      ]
    }
  }
  ```

#### 等待进程

- **接口**: `POST /api/v1/shell/wait`
- **描述**: 等待指定会话中的进程完成
- **请求体**:
  ```json
  {
    "id": "session_id",  /* 目标会话ID */
    "seconds": 10  /* 可选，等待时间（秒） */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Process completed, return code: 0",
    "data": {
      "session_id": "session_id",
      "returncode": 0,
      "status": "completed"
    }
  }
  ```

#### 写入输入

- **接口**: `POST /api/v1/shell/write`
- **描述**: 向指定会话中的进程写入输入
- **请求体**:
  ```json
  {
    "id": "session_id",  /* 目标会话ID */
    "input": "example input",  /* 写入的内容 */
    "press_enter": true  /* 是否在输入后模拟按下回车键 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Input written",
    "data": {
      "session_id": "session_id",
      "input": "example input"
    }
  }
  ```

#### 终止进程

- **接口**: `POST /api/v1/shell/kill`
- **描述**: 终止指定会话中的进程
- **请求体**:
  ```json
  {
    "id": "session_id"  /* 目标会话ID */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Process terminated",
    "data": {
      "session_id": "session_id",
      "status": "terminated"
    }
  }
  ```

### 2. 文件操作接口

#### 读取文件

- **接口**: `POST /api/v1/file/read`
- **描述**: 读取指定文件内容
- **请求体**:
  ```json
  {
    "file": "/path/to/file",  /* 文件绝对路径 */
    "start_line": 0,  /* 可选，起始行（从0开始计数） */
    "end_line": 100,  /* 可选，结束行（不包含该行） */
    "sudo": false  /* 可选，是否使用sudo权限读取 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "File read successfully",
    "data": {
      "content": "文件内容",
      "line_count": 100,
      "file": "/path/to/file"
    }
  }
  ```

#### 写入文件

- **接口**: `POST /api/v1/file/write`
- **描述**: 写入内容到指定文件
- **请求体**:
  ```json
  {
    "file": "/path/to/file",  /* 文件绝对路径 */
    "content": "文件内容",  /* 要写入的内容 */
    "append": false,  /* 可选，是否使用追加模式 */
    "leading_newline": false,  /* 可选，是否在内容前添加换行符 */
    "trailing_newline": false,  /* 可选，是否在内容后添加换行符 */
    "sudo": false  /* 可选，是否使用sudo权限写入 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "File written successfully",
    "data": {
      "file": "/path/to/file",
      "bytes_written": 123
    }
  }
  ```

#### 替换文件内容

- **接口**: `POST /api/v1/file/replace`
- **描述**: 替换文件中的字符串
- **请求体**:
  ```json
  {
    "file": "/path/to/file",  /* 文件绝对路径 */
    "old_str": "原字符串",  /* 要替换的原始字符串 */
    "new_str": "新字符串",  /* 替换后的新字符串 */
    "sudo": false  /* 可选，是否使用sudo权限 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Replacement completed, replaced 5 occurrences",
    "data": {
      "file": "/path/to/file",
      "replaced_count": 5
    }
  }
  ```

#### 搜索文件内容

- **接口**: `POST /api/v1/file/search`
- **描述**: 使用正则表达式搜索文件内容
- **请求体**:
  ```json
  {
    "file": "/path/to/file",  /* 文件绝对路径 */
    "regex": "search pattern",  /* 正则表达式模式 */
    "sudo": false  /* 可选，是否使用sudo权限 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Search completed, found 3 matches",
    "data": {
      "file": "/path/to/file",
      "matches": [
        {
          "line_number": 10,
          "line": "匹配的行内容",
          "match": "匹配的内容"
        }
      ]
    }
  }
  ```

#### 查找文件

- **接口**: `POST /api/v1/file/find`
- **描述**: 根据文件名模式查找文件
- **请求体**:
  ```json
  {
    "path": "/path/to/dir",  /* 要搜索的目录路径 */
    "glob": "*.txt"  /* 文件名模式（glob语法） */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Search completed, found 5 files",
    "data": {
      "files": [
        "/path/to/dir/file1.txt",
        "/path/to/dir/file2.txt"
      ]
    }
  }
  ```

### 3. 进程管理接口

#### 获取进程状态

- **接口**: `GET /api/v1/supervisor/status`
- **描述**: 获取所有服务进程状态
- **响应**:
  ```json
  {
    "success": true,
    "message": "Services status retrieved successfully",
    "data": [
      {
        "name": "chrome",
        "status": "RUNNING",
        "description": "pid 123, uptime 10:30:45"
      }
    ]
  }
  ```

#### 停止所有服务

- **接口**: `POST /api/v1/supervisor/stop`
- **描述**: 停止所有服务
- **响应**:
  ```json
  {
    "success": true,
    "message": "All services stopped",
    "data": {
      "status": "stopped"
    }
  }
  ```

#### 关闭 Supervisor

- **接口**: `POST /api/v1/supervisor/shutdown`
- **描述**: 仅关闭 supervisord 服务本身
- **响应**:
  ```json
  {
    "success": true,
    "message": "Supervisord service shutdown",
    "data": {
      "status": "shutdown"
    }
  }
  ```

#### 重启所有服务

- **接口**: `POST /api/v1/supervisor/restart`
- **描述**: 重启所有服务
- **响应**:
  ```json
  {
    "success": true,
    "message": "All services restarted",
    "data": {
      "status": "restarted"
    }
  }
  ```

#### 激活超时

- **接口**: `POST /api/v1/supervisor/timeout/activate`
- **描述**: 重置超时功能，在指定时间后自动关闭所有服务
- **请求体**:
  ```json
  {
    "minutes": 60  /* 可选，超时时间（分钟），若不提供则使用系统默认配置 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Timeout reset, all services will be shut down after 60 minutes",
    "data": {
      "timeout_minutes": 60,
      "timeout_timestamp": "2023-07-01T12:34:56",
      "status": "timeout_set"
    }
  }
  ```

#### 延长超时

- **接口**: `POST /api/v1/supervisor/timeout/extend`
- **描述**: 延长超时时间
- **请求体**:
  ```json
  {
    "minutes": 30  /* 可选，延长的分钟数，若不提供则使用系统默认配置 */
  }
  ```
- **响应**:
  ```json
  {
    "success": true,
    "message": "Timeout extended, all services will be shut down after 90 minutes",
    "data": {
      "timeout_minutes": 90,
      "timeout_timestamp": "2023-07-01T14:04:56",
      "status": "timeout_extended"
    }
  }
  ```

#### 取消超时

- **接口**: `POST /api/v1/supervisor/timeout/cancel`
- **描述**: 取消超时功能
- **响应**:
  ```json
  {
    "success": true,
    "message": "Timeout cancelled",
    "data": {
      "status": "timeout_cancelled"
    }
  }
  ```

#### 获取超时状态

- **接口**: `GET /api/v1/supervisor/timeout/status`
- **描述**: 获取超时功能的状态
- **响应**:
  ```json
  {
    "success": true,
    "message": "Remaining time: 45 minutes",
    "data": {
      "active": true,
      "timeout_timestamp": "2023-07-01T14:04:56",
      "remaining_seconds": 2700
    }
  }
  ```

## 容器环境配置

沙盒容器内置以下环境：

- Ubuntu 22.04
- Python 3.10
- Node.js 20.18.0
- Google Chrome

## 调试指南

### 浏览器调试

1. 通过VNC客户端连接`localhost:5900`
2. 在浏览器中访问`http://localhost:9222/devtools/inspector.html`


================================================
FILE: sandbox/requirements.txt
================================================
fastapi
uvicorn
pydantic
email-validator
python-multipart
pydantic-settings


================================================
FILE: sandbox/supervisord.conf
================================================
[unix_http_server]
file=/tmp/supervisor.sock   ; Path of UNIX socket file, supervisor uses it to listen
chmod=0770                  ; Socket file permissions
chown=ubuntu:ubuntu         ; Socket file owner and group

[supervisord]
logfile=/dev/stdout         ; Main log file output to standard output
logfile_maxbytes=0          ; No limit on log size
loglevel=info               ; Log level
pidfile=/tmp/supervisord.pid ; Path of pidfile
nodaemon=true                ; Need to run in foreground in Docker
minfds=1024                  ; Minimum value of open file descriptors
minprocs=200                 ; Minimum number of processes
autoshutdown=true            ; Auto exit after all services stop

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; Socket connection to supervisord

; Xvfb virtual display configuration
[program:xvfb]
command=bash -c "rm -f /tmp/.X1-lock && Xvfb :1 -screen 0 1280x1029x24"
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
environment=DISPLAY=:1
priority=10

; Google Chrome configuration
[program:chrome]
command=chromium \
    --display=:1 \
    --window-size=1280,1029 \
    --start-maximized \
    --no-sandbox \
    --disable-dev-shm-usage \
    --disable-setuid-sandbox \
    --disable-accelerated-2d-canvas \
    --disable-gpu \
    --disable-features=WelcomeExperience,SigninPromo \
    --no-first-run \
    --no-default-browser-check \
    --disable-infobars \
    --test-type \
    --disable-popup-blocking \
    --disable-gpu-sandbox \
    --no-xshm \
    --new-window=false \
    --disable-notifications \
    --disable-extensions \
    --disable-component-extensions-with-background-pages \
    --disable-popup-blocking \
    --disable-prompt-on-repost \
    --disable-dialogs \
    --disable-modal-dialogs \
    --disable-web-security \
    --disable-site-isolation-trials \
    --remote-debugging-address=0.0.0.0 \
    --remote-debugging-port=8222 %(ENV_CHROME_ARGS)s
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
environment=DISPLAY=:1
priority=20
startretries=3
startsecs=5

; socat port forwarding configuration
[program:socat]
command=socat TCP-LISTEN:9222,bind=0.0.0.0,fork,reuseaddr TCP:127.0.0.1:8222
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
priority=30
startsecs=2

; VNC service configuration
[program:x11vnc]
command=x11vnc -display :1 -nopw -shared -listen 0.0.0.0 -xkb -forever -rfbport 5900
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
environment=DISPLAY=:1
priority=40
startsecs=3

; Websockify configuration - Convert VNC to WebSocket
[program:websockify]
command=websockify 0.0.0.0:5901 localhost:5900
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
priority=45
startsecs=3

; FastAPI application configuration
[program:app]
command=uvicorn app.main:app --host 0.0.0.0 --port 8080 %(ENV_UVI_ARGS)s
directory=/app
user=ubuntu
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0
environment=HOME=/home/ubuntu
priority=50

; Group configuration, can start or stop multiple programs at once
[group:services]
programs=xvfb,chrome,socat,x11vnc,websockify,app 


================================================
FILE: sandbox/app/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/main.py
================================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging
import sys

from app.core.config import settings
from app.api.router import api_router
from app.core.exceptions import (
    AppException, 
    app_exception_handler, 
    http_exception_handler, 
    validation_exception_handler,
    general_exception_handler
)
from app.core.middleware import auto_extend_timeout_middleware

# Configure logging
def setup_logging():
    """
    Set up the application logging system
    
    Configures log level, format, and handlers based on application settings.
    Outputs logs to stdout for container compatibility.
    """
    log_level = getattr(logging, settings.LOG_LEVEL)
    log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    
    logging.basicConfig(
        level=log_level,
        format=log_format,
        handlers=[logging.StreamHandler(sys.stdout)]
    )
    # Get root logger
    root_logger = logging.getLogger()
    
    # Set root log level
    log_level = getattr(logging, settings.LOG_LEVEL)
    root_logger.setLevel(log_level)
    
    # Log setup completion
    logging.info("Sandbox logging system initialized with level: %s", settings.LOG_LEVEL)

# Initialize logging
setup_logging()
logger = logging.getLogger(__name__)

app = FastAPI(
    version="1.0.0",
)

# Set up CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

logger.info("Sandbox API server starting")

# Register middleware
app.middleware("http")(auto_extend_timeout_middleware)

# Register exception handlers
app.add_exception_handler(AppException, app_exception_handler)
app.add_exception_handler(StarletteHTTPException, http_exception_handler)
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)

# Register routes
app.include_router(api_router, prefix="/api/v1")

logger.info("Sandbox API routes registered and server ready")


================================================
FILE: sandbox/app/api/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/api/router.py
================================================
from fastapi import APIRouter

from app.api.v1 import shell, supervisor, file

api_router = APIRouter()
api_router.include_router(shell.router, prefix="/shell", tags=["shell"])
api_router.include_router(supervisor.router, prefix="/supervisor", tags=["supervisor"])
api_router.include_router(file.router, prefix="/file", tags=["file"])



================================================
FILE: sandbox/app/api/v1/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/api/v1/file.py
================================================
"""
File operation API interfaces
"""
from fastapi import APIRouter, UploadFile, File, Form
from fastapi.responses import FileResponse
from app.schemas.file import (
    FileReadRequest, FileWriteRequest, FileReplaceRequest,
    FileSearchRequest, FileFindRequest
)
from app.schemas.response import Response
from app.services.file import file_service

router = APIRouter()

@router.post("/read", response_model=Response)
async def read_file(request: FileReadRequest):
    """
    Read file content
    """
    result = await file_service.read_file(
        file=request.file,
        start_line=request.start_line,
        end_line=request.end_line,
        sudo=request.sudo,
        max_length=request.max_length
    )
    
    # Construct response
    return Response(
        success=True,
        message="File read successfully",
        data=result.model_dump()
    )

@router.post("/write", response_model=Response)
async def write_file(request: FileWriteRequest):
    """
    Write file content
    """
    result = await file_service.write_file(
        file=request.file,
        content=request.content,
        append=request.append,
        leading_newline=request.leading_newline,
        trailing_newline=request.trailing_newline,
        sudo=request.sudo
    )
    
    # Construct response
    return Response(
        success=True,
        message="File written successfully",
        data=result.model_dump()
    )

@router.post("/replace", response_model=Response)
async def replace_in_file(request: FileReplaceRequest):
    """
    Replace string in file
    """
    result = await file_service.str_replace(
        file=request.file,
        old_str=request.old_str,
        new_str=request.new_str,
        sudo=request.sudo
    )
    
    # Construct response
    return Response(
        success=True,
        message=f"Replacement completed, replaced {result.replaced_count} occurrences",
        data=result.model_dump()
    )

@router.post("/search", response_model=Response)
async def search_in_file(request: FileSearchRequest):
    """
    Search in file content
    """
    result = await file_service.find_in_content(
        file=request.file,
        regex=request.regex,
        sudo=request.sudo
    )
    
    # Construct response
    return Response(
        success=True,
        message=f"Search completed, found {len(result.matches)} matches",
        data=result.model_dump()
    )

@router.post("/find", response_model=Response)
async def find_files(request: FileFindRequest):
    """
    Find files by name pattern
    """
    result = await file_service.find_by_name(
        path=request.path,
        glob_pattern=request.glob
    )
    
    # Construct response
    return Response(
        success=True,
        message=f"Search completed, found {len(result.files)} files",
        data=result.model_dump()
    )

@router.post("/upload")
async def upload_file(
    file: UploadFile = File(...),
    path: str = Form(None)
):
    """
    Upload file using streaming
    """
    if not path:
        path = f"/tmp/{file.filename}"
    
    result = await file_service.upload_file(
        path=path,
        file_stream=file
    )
    
    return Response(
        success=True,
        message="File uploaded successfully",
        data=result.model_dump()
    )

@router.get("/download")
async def download_file(path: str):
    """
    Download file using FileResponse
    """
    # Check if file exists (this will raise appropriate exception if not found)
    file_service.ensure_file(path)
    
    # Determine filename from path
    filename = path.split('/')[-1]
    
    return FileResponse(
        path=path,
        filename=filename,
        media_type='application/octet-stream'
    )



================================================
FILE: sandbox/app/api/v1/shell.py
================================================
from fastapi import APIRouter
from app.schemas.shell import (
    ShellExecRequest, ShellViewRequest, ShellWaitRequest,
    ShellWriteToProcessRequest, ShellKillProcessRequest,
)
from app.schemas.response import Response
from app.services.shell import shell_service
from app.core.exceptions import BadRequestException

router = APIRouter()

@router.post("/exec", response_model=Response)
async def exec_command(request: ShellExecRequest):
    """
    Execute command in the specified shell session
    """
    # If no session ID is provided, automatically create one
    if not request.id or request.id == "":
        request.id = shell_service.create_session_id()
        
    result = await shell_service.exec_command(
        session_id=request.id,
        exec_dir=request.exec_dir,
        command=request.command
    )
    
    # Construct response
    return Response(
        success=True,
        message="Command executed",
        data=result.model_dump()
    )

@router.post("/view", response_model=Response)
async def view_shell(request: ShellViewRequest):
    """
    View output of the specified shell session
    """
    if not request.id or request.id == "":
        raise BadRequestException("Session ID not provided")
        
    result = await shell_service.view_shell(session_id=request.id, console=request.console)
    
    # Construct response
    return Response(
        success=True,
        message="Session content retrieved successfully",
        data=result.model_dump()
    )

@router.post("/wait", response_model=Response)
async def wait_for_process(request: ShellWaitRequest):
    """
    Wait for the process in the specified shell session to return
    """
    result = await shell_service.wait_for_process(
        session_id=request.id,
        seconds=request.seconds
    )
    
    # Construct response
    return Response(
        success=True,
        message=f"Process completed, return code: {result.returncode}",
        data=result.model_dump()
    )

@router.post("/write", response_model=Response)
async def write_to_process(request: ShellWriteToProcessRequest):
    """
    Write input to the process in the specified shell session
    """
    if not request.id or request.id == "":
        raise BadRequestException("Session ID not provided")
        
    result = await shell_service.write_to_process(
        session_id=request.id,
        input_text=request.input,
        press_enter=request.press_enter
    )
    
    # Construct response
    return Response(
        success=True,
        message="Input written",
        data=result.model_dump()
    )

@router.post("/kill", response_model=Response)
async def kill_process(request: ShellKillProcessRequest):
    """
    Terminate the process in the specified shell session
    """
    result = await shell_service.kill_process(session_id=request.id)
    
    # Construct response
    message = "Process terminated" if result.status == "terminated" else "Process ended"
    return Response(
        success=True,
        message=message,
        data=result.model_dump()
    )


================================================
FILE: sandbox/app/api/v1/supervisor.py
================================================
from fastapi import APIRouter
from pydantic import BaseModel
from typing import Optional

from app.schemas.response import Response
from app.services.supervisor import supervisor_service


# Request model
class TimeoutRequest(BaseModel):
    minutes: Optional[int] = None


router = APIRouter()

@router.get("/status", response_model=Response)
async def get_status():
    """
    Get status of all services
    """
    processes = await supervisor_service.get_all_processes()
    return Response(
        success=True,
        message="Services status retrieved successfully",
        data=processes
    )

@router.post("/stop", response_model=Response)
async def stop_services():
    """
    Stop all services
    """
    result = await supervisor_service.stop_all_services()
    return Response(
        success=True,
        message="All services stopped",
        data=result
    )

@router.post("/shutdown", response_model=Response)
async def shutdown_supervisor():
    """
    Shutdown only the supervisord service itself
    """
    result = await supervisor_service.shutdown()
    return Response(
        success=True,
        message="Supervisord service shutdown",
        data=result
    )

@router.post("/restart", response_model=Response)
async def restart_services():
    """
    Restart all services
    """
    result = await supervisor_service.restart_all_services()
    return Response(
        success=True,
        message="All services restarted",
        data=result
    )

@router.post("/timeout/activate", response_model=Response)
async def activate_timeout(request: TimeoutRequest):
    """
    Reset timeout feature, automatically shut down all services after the specified time
    
    minutes: Optional, timeout duration (minutes), if not provided, system default configuration will be used
    """
    result = await supervisor_service.activate_timeout(request.minutes)
    # Disable auto-expand since user explicitly controls timeout
    supervisor_service.disable_auto_expand()
    return Response(
        success=True,
        message=f"Timeout reset, all services will be shut down after {result.timeout_minutes} minutes",
        data=result.model_dump()
    )

@router.post("/timeout/extend", response_model=Response)
async def extend_timeout(request: TimeoutRequest):
    """
    Extend timeout duration
    
    minutes: Optional, number of minutes to extend, if not provided, system default configuration will be used
    """
    result = await supervisor_service.extend_timeout(request.minutes)
    # Disable auto-expand since user explicitly controls timeout
    supervisor_service.disable_auto_expand()
    return Response(
        success=True,
        message=f"Timeout extended, all services will be shut down after {result.timeout_minutes} minutes",
        data=result.model_dump()
    )

@router.post("/timeout/cancel", response_model=Response)
async def cancel_timeout():
    """
    Cancel timeout feature
    """
    result = await supervisor_service.cancel_timeout()
    return Response(
        success=True,
        message="Timeout cancelled" if result.status == "timeout_cancelled" else "No active timeout",
        data=result.model_dump()
    )

@router.get("/timeout/status", response_model=Response)
async def get_timeout_status():
    """
    Get timeout status
    """
    result = await supervisor_service.get_timeout_status()
    message = "No active timeout" if not result.active else f"Remaining time: {result.remaining_seconds // 60} minutes"
    return Response(
        success=True,
        message=message,
        data=result.model_dump()
    ) 


================================================
FILE: sandbox/app/core/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/core/config.py
================================================
from typing import List, Optional, Union
from pydantic import field_validator
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    ORIGINS: List[str] = ["*"]
    
    # Service timeout settings (minutes)
    SERVICE_TIMEOUT_MINUTES: Optional[int] = None
    
    # Log configuration
    LOG_LEVEL: str = "INFO"
    
    @field_validator("ORIGINS", mode="before")
    def assemble_cors_origins(cls, v: Union[str, List[str]]) -> Union[List[str], str]:
        if isinstance(v, str) and not v.startswith("["):
            return [i.strip() for i in v.split(",")]
        elif isinstance(v, (list, str)):
            return v
        raise ValueError(v)

    class Config:
        case_sensitive = True
        env_file = ".env"


settings = Settings() 


================================================
FILE: sandbox/app/core/exceptions.py
================================================
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from typing import Any
from app.schemas.response import Response
import logging

# Get logger
logger = logging.getLogger(__name__)

# Custom exception classes
class AppException(Exception):
    """Base application exception class"""
    def __init__(
        self, 
        message: str = "An error occurred", 
        status_code: int = status.HTTP_500_INTERNAL_SERVER_ERROR,
        data: Any = None
    ):
        self.message = message
        self.status_code = status_code
        self.data = data
        logger.error("AppException: %s (code: %d)", message, status_code)
        super().__init__(self.message)

class ResourceNotFoundException(AppException):
    """Resource not found exception"""
    def __init__(self, message: str = "Resource not found"):
        super().__init__(message=message, status_code=status.HTTP_404_NOT_FOUND)

class BadRequestException(AppException):
    """Bad request exception"""
    def __init__(self, message: str = "Bad request"):
        super().__init__(message=message, status_code=status.HTTP_400_BAD_REQUEST)

class UnauthorizedException(AppException):
    """Unauthorized exception"""
    def __init__(self, message: str = "Unauthorized"):
        super().__init__(message=message, status_code=status.HTTP_401_UNAUTHORIZED)

# Exception handlers
async def app_exception_handler(request: Request, exc: AppException):
    """Handle application custom exceptions"""
    logger.error("Processing application exception: %s", exc.message)
    response = Response.error(
        message=exc.message,
        data=exc.data
    )
    return JSONResponse(
        status_code=exc.status_code,
        content=response.model_dump()
    )

async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    """Handle HTTP exceptions"""
    logger.error("Processing HTTP exception: %s (code: %d)", exc.detail, exc.status_code)
    response = Response.error(
        message=str(exc.detail)
    )
    return JSONResponse(
        status_code=exc.status_code,
        content=response.model_dump()
    )

async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle validation exceptions"""
    errors = exc.errors()
    error_messages = []
    for error in errors:
        error_messages.append({
            "loc": error.get("loc", []),
            "msg": error.get("msg", ""),
            "type": error.get("type", "")
        })
    
    logger.error("Validation error: %s", error_messages)
    response = Response.error(
        message="Request data validation failed",
        data=error_messages
    )
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=response.model_dump()
    )

async def general_exception_handler(request: Request, exc: Exception):
    """Handle all other exceptions"""
    error_message = f"Internal server error: {str(exc)}"
    logger.error("Unhandled exception: %s", error_message, exc_info=True)
    response = Response.error(
        message=error_message
    )
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content=response.model_dump()
    ) 


================================================
FILE: sandbox/app/core/middleware.py
================================================
import logging
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response

from app.core.config import settings

logger = logging.getLogger(__name__)


async def auto_extend_timeout_middleware(request: Request, call_next):
    """
    Middleware to automatically extend timeout on every API request
    Only auto-extends when auto-expand is enabled (disabled when user explicitly manages timeout)
    """
    from app.services.supervisor import supervisor_service
    
    # Only extend timeout if timeout is currently active, it's an API request, 
    # and not a timeout management API call, and auto-expand is enabled
    if (settings.SERVICE_TIMEOUT_MINUTES is not None and
        supervisor_service.timeout_active and 
        request.url.path.startswith("/api/") and
        not request.url.path.startswith("/api/v1/supervisor/timeout/") and
        supervisor_service.auto_expand_enabled):
        try:
            await supervisor_service.extend_timeout()
            logger.debug("Timeout automatically extended due to API request: %s", request.url.path)
        except Exception as e:
            logger.warning("Failed to auto-extend timeout: %s", str(e))
    
    response = await call_next(request)
    return response 


================================================
FILE: sandbox/app/models/__init__.py
================================================
"""
业务模型定义
"""
from app.models.shell import ShellExecResult, ShellViewResult, ShellWaitResult, ShellWriteResult, ShellKillResult
from app.models.supervisor import ProcessInfo, SupervisorActionResult, SupervisorTimeout
from app.models.file import FileReadResult, FileWriteResult, FileReplaceResult, FileSearchResult, FileFindResult

__all__ = [
    'ShellExecResult', 'ShellViewResult', 'ShellWaitResult', 'ShellWriteResult', 'ShellKillResult',
    'ProcessInfo', 'SupervisorActionResult', 'SupervisorTimeout',
    'FileReadResult', 'FileWriteResult', 'FileReplaceResult', 'FileSearchResult', 'FileFindResult'
]



================================================
FILE: sandbox/app/models/file.py
================================================
"""
File operation related models
"""
from pydantic import BaseModel, Field
from typing import List, Optional


class FileReadResult(BaseModel):
    """File read result"""
    content: str = Field(..., description="File content")
    file: str = Field(..., description="Path of the read file")


class FileWriteResult(BaseModel):
    """File write result"""
    file: str = Field(..., description="Path of the written file")
    bytes_written: Optional[int] = Field(None, description="Number of bytes written")


class FileReplaceResult(BaseModel):
    """File content replacement result"""
    file: str = Field(..., description="Path of the operated file")
    replaced_count: int = Field(0, description="Number of replacements")


class FileSearchResult(BaseModel):
    """File content search result"""
    file: str = Field(..., description="Path of the searched file")
    matches: List[str] = Field([], description="List of matched content")
    line_numbers: List[int] = Field([], description="List of matched line numbers")


class FileFindResult(BaseModel):
    """File find result"""
    path: str = Field(..., description="Path of the search directory")
    files: List[str] = Field([], description="List of found files")


class FileUploadResult(BaseModel):
    """File upload result"""
    file_path: str = Field(..., description="Path of the uploaded file")
    file_size: int = Field(..., description="Size of the uploaded file in bytes")
    success: bool = Field(..., description="Whether upload was successful")



================================================
FILE: sandbox/app/models/shell.py
================================================
"""
Shell business model definitions
"""
from typing import Optional, List
from pydantic import BaseModel, Field


class ConsoleRecord(BaseModel):
    """Shell command console record model"""
    ps1: str = Field(..., description="Command prompt")
    command: str = Field(..., description="Executed command")
    output: str = Field(default="", description="Command output")


class ShellTask(BaseModel):
    """Shell task model"""
    id: str = Field(..., description="Task unique identifier")
    command: str = Field(..., description="Executed command")
    status: str = Field(..., description="Task status")
    created_at: str = Field(..., description="Task creation time")
    output: Optional[str] = Field(None, description="Task output")


class ShellExecResult(BaseModel):
    """Shell command execution result model"""
    session_id: str = Field(..., description="Shell session ID")
    command: str = Field(..., description="Executed command")
    status: str = Field(..., description="Command execution status")
    returncode: Optional[int] = Field(None, description="Process return code, only has value when status is completed")
    output: Optional[str] = Field(None, description="Command execution output, only has value when status is completed")


class ShellViewResult(BaseModel):
    """Shell session content view result model"""
    output: str = Field(..., description="Shell session output content")
    session_id: str = Field(..., description="Shell session ID")
    console: Optional[List[ConsoleRecord]] = Field(None, description="Console command records")


class ShellWaitResult(BaseModel):
    """Process wait result model"""
    returncode: int = Field(..., description="Process return code")


class ShellWriteResult(BaseModel):
    """Process input write result model"""
    status: str = Field(..., description="Write status")


class ShellKillResult(BaseModel):
    """Process termination result model"""
    status: str = Field(..., description="Process status")
    returncode: int = Field(..., description="Process return code") 


================================================
FILE: sandbox/app/models/supervisor.py
================================================
"""
Supervisor business model definitions
"""
from typing import Optional, List
from pydantic import BaseModel, Field


class ProcessInfo(BaseModel):
    """Process information model"""
    name: str = Field(..., description="Process name")
    group: str = Field(..., description="Process group")
    description: str = Field(..., description="Process description")
    start: int = Field(..., description="Start timestamp")
    stop: int = Field(..., description="Stop timestamp")
    now: int = Field(..., description="Current timestamp")
    state: int = Field(..., description="State code")
    statename: str = Field(..., description="State name")
    spawnerr: str = Field(..., description="Spawn error")
    exitstatus: int = Field(..., description="Exit status code")
    logfile: str = Field(..., description="Log file")
    stdout_logfile: str = Field(..., description="Standard output log file")
    stderr_logfile: str = Field(..., description="Standard error log file")
    pid: int = Field(..., description="Process ID")


class SupervisorActionResult(BaseModel):
    """Supervisor operation result model"""
    status: str = Field(..., description="Operation status")
    result: Optional[List[str]] = Field(None, description="Operation result")
    stop_result: Optional[List[str]] = Field(None, description="Stop result")
    start_result: Optional[List[str]] = Field(None, description="Start result")
    shutdown_result: Optional[List[str]] = Field(None, description="Shutdown result")


class SupervisorTimeout(BaseModel):
    """Supervisor timeout model"""
    status: Optional[str] = Field(None, description="Timeout setting status")
    active: bool = Field(False, description="Whether timeout is active")
    shutdown_time: Optional[str] = Field(None, description="Shutdown time")
    timeout_minutes: Optional[float] = Field(None, description="Timeout duration (minutes)")
    remaining_seconds: Optional[float] = Field(None, description="Remaining seconds") 


================================================
FILE: sandbox/app/schemas/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/schemas/file.py
================================================
"""
File operation request models
"""
from pydantic import BaseModel, Field
from typing import Optional


class FileReadRequest(BaseModel):
    """File read request"""
    file: str = Field(..., description="Absolute file path")
    start_line: Optional[int] = Field(None, description="Start line (0-based)")
    end_line: Optional[int] = Field(None, description="End line (not inclusive)")
    sudo: Optional[bool] = Field(False, description="Whether to use sudo privileges")
    max_length: Optional[int] = Field(10000, description="Maximum length of the content to return")

class FileWriteRequest(BaseModel):
    """File write request"""
    file: str = Field(..., description="Absolute file path")
    content: str = Field(..., description="Content to write")
    append: Optional[bool] = Field(False, description="Whether to use append mode")
    leading_newline: Optional[bool] = Field(False, description="Whether to add leading newline")
    trailing_newline: Optional[bool] = Field(False, description="Whether to add trailing newline")
    sudo: Optional[bool] = Field(False, description="Whether to use sudo privileges")


class FileReplaceRequest(BaseModel):
    """File content replacement request"""
    file: str = Field(..., description="Absolute file path")
    old_str: str = Field(..., description="Original string to replace")
    new_str: str = Field(..., description="New string to replace with")
    sudo: Optional[bool] = Field(False, description="Whether to use sudo privileges")


class FileSearchRequest(BaseModel):
    """File content search request"""
    file: str = Field(..., description="Absolute file path")
    regex: str = Field(..., description="Regular expression pattern")
    sudo: Optional[bool] = Field(False, description="Whether to use sudo privileges")


class FileFindRequest(BaseModel):
    """File find request"""
    path: str = Field(..., description="Directory path to search")
    glob: str = Field(..., description="Filename pattern (glob syntax)")



================================================
FILE: sandbox/app/schemas/response.py
================================================
from typing import Optional, Any
from pydantic import BaseModel, Field

# Unified response model
class Response(BaseModel):
    """Generic response model for API interface return results"""
    success: bool = Field(True, description="Whether the operation was successful")
    message: Optional[str] = Field("Operation successful", description="Operation result message")
    data: Optional[Any] = Field(None, description="Data returned from the operation")

    # Shortcut method to create error response
    @classmethod
    def error(cls, message: str, data: Any = None) -> "Response":
        """Create an error response instance"""
        return cls(success=False, message=message, data=data) 


================================================
FILE: sandbox/app/schemas/shell.py
================================================
from pydantic import BaseModel, Field
from typing import Optional

class ShellExecRequest(BaseModel):
    """Shell command execution request model"""
    id: Optional[str] = Field(None, description="Unique identifier of the target shell session, if not provided, one will be automatically created")
    exec_dir: Optional[str] = Field(None, description="Working directory for command execution (must use absolute path)")
    command: str = Field(..., description="Shell command to execute")


class ShellViewRequest(BaseModel):
    """Shell session content view request model"""
    id: str = Field(..., description="Unique identifier of the target shell session")
    console: Optional[bool] = Field(False, description="Whether to return console records")


class ShellWaitRequest(BaseModel):
    """Shell process wait request model"""
    id: str = Field(..., description="Unique identifier of the target shell session")
    seconds: Optional[int] = Field(None, description="Wait time (seconds)")


class ShellWriteToProcessRequest(BaseModel):
    """Request model for writing input to a running process"""
    id: str = Field(..., description="Unique identifier of the target shell session")
    input: str = Field(..., description="Input content to write to the process")
    press_enter: bool = Field(..., description="Whether to press enter key after input")


class ShellKillProcessRequest(BaseModel):
    """Request model for terminating a running process"""
    id: str = Field(..., description="Unique identifier of the target shell session")



================================================
FILE: sandbox/app/services/__init__.py
================================================
[Empty file]


================================================
FILE: sandbox/app/services/file.py
================================================
"""
File Operation Service Implementation - Async Version
"""
import os
import re
import glob
import asyncio
import subprocess
import mimetypes
from typing import Optional, BinaryIO
from fastapi import UploadFile
from app.models.file import (
    FileReadResult, FileWriteResult, FileReplaceResult,
    FileSearchResult, FileFindResult, FileUploadResult
)
from app.core.exceptions import AppException, ResourceNotFoundException, BadRequestException


class FileService:
    """File Operation Service"""

    async def read_file(self, file: str, start_line: Optional[int] = None, 
                 end_line: Optional[int] = None, sudo: bool = False, max_length: Optional[int] = 10000) -> FileReadResult:
        """
        Asynchronously read file content
        
        Args:
            file: Absolute file path
            start_line: Starting line (0-based)
            end_line: Ending line (not included)
            sudo: Whether to use sudo privileges
        """
        # Check if file exists
        if not os.path.exists(file) and not sudo:
            raise ResourceNotFoundException(f"File does not exist: {file}")
        
        try:
            content = ""
            
            # Read with sudo
            if sudo:
                command = f"sudo cat '{file}'"
                process = await asyncio.create_subprocess_shell(
                    command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await process.communicate()
                
                if process.returncode != 0:
                    raise BadRequestException(f"Failed to read file: {stderr.decode()}")
                
                content = stdout.decode('utf-8')
            else:
                # Asynchronously read file
                def read_file_async():
                    try:
                        with open(file, 'r', encoding='utf-8') as f:
                            return f.read()
                    except Exception as e:
                        raise AppException(message=f"Failed to read file: {str(e)}")
                
                # Execute IO operation in thread pool
                content = await asyncio.to_thread(read_file_async)
            
            # Process line range
            if start_line is not None or end_line is not None:
                lines = content.splitlines()
                start = start_line if start_line is not None else 0
                end = end_line if end_line is not None else len(lines)
                content = '\n'.join(lines[start:end])
            
            if max_length is not None and max_length > 0 and len(content) > max_length:
                content = content[:max_length] + "(truncated)"
            
            return FileReadResult(
                content=content,
                file=file
            )
        except Exception as e:
            if isinstance(e, BadRequestException) or isinstance(e, ResourceNotFoundException):
                raise e
            raise AppException(message=f"Failed to read file: {str(e)}")

    async def write_file(self, file: str, content: str, append: bool = False,
                  leading_newline: bool = False, trailing_newline: bool = False,
                  sudo: bool = False) -> FileWriteResult:
        """
        Asynchronously write file content
        
        Args:
            file: Absolute file path
            content: Content to write
            append: Whether to append mode
            leading_newline: Whether to add a leading newline
            trailing_newline: Whether to add a trailing newline
            sudo: Whether to use sudo privileges
        """
        try:
            # Prepare content
            if leading_newline:
                content = '\n' + content
            if trailing_newline:
                content = content + '\n'
            
            bytes_written = 0
            
            # Write with sudo
            if sudo:
                mode = '>>' if append else '>'
                # Create temporary file
                temp_file = f"/tmp/file_write_{os.getpid()}.tmp"
                
                # Asynchronously write to temporary file
                def write_temp_file():
                    with open(temp_file, 'w', encoding='utf-8') as f:
                        f.write(content)
                    return len(content.encode('utf-8'))
                
                bytes_written = await asyncio.to_thread(write_temp_file)
                
                # Use sudo to write temporary file content to target file
                command = f"sudo bash -c \"cat {temp_file} {mode} '{file}'\""
                process = await asyncio.create_subprocess_shell(
                    command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await process.communicate()
                
                if process.returncode != 0:
                    raise BadRequestException(f"Failed to write file: {stderr.decode()}")
                
                # Clean up temporary file
                os.unlink(temp_file)
            else:
                # Ensure directory exists
                os.makedirs(os.path.dirname(file), exist_ok=True)
                
                # Asynchronously write file
                def write_file_async():
                    mode = 'a' if append else 'w'
                    with open(file, mode, encoding='utf-8') as f:
                        return f.write(content)
                
                bytes_written = await asyncio.to_thread(write_file_async)
            
            return FileWriteResult(
                file=file,
                bytes_written=bytes_written
            )
        except Exception as e:
            if isinstance(e, BadRequestException):
                raise e
            raise AppException(message=f"Failed to write file: {str(e)}")

    async def str_replace(self, file: str, old_str: str, new_str: str, 
                   sudo: bool = False) -> FileReplaceResult:
        """
        Asynchronously replace string in file
        
        Args:
            file: Absolute file path
            old_str: Original string to be replaced
            new_str: New replacement string
            sudo: Whether to use sudo privileges
        """
        # First read file content
        file_result = await self.read_file(file, sudo=sudo)
        content = file_result.content
        
        # Calculate replacement count
        replaced_count = content.count(old_str)
        if replaced_count == 0:
            return FileReplaceResult(
                file=file,
                replaced_count=0
            )
        
        # Perform replacement
        new_content = content.replace(old_str, new_str)
        
        # Write back to file
        await self.write_file(file, new_content, sudo=sudo)
        
        return FileReplaceResult(
            file=file,
            replaced_count=replaced_count
        )

    async def find_in_content(self, file: str, regex: str, 
                       sudo: bool = False) -> FileSearchResult:
        """
        Asynchronously search in file content
        
        Args:
            file: Absolute file path
            regex: Regular expression pattern
            sudo: Whether to use sudo privileges
        """
        # Read file
        file_result = await self.read_file(file, sudo=sudo)
        content = file_result.content
        
        # Process line by line
        lines = content.splitlines()
        matches = []
        line_numbers = []
        
        # Compile regular expression
        try:
            pattern = re.compile(regex)
        except Exception as e:
            raise BadRequestException(f"Invalid regular expression: {str(e)}")
        
        # Find matches (use async processing for possibly large files)
        def process_lines():
            nonlocal matches, line_numbers
            for i, line in enumerate(lines):
                if pattern.search(line):
                    matches.append(line)
                    line_numbers.append(i)
        
        await asyncio.to_thread(process_lines)
        
        return FileSearchResult(
            file=file,
            matches=matches,
            line_numbers=line_numbers
        )

    async def find_by_name(self, path: str, glob_pattern: str) -> FileFindResult:
        """
        Asynchronously find files by name pattern
        
        Args:
            path: Directory path to search
            glob_pattern: File name pattern (glob syntax)
        """
        # Check if path exists
        if not os.path.exists(path):
            raise ResourceNotFoundException(f"Directory does not exist: {path}")
        
        # Asynchronously find files
        def glob_async():
            search_pattern = os.path.join(path, glob_pattern)
            return glob.glob(search_pattern, recursive=True)
        
        files = await asyncio.to_thread(glob_async)
        
        return FileFindResult(
            path=path,
            files=files
        )

    async def upload_file(self, path: str, file_stream: UploadFile) -> FileUploadResult:
        """
        Upload file using streaming for large files
        
        Args:
            path: Target file path to save uploaded file
            file_stream: File stream from FastAPI UploadFile
        """
        try:
            chunk_size = 8192  # 8KB chunks
            total_size = 0
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(path), exist_ok=True)
            
            # Stream write directly to target file
            def write_stream_direct():
                nonlocal total_size
                with open(path, 'wb') as f:
                    while True:
                        chunk = file_stream.file.read(chunk_size)
                        if not chunk:
                            break
                        f.write(chunk)
                        total_size += len(chunk)
            
            await asyncio.to_thread(write_stream_direct)
            
            return FileUploadResult(
                file_path=path,
                file_size=total_size,
                success=True
            )
        except Exception as e:
            raise AppException(message=f"Failed to upload file: {str(e)}")

    def ensure_file(self, path: str) -> None:
        """
        Ensure file exists
        
        Args:
            path: Path of the file to check
        """
        try:
            # Check if file exists
            if not os.path.exists(path):
                raise ResourceNotFoundException(f"File does not exist: {path}")
                    
        except Exception as e:
            if isinstance(e, (BadRequestException, ResourceNotFoundException)):
                raise e
            raise AppException(message=f"Failed to ensure file: {str(e)}")


# Service instance
file_service = FileService()



================================================
FILE: sandbox/app/services/shell.py
================================================
"""
Shell Service Implementation - Async Version
"""
import os
import subprocess
import uuid
import getpass
import socket
import logging
import asyncio
import re
from typing import Dict, Any, Optional, List, Tuple
from app.models.shell import (
    ShellExecResult, ShellViewResult, ShellWaitResult,
    ShellWriteResult, ShellKillResult, ShellTask, ConsoleRecord
)
from app.core.exceptions import AppException, ResourceNotFoundException, BadRequestException

# Set up logger
logger = logging.getLogger(__name__)

class ShellService:
    # Store active shell sessions
    active_shells: Dict[str, Dict[str, Any]] = {}
    
    # Store shell tasks
    shell_tasks: Dict[str, ShellTask] = {}

    def _remove_ansi_escape_codes(self, text: str) -> str:
        """Remove ANSI escape codes from text"""
        # Pattern to match ANSI escape sequences
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        return ansi_escape.sub('', text)

    def _get_display_path(self, path: str) -> str:
        """Get the path for display, replacing user home directory with ~"""
        home_dir = os.path.expanduser("~")
        logger.debug(f"Home directory: {home_dir} , path: {path}")
        if path.startswith(home_dir):
            return path.replace(home_dir, "~", 1)
        return path

    def _format_ps1(self, exec_dir: str) -> str:
        """Format the command prompt"""
        username = getpass.getuser()
        hostname = socket.gethostname()
        display_dir = self._get_display_path(exec_dir)
        return f"{username}@{hostname}:{display_dir} $"

    async def _create_process(self, command: str, exec_dir: str) -> asyncio.subprocess.Process:
        """Create a new async subprocess"""
        logger.debug(f"Creating process for command: {command} in directory: {exec_dir}")
        return await asyncio.create_subprocess_shell(
            command,
            executable="/bin/bash",
            cwd=exec_dir,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.STDOUT,  # Redirect stderr to stdout
            stdin=asyncio.subprocess.PIPE,
            limit=1024*1024  # Set buffer size to 1MB
        )

    async def _start_output_reader(self, session_id: str, process: asyncio.subprocess.Process):
        """Start a coroutine to continuously read process output and store it"""
        logger.debug(f"Starting output reader for session: {session_id}")
        while True:
            if process.stdout:
                try:
                    buffer = await process.stdout.read(128)
                    if not buffer:
                        # Process output ended
                        break
                    
                    output = buffer.decode('utf-8')
                    # Add output to shell session
                    shell = self.active_shells.get(session_id)
                    if shell:
                        shell["output"] += output
                        # Update the output of the latest console record
                        if shell["console"]:
                            shell["console"][-1].output += output
                except Exception as e:
                    logger.error(f"Error reading process output: {str(e)}", exc_info=True)
                    break
            else:
                break
        
        logger.debug(f"Output reader for session {session_id} has finished")

    async def exec_command(self, session_id: str, exec_dir: Optional[str], command: str) -> ShellExecResult:
        """
        Asynchronously execute a command in the specified shell session
        """
        logger.info(f"Executing command in session {session_id}: {command}")
        if not exec_dir:
            exec_dir = os.path.expanduser("~")
        # Ensure directory exists
        if not os.path.exists(exec_dir):
            logger.error(f"Directory does not exist: {exec_dir}")
            raise BadRequestException(f"Directory does not exist: {exec_dir}")
        
        try:
            # Create PS1 format
            ps1 = self._format_ps1(exec_dir)
            
            # If it's a new session, create a new process
            if session_id not in self.active_shells:
                logger.debug(f"Creating new shell session: {session_id}")
                process = await self._create_process(command, exec_dir)
                self.active_shells[session_id] = {
                    "process": process,
                    "exec_dir": exec_dir,
                    "output": "",
                    "console": [ConsoleRecord(ps1=ps1, command=command, output="")]
                }
                # Start the output reader coroutine
                asyncio.create_task(self._start_output_reader(session_id, process))
            else:
                # Execute command in an existing session
                logger.debug(f"Using existing shell session: {session_id}")
                shell = self.active_shells[session_id]
                old_process = shell["process"]
                
                # If the old process is still running, terminate it first
                if old_process.returncode is None:
                    logger.debug(f"Terminating previous process in session: {session_id}")
                    try:
                        old_process.terminate()
                        await asyncio.wait_for(old_process.wait(), timeout=1)
                    except:
                        # If graceful termination fails, force kill
                        logger.warning(f"Forcefully killing process in session: {session_id}")
                        old_process.kill()
                
                # Create a new process
                process = await self._create_process(command, exec_dir)
                
                # Update session information
                self.active_shells[session_id]["process"] = process
                self.active_shells[session_id]["exec_dir"] = exec_dir
                self.active_shells[session_id]["output"] = ""  # Clear previous output
                
                # Record command console record, but output is initially empty, will be updated later
                shell["console"].append(ConsoleRecord(ps1=ps1, command=command, output=""))
                
                # Start the output reader coroutine
                asyncio.create_task(self._start_output_reader(session_id, process))
            
            # Try to wait for the process to complete (max 5 seconds)
            try:
                logger.debug(f"Waiting for process completion in session: {session_id}")
                wait_result = await self.wait_for_process(session_id, seconds=5)
                if wait_result.returncode is not None:
                    # Process has completed, get the output
                    logger.debug(f"Process completed with code: {wait_result.returncode}")
                    view_result = await self.view_shell(session_id)
                    
                    return ShellExecResult(
                        session_id=session_id,
                        command=command,
                        status="completed",
                        returncode=wait_result.returncode,
                        output=view_result.output,
                    )
            except BadRequestException:
                # Wait timeout, process still running
                logger.debug(f"Process still running after timeout in session: {session_id}")
                pass
            except Exception as e:
                # Other exceptions, ignore and continue
                logger.warning(f"Exception while waiting for process: {str(e)}")
                pass
            
            # Get current console records
            console = self.get_console_records(session_id)
            
            return ShellExecResult(
                session_id=session_id,
                command=command,
                status="running",
            )
        except Exception as e:
            logger.error(f"Command execution failed: {str(e)}", exc_info=True)
            raise AppException(
                message=f"Command execution failed: {str(e)}",
                data={"session_id": session_id, "command": command}
            )

    async def view_shell(self, session_id: str, console: bool = False) -> ShellViewResult:
        """
        Asynchronously view the content of the specified shell session
        """
        logger.debug(f"Viewing shell content for session: {session_id}")
        if session_id not in self.active_shells:
            logger.error(f"Session ID not found: {session_id}")
            raise ResourceNotFoundException(f"Session ID does not exist: {session_id}")
        
        shell = self.active_shells[session_id]
        
        # Get raw output and filter ANSI escape codes
        raw_output = shell["output"]
        clean_output = self._remove_ansi_escape_codes(raw_output)
        
        # Get command console records with filtered output
        if console:
            console = self.get_console_records(session_id)
        else:
            console = None
        
        return ShellViewResult(
            output=clean_output,
            session_id=session_id,
            console=console
        )

    def get_console_records(self, session_id: str) -> List[ConsoleRecord]:
        """
        Get command console records for the specified session (this method doesn't need to be async)
        """
        logger.debug(f"Getting console records for session: {session_id}")
        if session_id not in self.active_shells:
            logger.error(f"Session ID not found: {session_id}")
            raise ResourceNotFoundException(f"Session ID does not exist: {session_id}")
        
        # Get raw console records and filter ANSI escape codes
        raw_console = self.active_shells[session_id]["console"]
        clean_console = []
        for record in raw_console:
            clean_record = ConsoleRecord(
                ps1=record.ps1,
                command=record.command,
                output=self._remove_ansi_escape_codes(record.output)
            )
            clean_console.append(clean_record)
        
        return clean_console

    async def wait_for_process(self, session_id: str, seconds: Optional[int] = None) -> ShellWaitResult:
        """
        Asynchronously wait for the process in the specified shell session to return
        """
        logger.debug(f"Waiting for process in session: {session_id}, timeout: {seconds}s")
        if session_id not in self.active_shells:
            logger.error(f"Session ID not found: {session_id}")
            raise ResourceNotFoundException(f"Session ID does not exist: {session_id}")
        
        shell = self.active_shells[session_id]
        process = shell["process"]
        
        try:
            # Asynchronously wait for process to complete
            if seconds is None:
                seconds = 60
            await asyncio.wait_for(process.wait(), timeout=seconds)
            
            logger.info(f"Process completed with return code: {process.returncode}")
            return ShellWaitResult(
                returncode=process.returncode
            )
        except asyncio.TimeoutError:
            logger.warning(f"Process wait timeout expired: {seconds}s")
            raise BadRequestException(f"Wait timeout: {seconds} seconds")
        except Exception as e:
            logger.error(f"Failed to wait for process: {str(e)}", exc_info=True)
            raise AppException(message=f"Failed to wait for process: {str(e)}")

    async def write_to_process(self, session_id: str, input_text: str, press_enter: bool) -> ShellWriteResult:
        """
        Asynchronously write input to the process in the specified shell session
        """
        logger.debug(f"Writing to process in session: {session_id}, press_enter: {press_enter}")
        if session_id not in self.active_shells:
            logger.error(f"Session ID not found: {session_id}")
            raise ResourceNotFoundException(f"Session ID does not exist: {session_id}")
        
        shell = self.active_shells[session_id]
        process = shell["process"]
        
        try:
            # Check if the process is still running
            if process.returncode is not None:
                logger.error(f"Process has already terminated, cannot write input")
                raise BadRequestException("Process has ended, cannot write input")
            
            # Prepare input data
            if press_enter:
                input_data = f"{input_text}\n".encode()
            else:
                input_data = input_text.encode()
            
            # Add input to output and console records
            input_str = input_data.decode('utf-8')
            shell["output"] += input_str
            if shell["console"]:
                shell["console"][-1].output += input_str
            
            # Asynchronously write input
            process.stdin.write(input_data)
            await process.stdin.drain()
            
            logger.info(f"Successfully wrote input to process")
            
            return ShellWriteResult(
                status="success"
            )
        except Exception as e:
            logger.error(f"Failed to write input: {str(e)}", exc_info=True)
            raise AppException(message=f"Failed to write input: {str(e)}")

    async def kill_process(self, session_id: str) -> ShellKillResult:
        """
        Asynchronously terminate the process in the specified shell session
        """
        logger.info(f"Killing process in session: {session_id}")
        if session_id not in self.active_shells:
            logger.error(f"Session ID not found: {session_id}")
            raise ResourceNotFoundException(f"Session ID does not exist: {session_id}")
        
        shell = self.active_shells[session_id]
        process = shell["process"]
        
        try:
            # Check if the process is still running
            if process.returncode is None:
                # Try to terminate gracefully
                logger.debug(f"Attempting to terminate process gracefully")
                process.terminate()
                try:
                    await asyncio.wait_for(process.wait(), timeout=3)
                except asyncio.TimeoutError:
                    # If graceful termination fails, force kill
                    logger.warning(f"Forcefully killing the process")
                    process.kill()
                    await process.wait()
                
                logger.info(f"Process terminated with return code: {process.returncode}")
                return ShellKillResult(
                    status="terminated",
                    returncode=process.returncode
                )
            else:
                logger.info(f"Process was already terminated with return code: {process.returncode}")
                return ShellKillResult(
                    status="already_terminated",
                    returncode=process.returncode
                )
        except Exception as e:
            logger.error(f"Failed to kill process: {str(e)}", exc_info=True)
            raise AppException(message=f"Failed to terminate process: {str(e)}")

    def create_session_id(self) -> str:
        """
        Create a new session ID (this method doesn't need to be async)
        """
        session_id = str(uuid.uuid4())
        logger.debug(f"Created new session ID: {session_id}")
        return session_id

shell_service = ShellService()


================================================
FILE: sandbox/app/services/supervisor.py
================================================
import threading
import xmlrpc.client
import socket
import http.client
import asyncio
from datetime import datetime, timedelta
from typing import List

from app.core.config import settings
from app.core.exceptions import BadRequestException, ResourceNotFoundException
from app.models.supervisor import (
    ProcessInfo, 
    SupervisorActionResult, 
    SupervisorTimeout
)


# Add Unix socket support for xmlrpc client
class UnixStreamHTTPConnection(http.client.HTTPConnection):
    def __init__(self, host, socket_path, timeout=None):
        http.client.HTTPConnection.__init__(self, host, timeout=timeout)
        self.socket_path = socket_path

    def connect(self):
        self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.sock.connect(self.socket_path)


class UnixStreamTransport(xmlrpc.client.Transport):
    def __init__(self, socket_path):
        xmlrpc.client.Transport.__init__(self)
        self.socket_path = socket_path

    def make_connection(self, host):
        return UnixStreamHTTPConnection(host, self.socket_path)


class SupervisorService:
    """
    Supervisor service management class, used for managing service timeout and renewal functionality - Async version
    """
    def __init__(self):
        self.rpc_url = "/tmp/supervisor.sock"
        self._connect_rpc()
        
        # Timeout management - enabled based on configuration
        self.timeout_active = settings.SERVICE_TIMEOUT_MINUTES is not None
        self.shutdown_task = None
        self.shutdown_time = None
        # Auto-expand functionality - disabled when user explicitly controls timeout
        self._auto_expand_enabled = True
        
        # If timeout is configured, create scheduled task
        if settings.SERVICE_TIMEOUT_MINUTES is not None:
            self.shutdown_time = datetime.now() + timedelta(minutes=settings.SERVICE_TIMEOUT_MINUTES)
            self._setup_timer(settings.SERVICE_TIMEOUT_MINUTES)
    
    @property
    def auto_expand_enabled(self) -> bool:
        """Get auto-expand status"""
        return self._auto_expand_enabled
    
    def disable_auto_expand(self):
        """Disable auto-expand functionality (called when user explicitly manages timeout)"""
        self._auto_expand_enabled = False
    
    def enable_auto_expand(self):
        """Enable auto-expand functionality"""
        self._auto_expand_enabled = True
    
    def _connect_rpc(self):
        """Connect to supervisord's RPC interface"""
        try:
            self.server = xmlrpc.client.ServerProxy(
                'http://localhost',
                transport=UnixStreamTransport(self.rpc_url)
            )
            # Test connection
            self.server.supervisor.getState()
        except Exception as e:
            raise ResourceNotFoundException(f"Cannot connect to Supervisord: {str(e)}")
    
    def _setup_timer(self, minutes):
        """Set up async timer"""
        # Cancel existing scheduled task
        if self.shutdown_task:
            try:
                self.shutdown_task.cancel()
            except:
                pass
            
        # Create scheduled task function
        async def shutdown_after_timeout():
            await asyncio.sleep(minutes * 60)
            await self.shutdown()
        
        # Create scheduled task
        try:
            loop = asyncio.get_event_loop()
            self.shutdown_task = loop.create_task(shutdown_after_timeout())
        except Exception as e:
            # If async task creation fails, fall back to thread timer
            if hasattr(self, 'shutdown_timer') and self.shutdown_timer:
                self.shutdown_timer.cancel()
            
            self.shutdown_timer = threading.Timer(
                minutes * 60, 
                lambda: asyncio.run(self.shutdown())
            )
            self.shutdown_timer.daemon = True
            self.shutdown_timer.start()
    
    async def _call_rpc(self, method, *args):
        """Execute RPC call asynchronously"""
        try:
            return await asyncio.to_thread(method, *args)
        except Exception as e:
            raise BadRequestException(f"RPC call failed: {str(e)}")
    
    async def get_all_processes(self) -> List[ProcessInfo]:
        """Asynchronously get all process statuses"""
        try:
            processes = await self._call_rpc(self.server.supervisor.getAllProcessInfo)
            return [ProcessInfo(**process) for process in processes]
        except Exception as e:
            raise ResourceNotFoundException(f"Failed to get process status: {str(e)}")
    
    async def stop_all_services(self) -> SupervisorActionResult:
        """Asynchronously stop all services"""
        try:
            result = await self._call_rpc(self.server.supervisor.stopAllProcesses)
            return SupervisorActionResult(status="stopped", result=result)
        except Exception as e:
            raise BadRequestException(f"Failed to stop all services: {str(e)}")
    
    async def shutdown(self) -> SupervisorActionResult:
        """Asynchronously shut down the supervisord service itself, without stopping processes"""
        try:
            shutdown_result = await self._call_rpc(self.server.supervisor.shutdown)
            return SupervisorActionResult(status="shutdown", shutdown_result=shutdown_result)
        except Exception as e:
            raise BadRequestException(f"Failed to shut down supervisord service: {str(e)}")
    
    async def restart_all_services(self) -> SupervisorActionResult:
        """Asynchronously restart all services"""
        try:
            stop_result = await self._call_rpc(self.server.supervisor.stopAllProcesses)
            start_result = await self._call_rpc(self.server.supervisor.startAllProcesses)
            return SupervisorActionResult(
                status="restarted", 
                stop_result=stop_result,
                start_result=start_result
            )
        except Exception as e:
            raise BadRequestException(f"Failed to restart services: {str(e)}")
    
    async def activate_timeout(self, minutes=None) -> SupervisorTimeout:
        """
        Asynchronously activate timeout functionality, automatically shut down all services after the set time
        
        Args:
            minutes: Timeout in minutes, if None then use the configured default value
        """
        # Set timeout
        timeout_minutes = minutes or settings.SERVICE_TIMEOUT_MINUTES
        
        # If no timeout is specified and no default in config, throw error
        if timeout_minutes is None:
            raise BadRequestException("Timeout not specified, and system default is no timeout")
            
        self.timeout_active = True
        self.shutdown_time = datetime.now() + timedelta(minutes=timeout_minutes)
        
        # Set up timer
        self._setup_timer(timeout_minutes)
        
        return SupervisorTimeout(
            status="timeout_activated",
            active=True,
            shutdown_time=self.shutdown_time.isoformat(),
            timeout_minutes=timeout_minutes
        )
    
    async def extend_timeout(self, minutes=None) -> SupervisorTimeout:
        """
        Asynchronously extend timeout
        
        Args:
            minutes: Number of minutes to extend, if None then use the configured default value
        """
        # Set new timeout
        timeout_minutes = minutes or settings.SERVICE_TIMEOUT_MINUTES
        
        # If no timeout is specified and no default in config, throw error
        if timeout_minutes is None:
            raise BadRequestException("Timeout not specified, and system default is no timeout")
            
        self.timeout_active = True
        self.shutdown_time = datetime.now() + timedelta(minutes=timeout_minutes)
        
        # Set up timer
        self._setup_timer(timeout_minutes)
        
        return SupervisorTimeout(
            status="timeout_extended",
            active=True,
            shutdown_time=self.shutdown_time.isoformat(),
            timeout_minutes=timeout_minutes
        )
    
    async def cancel_timeout(self) -> SupervisorTimeout:
        """Asynchronously cancel timeout functionality"""
        if not self.timeout_active:
            return SupervisorTimeout(status="no_timeout_active", active=False)
        
        if self.shutdown_task:
            try:
                self.shutdown_task.cancel()
                self.shutdown_task = None
            except:
                pass
        
        # Also check thread timer (for compatibility)
        if hasattr(self, 'shutdown_timer') and self.shutdown_timer:
            self.shutdown_timer.cancel()
            self.shutdown_timer = None
        
        self.timeout_active = False
        self.shutdown_time = None
        # Re-enable auto-expand when timeout is cancelled
        self._auto_expand_enabled = True
        
        return SupervisorTimeout(status="timeout_cancelled", active=False)
    
    async def get_timeout_status(self) -> SupervisorTimeout:
        """Asynchronously get current timeout status"""
        if not self.timeout_active:
            return SupervisorTimeout(active=False)
        
        remaining_seconds = 0
        if self.shutdown_time:
            remaining = self.shutdown_time - datetime.now()
            remaining_seconds = max(0, remaining.total_seconds())
        
        return SupervisorTimeout(
            active=self.timeout_active,
            shutdown_time=self.shutdown_time.isoformat() if self.shutdown_time else None,
            remaining_seconds=remaining_seconds
        )


# Global instance
supervisor_service = SupervisorService() 


================================================
FILE: sandbox/resource/test_upload_unique.txt
================================================
This is test upload content


================================================
FILE: sandbox/tests/conftest.py
================================================
"""
Pytest configuration and fixtures
"""
import sys
import os
import pytest
import tempfile
from pathlib import Path

# Add the parent directory to Python path so we can import app modules
sys.path.insert(0, str(Path(__file__).parent.parent))

import requests

# Base URL for API testing
BASE_URL = "http://localhost:8080"

@pytest.fixture
def client():
    """Create requests session"""
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    return session


@pytest.fixture
def temp_test_file():
    """Create temporary test file path for container"""
    # Use container-accessible path
    temp_file = "/tmp/test_file.txt"
    # Create content via API
    import requests
    session = requests.Session()
    session.headers.update({"Content-Type": "application/json"})
    
    content = "Line 1: Hello World\nLine 2: This is a test\nLine 3: Python testing"
    session.post(f"{BASE_URL}/api/v1/file/write", json={
        "file": temp_file,
        "content": content
    })
    
    yield temp_file
    
    # Cleanup via API
    try:
        session.post(f"{BASE_URL}/api/v1/file/write", json={
            "file": temp_file,
            "content": ""
        })
    except:
        pass 


================================================
FILE: sandbox/tests/requirements.txt
================================================
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-cov>=4.0.0
pytest-mock>=3.10.0
requests>=2.28.0 


================================================
FILE: sandbox/tests/test_api_file.py
================================================
import pytest
import tempfile
import os
from unittest.mock import patch, mock_open
from conftest import BASE_URL
import logging


logger = logging.getLogger(__name__)


@pytest.mark.file_api
def test_upload_file_success(client):
    """Test successful file upload"""
    temp_path = "resource/test_upload_unique.txt"  # Use unique filename
    
    # Create test file content
    test_content = b"This is test upload content"
    
    # For file upload, create a new requests session without JSON headers
    import requests
    upload_client = requests.Session()
    
    response = upload_client.post(
        f"{BASE_URL}/api/v1/file/upload",
        files={"file": ("test.txt", test_content, "text/plain")},
        data={"path": temp_path}
    )
    
    assert response.status_code == 200
    data = response.json()

    logger.info(f"Upload response: {data}")

    assert data["success"] is True
    assert "File uploaded successfully" in data["message"]
    
    # Verify file was created via API
    read_response = client.post(f"{BASE_URL}/api/v1/file/read", json={
        "file": temp_path
    })
    read_data = read_response.json()
    logger.info(f"Read response: {read_data}")
    assert read_response.status_code == 200
    assert read_data["data"]["content"] == test_content.decode()


@pytest.mark.file_api
def test_download_file_success(client, temp_test_file):
    """Test successful file download"""
    response = client.get(f"{BASE_URL}/api/v1/file/download", params={"path": temp_test_file})
    
    assert response.status_code == 200
    assert response.headers["content-type"] == "application/octet-stream"
    assert "attachment" in response.headers.get("content-disposition", "")


@pytest.mark.file_api
def test_download_nonexistent_file(client):
    """Test downloading non-existent file"""
    response = client.get(f"{BASE_URL}/api/v1/file/download", params={"path": "1nonexistent.txt"})

    logger.info(f"Download response: {response.status_code}")
    
    assert response.status_code == 404 or response.status_code == 500



================================================
FILE: .github/workflows/docker-build-and-push.yml
================================================
name: Build and Push Docker Images to Docker Hub

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - develop

env:
  REGISTRY: docker.io
  IMAGE_REGISTRY: simpleyyt

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [frontend, backend, sandbox]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_REGISTRY }}/manus-${{ matrix.component }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.component }}
          file: ./${{ matrix.component }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max


